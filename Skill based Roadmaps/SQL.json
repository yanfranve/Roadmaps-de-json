{
    "Skill": {
        "SQL": {
            "description": "Step by step guide to learning SQL in 2023 ",
            "Introduction": {
                "description": "SQL, which stands for Structured Query Language, is a programming language that is used to communicate with and manage databases. SQL is a standard language for manipulating data held in relational database management systems (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It was first developed in the 1970s by IBM.\n\nSQL consists of several components, each serving their own unique purpose in database communication.Queries: This is the component that allows you to retrieve data from a database. The SELECT statement is most commonly used for this purpose.Data Definition Language (DDL): It lets you to create, alter, or delete databases and their related objects like tables, views, etc. Commands include CREATE, ALTER, DROP, and TRUNCATE.Data Manipulation Language (DML): It lets you manage data within database objects. These commands include SELECT, INSERT, UPDATE, and DELETE.Data Control Language (DCL): It includes commands like GRANT and REVOKE, which primarily deal with rights, permissions and other control-level management tasks for the database system.SQL databases come in a number of forms, such as Oracle Database, Microsoft SQL Server, and MySQL. Despite their many differences, all SQL databases utilise the same language commands - SQL.",
                "resources": [
                    {
                        "name": "SQL Tutorial - Mode",
                        "link": "https://mode.com/sql-tutorial/"
                    },
                    {
                        "name": "SQL Tutorial",
                        "link": "https://www.sqltutorial.org/"
                    },
                    {
                        "name": "SQL Tutorial - W3Schools",
                        "link": "https://www.w3schools.com/sql/default.asp"
                    }
                ],
                "order": 1,
                "options": [
                    {
                        "name": "What Are Relational Databases?",
                        "recommendation-type": "opinion",
                        "description": "A relational database is a type of database that stores and organizes data in a structured way. It uses a structure that allows data to be identified and accessed in relation to other data in the database. Data in a relational database is stored in various data tables, each of which has a unique key identifying every row.Relational databases are made up of a set of tables with data that fits into a predefined category. Each table has at least one data category in a column, and each row contains a certain data instance for the categories defined in the columns.Relationships The term “relational database” comes from the concept of a relation—a set of tuples that the database organizes into rows and columns. Each row in a table represents a relationship among a set of values.Relational databases use keys to create links between tables. A primary key is a unique identifier for a row of data. A foreign key is a column or combination of columns used to establish and enforce a link between the data in two tables.‘EmployeeId’ serves as the foreign key creating a relationship between ‘Orders’ and ‘Employees’. This allows queries that involve data in both tables, like “Find all orders placed by John Doe”. \nSELECT Orders.OrderId, Orders.Product, Employees.FirstName, Employees.LastName FROM Orders INNER JOIN Employees ON Orders.EmployeeId = Employees.EmployeeId;The above SQL code is an example of how to retrieve data from a relational database using a JOIN clause to combine rows from two or more tables. Overall, relational databases provide a powerful mechanism for defining relationships within data and enabling efficient data retrieval.",
                        "resources": []
                    },
                    {
                        "name": "RDBMS Benefits and Limitations",
                        "recommendation-type": "opinion",
                        "description": "Here are some of the benefits of using an RDBMS:\n\nStructured Data: RDBMS allows data storage in a structured way, using rows and columns in tables. This makes it easy to manipulate the data using SQL (Structured Query Language), ensuring efficient and flexible usage.\n\nACID Properties: ACID stands for Atomicity, Consistency, Isolation, and Durability. These properties ensure reliable and safe data manipulation in an RDBMS, making it suitable for mission-critical applications.Normalization: RDBMS supports data normalization, a process that organizes data in a way that reduces data redundancy and improves data integrity.\nScalability: RDBMSs generally provide good scalability options, allowing for the addition of more storage or computational resources as the data and workload grow.\nData Integrity: RDBMS provides mechanisms like constraints, primary keys, and foreign keys to enforce data integrity and consistency, ensuring that the data is accurate and reliable.\nSecurity: RDBMSs offer various security features such as user authentication, access control, and data encryption to protect sensitive data.Here are some of the limitations of using an RDBMS:\nComplexity: Setting up and managing an RDBMS can be complex, especially for large applications. It requires technical knowledge and skills to manage, tune, and optimize the database.\nCost: RDBMSs can be expensive, both in terms of licensing fees and the computational and storage resources they require.\nFixed Schema: RDBMS follows a rigid schema for data organization, which means any changes to the schema can be time-consuming and complicated.\nHandling of Unstructured Data: RDBMSs are not suitable for handling unstructured data like multimedia files, social media posts, and sensor data, as their relational structure is optimized for structured data.\nHorizontal Scalability: RDBMSs are not as easily horizontally scalable as NoSQL databases. Scaling horizontally, which involves adding more machines to the system, can be challenging in terms of cost and complexity.",
                        "resources": []
                    },
                    {
                        "SQL vs NoSQL": {
                            "description": "When discussing databases, it’s essential to understand the difference between SQL and NoSQL databases, as each has its own set of advantages and limitations. In this section, we’ll briefly compare and contrast the two, so you can determine which one suits your needs better.\n\nSQL Databases\nSQL (Structured Query Language) databases are also known as relational databases. They have a predefined schema, and data is stored in tables consisting of rows and columns. SQL databases follow the ACID (Atomicity, Consistency, Isolation, Durability) properties to ensure reliable transactions. Some popular SQL databases include MySQL, PostgreSQL, and Microsoft SQL Server.\n\nAdvantages of SQL databases:\n- Predefined schema: Ideal for applications with a fixed structure.\n- ACID transactions: Ensures data consistency and reliability.\n- Support for complex queries: Rich SQL queries can handle complex data relationships and aggregation operations.\n- Scalability: Vertical scaling by adding more resources to the server (e.g., RAM, CPU).\n\nLimitations of SQL databases:\n- Rigid schema: Data structure updates are time-consuming and can lead to downtime.\n- Scaling: Difficulties in horizontal scaling and sharding of data across multiple servers.\n- Not well-suited for hierarchical data: Requires multiple tables and JOINs to model tree-like structures.\n\nNoSQL Databases\nNoSQL (Not only SQL) databases refer to non-relational databases, which don’t follow a fixed schema for data storage. Instead, they use a flexible and semi-structured format like JSON documents, key-value pairs, or graphs. MongoDB, Cassandra, Redis, and Couchbase are some popular NoSQL databases.\n\nAdvantages of NoSQL databases:\n- Flexible schema: Easily adapts to changes without disrupting the application.\n- Scalability: Horizontal scaling by partitioning data across multiple servers (sharding).\n- Fast: Designed for faster read and writes, often with a simpler query language.\n- Handling large volumes of data: Better suited to managing big data and real-time applications.\n- Support for various data structures: Different NoSQL databases cater to various needs, like document, graph, or key-value stores.\n\nLimitations of NoSQL databases:\n- Limited query capabilities: Some NoSQL databases lack complex query and aggregation support or use specific query languages.\n- Weaker consistency: Many NoSQL databases follow the BASE (Basically Available, Soft state, Eventual consistency) properties that provide weaker consistency guarantees than ACID-compliant databases.\n\nMongoDB: A NoSQL Database\nThis guide focuses on MongoDB, a popular NoSQL database that uses a document-based data model. MongoDB has been designed with flexibility, performance, and scalability in mind. With its JSON-like data format (BSON) and powerful querying capabilities, MongoDB is an excellent choice for modern applications dealing with diverse and large-scale data.\n\nNoSQL vs. SQL Databases",
                            "resources": [
                                {
                                    "name": "NoSQL vs. SQL Databases",
                                    "link": "https://www.mongodb.com/nosql-explained/nosql-vs-sql"
                                }
                            ]
                        }
                    }
                ]
            },
            "Basic SQL Syntax": {
                "Basic SQL Syntax": {
                    "description": "SQL, or Structured Query Language, uses a specific set of commands to interact with a database. It includes the use of keyword-like statements to accomplish several tasks such as creating, deleting, or modifying tables, retrieving, inserting, or modifying data.\n\nThe SELECT statement is used to retrieve data from a database. The data returned is stored in a result table, called the result-set.\n\nSELECT column1, column2 FROM table_name;\n\nThe INSERT INTO statement is used to insert new rows of data in a table.\n\nINSERT INTO table_name (column1, column2, column3) VALUES (value1, value2, value3);\n\nThe UPDATE statement is used to modify existing records in a table.\n\nUPDATE table_name\nSET column1 = value1, column2 = value2\nWHERE condition;\n\nThe DELETE statement is used to remove rows from a table.\n\nDELETE FROM table_name WHERE condition;\n\nThe CREATE TABLE statement is used to create a new table in a database.\n\nCREATE TABLE table_name (\ncolumn1 datatype constraints,\ncolumn2 datatype constraints,\ncolumn3 datatype constraints\n);\n\nThe ALTER TABLE statement is used to add, delete/drop or modify columns in the existing table. It is also used to add and drop constraints on the existing table.\n\n-- To add a column\nALTER TABLE table_name\nADD column_name datatype;\n\n-- To delete/drop column\nALTER TABLE table_name\nDROP COLUMN column_name;\n\n-- To modify existing column\nALTER TABLE table_name\nMODIFY COLUMN column_name datatype;\n\nThe DROP TABLE statement is used to drop an existing table in a database.\n\nDROP TABLE table_name;\n\nLearn more about SQL from the following resources:\nSQL Tutorial - Mode\nSQL Tutorial\nSQL Tutorial - W3Schools",
                    "resources": [
                        {
                            "name": "SQL Tutorial - Mode",
                            "link": "https://mode.com/sql-tutorial/"
                        },
                        {
                            "name": "SQL Tutorial",
                            "link": "https://www.sqltutorial.org/"
                        },
                        {
                            "name": "SQL Tutorial - W3Schools",
                            "link": "https://www.w3schools.com/sql/default.asp"
                        }
                    ]
                },
                "order": 2,
                "options": [
                    {
                        "SQL keywords": {
                            "description": "SQL employs a number of standard command keywords that are integral to interact with databases. Keywords in SQL provide instructions as to what action should be performed.\n\nHere are some of the primary SQL keywords:\n\nSELECT: This keyword retrieves data from a database. For example,\n\nSELECT * FROM Customers;\nIn the above statement * indicates that all records should be retrieved from the Customers table.\n\nFROM: Used in conjunction with SELECT to specify the table from which to fetch data.\n\nWHERE: Used to filter records. Incorporating a WHERE clause, you might specify conditions that must be met. For example,\n\nSELECT * FROM Customers WHERE Country='Germany';\nINSERT INTO: This command is used to insert new data into a database.\n\nINSERT INTO Customers (CustomerID, CustomerName, ContactName, Address, City, PostalCode, Country)\nVALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway');\nUPDATE: This keyword updates existing data within a table. For example,\n\nUPDATE Customers SET ContactName='Alfred Schmidt', City='Frankfurt' WHERE CustomerID=1;\nDELETE: This command removes one or more records from a table. For example,\n\nDELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste';\nCREATE DATABASE: As implied by its name, this keyword creates a new database.\n\nCREATE DATABASE mydatabase;\nALTER DATABASE, DROP DATABASE, CREATE TABLE, ALTER TABLE, DROP TABLE: These keywords are used to modify databases and tables.\n\nRemember that SQL is not case sensitive, meaning keywords can be written in lower case. The convention is to write them in ALL CAPS for readability. There are many more keywords in SQL, but these are some of the most common.\n\nLearn more about SQL from the following resources:\nSQL Tutorial - Mode\nSQL Tutorial\nSQL Tutorial - W3Schools",
                            "resources": [
                                {
                                    "name": "SQL Tutorial - Mode",
                                    "link": "https://mode.com/sql-tutorial/"
                                },
                                {
                                    "name": "SQL Tutorial",
                                    "link": "https://www.sqltutorial.org/"
                                },
                                {
                                    "name": "SQL Tutorial - W3Schools",
                                    "link": "https://www.w3schools.com/sql/default.asp"
                                }
                            ]
                        },
                        "Data Types": {
                            "description": "SQL data types define the type of data that can be stored in a database table’s column. Depending on the DBMS, the names of the data types can differ slightly. Here are the general types:\n\nINT\nINT is used for whole numbers. For example:\n\nCREATE TABLE Employees (\n    ID INT,\n    Name VARCHAR(30)\n);\nDECIMAL\nDECIMAL is used for decimal and fractional numbers. For example:\n\nCREATE TABLE Items (\n    ID INT,\n    Price DECIMAL(5,2)\n);\nCHAR\nCHAR is used for fixed-length strings. For example:\n\nCREATE TABLE Employees (\n    ID INT,\n    Initial CHAR(1)\n);\nVARCHAR\nVARCHAR is used for variable-length strings. For example:\n\nCREATE TABLE Employees (\n    ID INT,\n    Name VARCHAR(30)\n);\nDATE\nDATE is used for dates in the format (YYYY-MM-DD).\n\nCREATE TABLE Employees (\n    ID INT,\n    BirthDate DATE\n);\nDATETIME\nDATETIME is used for date and time values in the format (YYYY-MM-DD HH:MI:SS).\n\nCREATE TABLE Orders (\n    ID INT,\n    OrderDate DATETIME\n);\nBINARY\nBINARY is used for binary strings.\nBOOLEAN\nBOOLEAN is used for boolean values (TRUE or FALSE).\n\nRemember, the specific syntax for creating tables and defining column data types can vary slightly depending upon the SQL database you are using (MySQL, PostgreSQL, SQL Server, SQLite, Oracle, etc.), but the general concept and organization of data types is cross-platform.",
                            "resources": []
                        }
                    },
                    {
                        "Operators": {
                            "description": "SQL operators are used to perform operations like comparisons and arithmetic calculations. They are very crucial in forming queries. SQL operators are divided into the following types:\n\nArithmetic Operators: These are used to perform mathematical operations. Here is a list of these operators:\n+ : Addition\n- : Subtraction\n* : Multiplication\n/ : Division\n% : Modulus\nExample:\nSELECT product, price, (price * 0.18) as tax FROM products;\nComparison Operators: These are used in the where clause to compare one expression with another. Some of these operators are:\n= : Equal\n!= or <> : Not equal\n> : Greater than\n< : Less than\n>=: Greater than or equal\n<=: Less than or equal\nExample:\nSELECT name, age FROM students WHERE age > 18;\nLogical Operators: They are used to combine the result set of two different component conditions. These include:\nAND: Returns true if both components are true.\nOR : Returns true if any one of the component is true.\nNOT: Returns the opposite boolean value of the condition.\nExample:\nSELECT * FROM employees WHERE salary > 50000 AND age < 30;\nBitwise Operators: These perform bit-level operations on the inputs. Here is a list of these operators:\n& : Bitwise AND\n| : Bitwise OR\n^ : Bitwise XOR\nBitwise operators are much less commonly used in SQL than the other types of operators.\nRemember, the datatype of the result is dependent on the types of the operands.",
                            "resources": []
                        },
                        "SELECT": {
                            "description": "The SELECT statement is used in SQL to pick out specific data from a database. In other words, it is used to select from the database what you would like to display. The syntax for the SELECT statement is fairly straightforward:\nSELECT column(s)\nFROM table\nWHERE condition;\ncolumn(s): Enter the name(s) of the column(s) that you want to display.\ntable: The name of the table from where you want to retrieve data.\nWHERE: Optional. This is a filter to display only the rows where this condition is true.\nFor instance, if you wanted to select all data from the “Customers” table, your query would look like this:\nSELECT *\nFROM Customers;\nIn the above code, the asterisk * denotes “all”. This will retrieve all of the data in the “Customers” table.\nIf you want to select only the “FirstName” and “LastName” columns from the “Customers” table, your query would look like this:\nSELECT FirstName, LastName\nFROM Customers;\nYou can also filter using the WHERE clause. For example, selecting only the customers who are from “Germany”:\nSELECT *\nFROM Customers\nWHERE Country='Germany';\nFinally, you can also sort the results using the ORDER BY keyword:\nSELECT *\nFROM Customers\nORDER BY Country;\nThis will sort the output in ascending order by the Country column. To sort in descending order, you would add the DESC keyword:\nSELECT *\nFROM Customers\nORDER BY Country DESC;\nThese are the very basics of the SELECT statement in SQL, which is a vital part of working with databases.",
                            "resources": []
                        },
                        "UPDATE": {
                            "description": "The SQL UPDATE statement is used to modify the existing data in a database. This statement is very useful when you need to change the values assigned to specific fields in an existing row or set of rows.\nThe general syntax for the UPDATE statement is as follows:\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\ntable_name: The name of the table where an update will be performed.\nSET: This clause specifies the column name and the new value that it should be updated to.\ncolumn1, column2, ...: The column names in the table.\nvalue1, value2,The new values that you want to record into the database.\nWHERE: This clause specifies the conditions that identify which row(s) to update.\nExample Usage\nHere’s an example that might provide some clarity. For an imaginary Employees table:\nEmployeeID Name Position Salary\n1 Jane Manager\n50000\n2John Clerk\n30000\n3Bob Engineer\n45000\nAlways be careful with the UPDATE statement; if you forget the WHERE clause, you will update all the rows in the table. ",
                            "resources": []
                        }
                    },
                    {
                        "DELETE": {
                            "description": "The DELETE statement in SQL helps you remove existing records from a database. However, keep in mind, it is a destructive operation and may permanently erase data from your database.\n\nWith the DELETE statement, you can perform the following:\n\nDelete All Rows:\n\nThe DELETE statement without a WHERE clause deletes all rows in a table. This operation is irreversible.\n\nExample:\n\nDELETE FROM table_name;\nThis SQL statement deletes all the records from table_name.\n\nDelete Specific Rows:\n\nWhen combined with the WHERE clause, the DELETE SQL statement erases specific rows that meet the condition.\n\nExample:\n\nDELETE FROM table_name WHERE condition;\nThis instance of the DELETE statement deletes records from table_name the place where the given condition matches.\n\nIt’s crucial to use DELETE cautiously because it has the potential to either erase certain important rows or entirely empty the table.\n\nNote: The deletion made by the “DELETE” statement is permanent and cannot be undone. Always ensure to have a backup before running a DELETE query, especially when it is on a production database.",
                            "resources": []
                        }
                    }
                ]
            },
            "Data Definition Language (DDL)": {
                "description": "Data Definition Language (DDL) is a subset of SQL. Its primary function is to create, modify, and delete database structures but not data. The commands in DDL areCREATE: This command is used to create the database or its objects (like table, index, function, views, store procedure, and triggers).\nCREATE TABLE table_name column1 data_type(size),column2 data_type(size),...);DROP: This command is used to delete an existing database or table.DROP TABLE table_name;ALTER: This is used to alter the structure of the database. It is used to add, delete/drop or modify columns in an existing table.\nALTER TABLE table_name ADD column_name datatype; ALTER TABLE table_name DROP COLUMN column_name; ALTER TABLE table_name MODIFY COLUMN column_name datatype(size);TRUNCATE: This is used to remove all records from a table, including all spaces allocated for the records which are removed.TRUNCATE TABLE table_name;RENAME: This is used to rename an object in the database.RENAME TABLE old_table_name TO new_table_name;Remember: In DDL operations, COMMIT and ROLLBACK statement cannot be performed because the MySQL engine automatically commits the changes Remember to replace table_name, column_name, datatype(size), old_table_name, and new_table_name in the examples above with your actual table names, column names, data types and sizes, and the old or new table names you want to specify.",
                "resources": [],
                "order": 3,
                "options": [
                    {
                        "Create Table": {
                            "description": "The CREATE TABLE statement in SQL is a Data Definition Language (DDL) command used to create a new table in the database.\n\nSQL CREATE TABLE Syntax\nThe syntax for SQL CREATE TABLE is as follows:\n\nCREATE TABLE table_name (\n    column1 datatype,\n    column2 datatype,\n    column3 datatype,\n   ....\n);\ntable_name is the name of the table that you want to create.\ncolumn1, column2,... are the columns in the table.\ndatatype is the data type for the column, such as varchar, int, date, etc.\nSQL CREATE TABLE Example\nHere is an example of the CREATE TABLE statement:\n\nCREATE TABLE Employees (\n    ID int,\n    Name varchar(255),\n    Salary int,\n    Department varchar(255),\n    Position varchar(255)\n);\nThis SQL command creates a new table named Employees with five columns, named ‘ID’, ‘Name’, ‘Salary’, ‘Department’, and ‘Position’. The data types are int for the ‘ID’ and ‘Salary’, and varchar(255) for the others.\nSQL CREATE TABLE with NOT NULL\nThe NOT NULL constraint enforces a column to not accept null values. When creating a new table, you can add this constraint. Here is a practical example:\n\nCREATE TABLE Employees (\n    ID int NOT NULL,\n    Name varchar(255) NOT NULL,\n    Salary int,\n    Department varchar(255),\n    Position varchar(255)\n);",
                            "resources": []
                        },
                        "Alter Table": {
                            "description": "The ALTER TABLE command in SQL is used to add, delete/drop, or modify columns in an existing table. It’s also useful for adding and dropping constraints such as primary key, foreign key, etc.\n\nAdd Column\nA single column can be added using the following syntax:\n\nALTER TABLE tableName\nADD columnName datatype;\nTo add more than one column:\n\nALTER TABLE tableName\nADD (columnName1 datatype,\n     columnName2 datatype,\n     ...\n     );\nDrop Column\nTo drop a single column:\n\nALTER TABLE tableName\nDROP COLUMN columnName;\nTo drop multiple columns:\n\nALTER TABLE tableName\nDROP (columnName1,\n       columnName2,\n       ...\n      );\nModify Column\nTo modify the datatype of a column:\n\nALTER TABLE tableName\nALTER COLUMN columnName TYPE newDataType;\nAdd/Drop Constraints\nTo add constraints:\n\nALTER TABLE tableName\nADD CONSTRAINT constraintName\nPRIMARY KEY (column1, column2, ... column_n);\nTo drop constraints:\n\nALTER TABLE tableName\nDROP CONSTRAINT constraintName;\nIn conclusion, ALTER TABLE in SQL lets you alter the structure of an existing table. This is a powerful command that lets you dynamically add, modify, and delete columns as well as the constraints placed on them. It ensures you are more flexible in dealing with changing data storage requirements.",
                            "resources": []
                        },
                        "Truncate Table": {
                            "description": "The TRUNCATE TABLE statement is a Data Definition Language (DDL) operation that is used to mark the extents of a table for deallocation (empty for reuse). The result of this operation quickly removes all data from a table, typically bypassing a number of integrity enforcing mechanisms intended to protect data (like triggers).\n\nSyntax\nIn SQL, the TRUNCATE TABLE statement is quite simple:\n\nTRUNCATE TABLE table_name;\nIn this command, “table_name” refers to the name of the table you wish to clear.\nExample\nIf you have a table named Orders and you want to delete all its records, you would use:\n\nTRUNCATE TABLE Orders;\nAfter executing this statement, the Orders table would still exist, but it would be empty.\nRemember, while TRUNCATE TABLE is faster and uses fewer system and transaction log resources than DELETE, it does not invoke triggers and cannot be rolled back, so use with caution.\nLimitations\nTruncate preserves the structure of the table for future use. But you can’t truncate a table that:\n- Is referenced by a FOREIGN KEY constraint. (You can truncate a table that has a foreign key that references itself.)\n- Participates in an indexed view.\n- Is published by using transactional replication or merge replication.\nIf you try to truncate a table with a foreign key constraint, SQL Server will prevent you from doing so and you will have to use the DELETE statement instead.\nFor partitioned tables, TRUNCATE TABLE removes all rows from all partitions. The operation is not allowed if the table contains any LOB columns - varchar(max), nvarchar(max), varbinary(max), text, ntext, image, xml, or if the table contains any filestream columns or spatial geo, geography, geometry, and hierarchyid data type columns, or any columns of CLR user-defined data types.",
                            "resources": []
                        }
                    }
                ]
            },
            "Data Manipulation Language (DML)": {
                "description": "DML is a subcategory of SQL which stands for Data Manipulation Language. The purpose of DML is to insert, retrieve, update and delete data from the database. With this, we can perform operations on existing records.\n\nDML contains four commands which are:\n\nINSERT INTO - This command is used to insert new rows (records) into a table.\nExample:\n\nINSERT INTO table_name ( column1, column2, column3, ... )\nVALUES ( value1, value2, value3, ... )\nSELECT - This command is used to select data from a database. The data returned is stored in a result table, called the result-set.\nExample:\n\nSELECT column1, column2, ...\nFROM table_name\nUPDATE - This command is used to modify the existing rows in a table.\nExample:\n\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\nDELETE FROM - This command is used to delete existing rows (records) from a table.\nExample:\n\nDELETE FROM table_name WHERE condition;",
                "resources": [
                    {
                        "SELECT": {
                            "description": "The SELECT statement in SQL is majorly used for fetching data from the database. It is one of the most essential elements of SQL.\n\nSyntax\nHere’s how your SELECT command will look like:\n\nSELECT column1, column2, ...\nFROM table_name;\nIf you want to select all the columns of a table, you can use * like this:\n\nSELECT * FROM table_name;\nExample\nFor instance, consider we have a table EMPLOYEES with columns name, designation, and salary. We can use SELECT in the following way:\n\nSELECT name, designation FROM EMPLOYEES;\nThis will retrieve all the names and designations of all employees from the table EMPLOYEES.\n\nSELECT DISTINCT\nThe SELECT DISTINCT statement is used to return only distinct (different) values. The DISTINCT keyword eliminates duplicate records from the results.\n\nHere’s how you can use it:\n\nSELECT DISTINCT column1, column2, ...\nFROM table_name;\nFor example, if we want to select all unique designations from the EMPLOYEES table, the query will look like this:\n\nSELECT DISTINCT designation FROM EMPLOYEES;\nSELECT WHERE\nSELECT statement combined with WHERE gives us the ability to filter records based on a condition.\n\nSyntax:\n\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\nFor example, to select employees with salary more than 50000, you can use this query:\n\nSELECT * FROM EMPLOYEES WHERE salary > 50000;\nSELECT ORDER BY\nUsing SELECT statement in conjunction with ORDER BY, we can sort the result-set in ascending or descending order.\n\nSyntax:\n\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column ASC|DESC;\nFor example, to select all employees and order them by their name in ascending fashion:\n\nSELECT * FROM EMPLOYEES ORDER BY name ASC;\nRemember that the default sort order is ascending if the ASC|DESC parameter is not defined.",
                            "resources": [],
                            "options": [
                                {
                                    "FROM": {
                                        "description": "The FROM clause in SQL specifies the tables from which the retrieval should be made. It is an integral part of SELECT statements and variants of SELECT like SELECT INTO and SELECT WHERE. FROM can be used to join tables as well.\n\nTypically, FROM is followed by a space-delimited list of tables in which the SELECT operation is to be executed. If you need to pull data from multiple tables, you would separate each table with a comma.\n\nHere are some examples:\n\nExample 1 - Simple Usage\nIf you’ve a table called employees, you can select all employees’ data like this:\n\nSELECT *\nFROM employees;\nIn this example, * means “all columns”. So, SELECT * FROM employees; will retrieve all data from the employees table.\n\nExample 2 - FROM with Multiple Tables\nIf you’ve multiple tables, say employees and departments, and you want to select data from both, you can do the following:\n\nSELECT employees.name, departments.department\nFROM employees, departments\nWHERE employees.dept_id = departments.dept_id;\nIn this example, the FROM clause is following by two tables: employees and departments. employees.name and departments.department indicate that we’re selecting the name column from the employees table and the department column from the departments table.\nRemember, always respect the order of operations in SQL. The FROM clause works only after tables are identified.\nIn complex SQL queries where you might need to pull data from multiple tables, aliases are used to temporarily rename the tables within the individual SQL statement.\nExample 3 - FROM with Aliases\nBelow is an example of a FROM clause with aliases:\n\nSELECT e.name, d.department\nFROM employees AS e, departments AS d\nWHERE e.dept_id = d.dept_id;\nIn this example, employees and departments tables are termed as e and d respectively.\nThat’s it! Remember that FROM is not limited only to SELECT. It is applicable to UPDATE and DELETE operations as well.",
                                        "resources": []
                                    }
                                },
                                {
                                    "WHERE": {
                                        "description": "SQL provides a WHERE clause that is basically used to filter the records. If the condition specified in the WHERE clause satisfies, then only it returns the specific value from the table. You should use the WHERE clause to filter the records and fetch only the necessary records.\n\nThe WHERE clause is not only used in SELECT statements, but it is also used in UPDATE, DELETE statements, and more, which we will cover in subsequent chapters.\n\nAn example of its implementation is:\n\nSELECT * FROM Students WHERE Age > 10;\nIn this example, the statement selects all fields from the ‘Students’ table where the ‘Age’ field value is greater than 10.\n\nThe WHERE clause can be combined with AND, OR, and NOT operators. Here’s an example:\n\nSELECT * FROM Students WHERE Age > 10 AND Gender = 'Female';\nIn this example, the statement selects all fields from the ‘Students’ table where the ‘Age’ field value is greater than 10 and the ‘Gender’ is Female.\n\nThe syntax generally looks like this:\n\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;",
                                        "resources": []
                                    }
                                },
                                {
                                    "ORDER BY": {
                                        "description": "The ORDER BY clause in SQL is used to sort the result-set from a SEL\nSELECT column1, column2,...\nFROM table_name\nORDER BY column1, column2, ... ASC\nHere, ASC is used for ascending order. If you use ORDER BY without ASC or DESC, ASC is used by default.\n\nSyntax for Descending Order:\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... DESC;\nHere, DESC is used for descending order.\n\nUsage Example\nConsider the following Customers table:\n\nID NAME AGE ADDRESS SALARY\n1 Ramesh 32 Ahmedabad \n2000.0\n2 Khilan 25 Delhi\n1500.0\n3 kaushik 23 Kota 2000.0\nn4 Chaitali 25 Mumbai 6500.0\n5 Hardik 27 Bhopal 8500.0\n6 Komal 22 MP 4500.0\nExample 1 - Ascending Order:\nSort the table by the NAME column in ascending order:\n\nSELECT * FROM Customers\nORDER BY NAME ASC;\nExample 2 - Descending Order:\nSort the table by the SALARY column in descending order:\n\nSELECT * FROM Customers\nORDER BY SALARY DESC;\nExample 3 - Multiple Columns:\nYou can also sort by multiple columns. Sort the table by the AGE column in ascending order and then SALARY in descending order:\n\nSELECT * FROM Customers\nORDER BY AGE ASC, SALARY DESC;\nIn this instance, the ORDER BY clause first sorts the Customers table by the AGE column and then sorts the sorted result further by the SALARY column.",
                                        "resources": []
                                    }
                                },
                                {
                                    "GROUP BY": {
                                        "description": "“Group By” is a clause in SQL that is used to arrange identical data into groups. This clause comes under the category of Group Functions, alongside the likes of Count, Sum, Average, etc.\n\nThe syntax for ‘Group by’ is:\n\nSELECT column1, column2\nFROM table_name\nGROUP BY column1, column2;\nHere, column1, column2, are the names of the columns based on which we want to group the results.\n\nExample:\nAssume we have a “Sales” table. This table has three columns: ID, Item, and Amount.\n\nID     Item    Amount\n---   ------   ------\n1      A        150\n2      B        200\n3      A        100\n4      B        50\n5      A        200\n6      A        100\n7      B        150\nExecute the following SQL statement…\n\nSELECT Item, SUM(Amount)\nFROM Sales\nGROUP BY Item;\nThis will concatenate, or “group”, all items that are the same into one row, applying the SUM() function on their respective Amounts. The output will then be:\n\nItem    SUM(Amount)\n------  ----------\nA        550\nB        400\nGroup By with Having Clause\nThe Group By clause can also be used with the Having keyword. The Having keyword allows you to filter the results of the group function.\n\nFor example:\n\nSELECT Item, SUM(Amount)\nFROM Sales\nGROUP BY Item\nHAVING SUM(Amount) > 150;\nThis will return all grouped items where the total amount is more than 150. Hence, the result will be:\n\nItem    SUM(Amount)\n------  ----------\nA        550\nB        400",
                                        "resources": []
                                    }
                                },
                                {
                                    "HAVING": {
                                        "description": "HAVING is a clause in SQL that allows you to filter result sets in a GROUP BY clause. It is used to mention conditions on the groups being selected. In other words, HAVING is mainly used with the GROUP BY clause to filter the results that a GROUP BY returns.\n\nIt’s similar to a WHERE clause, but operates on the results of a grouping. The WHERE clause places conditions on the selected columns, whereas the HAVING clause places conditions on groups created by the GROUP BY clause.\n\nSyntax\nThe basic syntax is as follows:\n\nSELECT column_name, function(column_name)\nFROM table_name\nWHERE condition\nGROUP BY column_name\nHAVING function(column_name) condition value;\nExample\nSuppose we have a Sales table with the following data:\n\nSaleIDProductQuantity\n1A30\n2B20\n3A100\n4B50\n5C60\n6A70\nAnd we want to find products which have total quantity sold more than 100. We can use the HAVING clause as follows:\n\nSELECT Product, SUM(Quantity) as TotalQuantity\nFROM Sales\nGROUP BY Product\nHAVING TotalQuantity > 100;\nIn this query,\n\nGROUP BY Product would group the sales figures by Product.\nSUM(Quantity) would calculate total quantity sold for each product.\nHAVING TotalQuantity > 100 would filter out the groups which have total quantity sold less than or equal to 100.",
                                        "resources": []
                                    }
                                },
                                {
                                    "JOINs": {
                                        "description": "SQL Joins are used to retrieve data from two or more data tables, based on a related column between them. The key types of JOINs include:\n\nINNER JOIN: This type of join returns records with matching values in both tables.\nSELECT table1.column1, table2.column2...\nFROM table1\nINNER JOIN table2\nON table1.matching_column = table2.matching_column;\nLEFT (OUTER) JOIN: Returns all records from the left table, and matched records from the right table.\nSELECT table1.column1, table2.column2...\nFROM table1\nLEFT JOIN table2\nON table1.matching_column = table2.matching_column;\nRIGHT (OUTER) JOIN: Returns all records from the right table, and matched records from the left table.\nSELECT table1.column1, table2.column2...\nFROM table1\nRIGHT JOIN table2\nON table1.matching_column = table2.matching_column;\nFULL (OUTER) JOIN: Returns all records when either a match is found in either left (table1) or right (table2) table records.\nSELECT table1.column1, table2.column2...\nFROM table1\nFULL JOIN table2\nON table1.matching_column = table2.matching_column;\nSELF JOIN: A self join is a join in which a table is joined with itself.\nSELECT a.column_name, b.column_name...\nFROM table_name AS a, table_name AS b\nWHERE condition;\nCARTESIAN JOIN: If WHERE clause is omitted, the join operation produces a Cartesian product of the tables involved in the join. The size of a Cartesian product result set is the number of rows in the first table multiplied by the number of rows in the second table.\nSELECT table1.column1, table2.column2...\nFROM table1, table2;\nEach type of JOIN allows for the retrieval of data in different situations, making them flexible and versatile for different SQL queries.",
                                        "resources": []
                                    }
                                },
                                {
                                    "INSERT": {
                                        "description": "The “INSERT” statement is used to add new rows of data to a table in a database. There are two main forms of the INSERT command: INSERT INTO which, if columns are not named, expects a full set of columns, and INSERT INTO table_name (column1, column2, ...) where only named columns will be filled with data.\n\nUsage\nInsert full set of columns:\nCode example:\n\nINSERT INTO table_name \nVALUES (value1, value2, ..., valueN);\nIn the example above, you need to provide values for all columns available in the table.\n\nSelectively insert data:\nCode example:\n\nINSERT INTO table_name (column1, column2, ..., columnN)  \nVALUES (value1, value2, ..., valueN);\nHere, you only provide values for certain columns of the table. Other columns will take on their default values (if any).\n\nInsert data from another table:\nAnother useful form of the INSERT command is INSERT INTO SELECT, which allows you to copy data from one table and add it into another table.\nCode example:\n\nINSERT INTO table1 (column1, column2, ... , columnN)\nSELECT column1, column2, ... , columnN \nFROM table2 \nWHERE condition;\nIn this scenario, table2 should already have the data we need and the WHERE clause can be used to select only those rows that satisfy certain conditions.\nNote: The crucial point is that your columns in both SELECT and INSERT INTO command must be in the same order and their datatypes must be compatible.\nKindly ensure that the database table has enough space to hold inserted data, else it will result in an OVERFLOW error.\nNote: Always make sure to provide correct and compatible data types for the columns. The SQL engine won’t allow you to add data that doesn’t match the column’s declared data type.",
                                        "resources": []
                                    }
                                },
                                {
                                    "UPDATE": {
                                        "description": "The UPDATE command in SQL is used to modify the existing records in a table. This command is useful when you need to update existing data within a database.\n\nHere are important points to remember before updating records in SQL:\n\n- The WHERE clause in the UPDATE statement specifies which records to modify. If you omit the WHERE clause, all records in the table will be updated!\n- Be careful when updating records in SQL. If you inadvertently run an UPDATE statement without a WHERE clause, you will rewrite all the data in the table.\n\nSQL UPDATE Syntax\nHere is a basic syntax of SQL UPDATE command:\n\nUPDATE table_name\nSET column1 = value1, column2 = value2...., columnN = valueN\nWHERE [condition];\nIn this syntax:\n- table_name: Specifies the table where you want to update records.\n- SET: This keyword is used to set the column values.\n- column1, column2... columnN: These are the columns of the table that you want to change.\n- value1, value2... valueN: These are the new values that you want to assign for your columns.\n- WHERE: This clause specifies which records need to be updated. It selects records based on one or more conditions.\nSQL UPDATE Example\nLet’s assume we have the following Students table:\n\nStudentIDFirstNameLastNameAge\n1JohnDoe20\n2JaneSmith22\n3BobJohnson23\nAnd we want to update the Age of the student with StudentID as 2. We can use the UPDATE command as follows:\n\nUPDATE Students\nSET Age = 23\nWHERE StudentID = 2;\nAfter executing the above SQL command, the Age of the student with StudentID 2 will be updated to 23.",
                                        "resources": []
                                    }
                                },
                                {
                                    "DELETE": {
                                        "description": "The DELETE statement is used to delete existing records in a table. This is a straightforward process, but care must be taken because the DELETE statement is destructive and cannot be undone by default.\n\nSyntax\nThe basic syntax of a DELETE query with WHERE clause in SQL is as follows:\n\nDELETE FROM table_name [WHERE condition]\n- table_name: Specifies the table where you want to delete data.\n- WHERE condition: It is optional. You can use the WHERE clause with a DELETE query to delete the selected rows; otherwise, all the records would be deleted.\nExamples\nDELETE ALL Rows\nDeletes all rows from a table named ‘students’.\n\nDELETE FROM students;\nDELETE Specified Rows\nDeletes the student whose student_id is ‘1001’ from the ‘students’ table.\n\nDELETE FROM students WHERE student_id = '1001';\nCaution: Be very careful when using the DELETE statement. If you omit the WHERE clause, all records will be deleted!\nMulti-table deletions\nSome database systems allow for deleting from multiple tables in a single DELETE statement. This is database-specific and beyond the scope of the basic SQL DELETE command.\nRemember, always make sure to have a backup and confirm you’re deleting the correct data before running a DELETE command, especially in production environments.",
                                        "resources": []
                                    }
                                }
                            ]
                        }
                    }
                ],
                "order": 4,
                "options": []
            },
            "Aggregate Queries": {
                "description": "SQL aggregate functions are inbuilt functions that are used to perform some calculation on the data and return a single value. This is why they form the basis for “aggregate queries”. These functions operate on a set of rows and return a single summarized result.\n\nCommon Aggregate Functions\n1. COUNT()\n\nCounts the number of rows.\nSELECT COUNT(column_name) \nFROM table_name \nWHERE condition;\n2. SUM()\n\nReturns the sum of a numeric column.\nSELECT SUM(column_name) \nFROM table_name \nWHERE condition;\n3. AVG()\n\nReturns the average value of a numeric column.\nSELECT AVG(column_name) \nFROM table_name \nWHERE condition;\n4. MIN()\n\nReturns the smallest value of the selected column.\nSELECT MIN(column_name) \nFROM table_name \nWHERE condition;\n5. MAX()\n\nReturns the largest value of the selected column.\nSELECT MAX(column_name) \nFROM table_name \nWHERE condition;\nThese functions ignore NULL values.\n\nGROUP BY and HAVING Clauses\nTo separate the results into groups of accumulated data, you can use the GROUP BY clause.\nSELECT column1, aggregate_function(column2)\nFROM table\nGROUP BY column1;\n“A group” is represented by ROW(s) that have the same value in the specific column(s). The GROUP BY clause can be used in a SELECT statement to collect data across multiple records and group by some columns.\nThe HAVING clause is used with the GROUP BY clause, it applies to summarized group records, unlike the ‘where’ clause. It was added to SQL because the WHERE keyword could not be used with aggregate functions.\nSELECT column1, aggregate_function(column2)\nFROM table\nGROUP BY column1\nHAVING conditions;\nAggregate queries are simply a way of summarizing information in your database. Although they are a powerful tool, they can become complex very quickly, especially if you start nesting them together or combining multiple aggregate functions in a single query.",
                "resources": [],
                "order": 5,
                "options": [
                    {
                        "SELECT": {
                            "description": "SELECT is one of the most widely used commands in SQL. This command is used to select data from a database. The data returned is stored in a results table, also called the result-set.\n\nSyntax\nThe simplest way to use the SELECT statement is to return all columns from a table. This can be done with the following syntax:\nSELECT * FROM table_name;\nThis will return all fields (columns) of all records (rows) from the table.\n\nIf you want to select just certain columns, you can specify them by name, separated by commas:\nSELECT column_name1, column_name2 FROM table_name;\nSELECT DISTINCT\nThe SELECT DISTINCT statement is used to return only unique values in the output. It can be used to eliminate duplicate values in the returned data.\nSELECT DISTINCT column_name FROM table_name;\nWHERE Clause\nThe WHERE clause is used to filter records. The WHERE clause is used to extract only those records that fulfill a specified condition.\nSELECT column_name FROM table_name WHERE condition;\nORDER BY\nThe ORDER BY keyword is used to sort the result-set in ascending or descending order. The ORDER BY keyword sorts the records in ascending order by default. If you want to sort the records in descending order, you can use the DESC keyword.\nSELECT column_name FROM table_name ORDER BY column_name ASC|DESC;\nAggregate Functions\nAggregate functions in SQL are functions where the values of multiple rows are grouped together to form a single value of more significant meaning, such as a list, a set, or a sum. Some examples include SUM(), COUNT(), MIN(), MAX(), and AVG().\nSELECT COUNT(column_name) FROM table_name WHERE condition;\nSELECT AVG(column_name) FROM table_name WHERE condition;\nSELECT SUM(column_name) FROM table_name WHERE condition;\nSELECT MIN(column_name) FROM table_name WHERE condition;\nSELECT MAX(column_name) FROM table_name WHERE condition;\nGROUP BY\nThe GROUP BY statement is often used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result-set by one or more columns.\nSELECT column_name1, COUNT(column_name2) FROM table_name WHERE condition GROUP BY column_name1 ORDER BY COUNT(column_name2) DESC;\nHAVING Clause\nThe HAVING clause was added to SQL because the WHERE keyword could not be used with aggregate functions. It works like the WHERE clause but on grouped records.\nSELECT column_name, COUNT(column_name) FROM table_name GROUP BY column_name HAVING COUNT(column_name) > value;\nThe above are the most common uses of the SELECT keyword in SQL. There are other keywords and functions you can use to manipulate the data as well. These will give you a good start on using SELECT in your SQL queries.",
                            "resources": [],
                            "options": [
                                {
                                    "SUM": {
                                        "description": "The SUM() function in SQL is used to calculate the sum of a column. This function allows you to add up a column of numbers in an SQL table.\n\nThe syntax for SUM is as follows:\nSELECT SUM(column_name) FROM table_name;\nWhere column_name is the name of the column you want to calculate the sum of, and table_name is the name of the table where the column is.\nFor example, consider the following ORDER table:\n|   OrderID  | Company | Quantity |\n|-------------|-----------|----------|\n|     1           |     A     |    30     |\n|     2           |     B     |    15     |\n|     3           |     A     |    20     |\nIf you want to find the total quantity, you can use SUM():\nSELECT SUM(Quantity) AS TotalQuantity FROM Order;\nOutput will be:\n| TotalQuantity |\n|----------------|\n|           65     |\nNote: The SUM() function skips NULL values.\nOne of the common use cases of SUM() function is in conjunction with GROUP BY to get the sum for each group of rows.\nExample:\nSELECT Company, SUM(Quantity) AS TotalQuantity \nFROM Order \nGROUP BY Company;\nThis will give us the sum of Quantity for each Company in the Order table.\n| Company | TotalQuantity |\n|-----------|----------------|\n|     A     |           50     |\n|     B     |           15     |\nNotably, in all databases, including MySQL, PostgreSQL, and SQLite, the SUM() function operates the same way.",
                                        "resources": []
                                    }
                                },
                                {
                                    "COUNT": {
                                        "description": "COUNT is a SQL function that returns the number of rows that match a specified criteria. Essentially, COUNT function is used when you need to know the count of a record in a certain table’s column.\n\nThere are two types of count function; COUNT(*) and COUNT(column).\nCOUNT(*) counts all the rows in the target table whether columns contain null values or not.\nSELECT COUNT(*) FROM table_name;\nCOUNT(column) counts the rows in the column of a table excluding null.\nSELECT COUNT(column_name) FROM table_name;\nYou may also use COUNT() in conjunction with GROUP BY to return the count of rows within each group.\nA typical example would be:\nSELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;\nHere, column_name is the name of the column based on which the rows will be grouped. This query will return the count of rows in each group of column_name.\nBy understanding how to use the COUNT() function, you can extract more meaningful data from your tables, and perform analytics and generate reports based on the counts of certain attributes in your database.",
                                        "resources": []
                                    }
                                },
                                {
                                    "AVG": {
                                        "description": "The AVG() function in SQL is an aggregate function that returns the average value of a numeric column. It calculates the sum of values in a column and then divides it by the count of those values.\n\nSyntax:\n\nSELECT AVG(column_name)\nFROM table_name;\nThis statement will return the average value of the specified column.\n\nExample Usage of AVG:\nConsider the following table Orders:\n\nOrderID    CustomerID    Quantity\n1    A    30\n2    A    40\n3    B    20\n4    B    60\n5    C    50\n6    C    10\nLet’s calculate the average quantity in the Orders table:\n\nSELECT AVG(Quantity) AS AvgQuantity\nFROM Orders;\nThe result is 35. This value is the average of all Quantity values in the table.\n\nIt’s also possible to group the average function by one or more columns. For example, to find the average quantity of order per customer, we can write:\n\nSELECT CustomerID, AVG(Quantity) as AvgQuantity\nFROM Orders\nGROUP BY CustomerID;\nIt will calculate the average quantity for each customer and display the result along with the associated customer’s ID.\n\nNote: The AVG() function works only with numeric data types (INT, FLOAT, DECIMAL, etc.). It will return an error if used with non-numeric data types.",
                                        "resources": []
                                    }
                                },
                                {
                                    "MIN": {
                                        "description": "MIN is an SQL aggregate function used to return the smallest value in a selected column. It is useful in querying tables where users want to identify the smallest or least available value in datasets. MIN ignores any null values in the dataset.\n\nSyntax:\n\nSELECT MIN(column_name)\nFROM table_name\nWHERE condition;\nIn the case where column_name belongs to a numeric data type (Integers, Float, etc.), MIN returns the smallest numeric value in the column.\n\nIf column_name belongs to datetime types (Date, Time, etc.), MIN returns the earliest date or time.\n\nIf column_name belongs to string types (Char, Text, etc.), MIN returns the lowest value in lexicographic order (similar to alphabetic order).\nExamples:\nConsider a table, named Orders, with the following layout:\nOrderID    CustomerID    OrderDate\n1    C01    2020-10-10\n2    C02    2020-09-05\n3    C01    2020-08-21\nTo find the earliest order date in the Orders table, the MIN function is used in the following way:\nSELECT MIN(OrderDate) AS EarliestOrder\nFROM Orders;\nThe result of this query will be 2020-08-21.\n\nSuppose we have a Prices table with items and their prices. To find the lowest price, use:\nSELECT MIN(price) AS LowestPrice\nFROM Prices;\nThis query will return the smallest value in the price column.\nOne important usage is when it is used along with the GROUP BY clause to find the minimum value in each group.\nExample, to find the earliest order date for each customer:\nSELECT CustomerID, MIN(OrderDate) AS EarliestOrder\nFROM Orders\nGROUP BY CustomerID;\nThis query will return the earliest order date for each customer.",
                                        "resources": []
                                    }
                                },
                                {
                                    "MAX": {
                                        "description": "The MAX() function in SQL is used to return the maximum value of an expression in a SELECT statement.\n\nIt can be used for numeric, character, and datetime column data types. If there are null values, then they are not considered for comparison.\n\nSyntax\nSELECT MAX(column_name)\nFROM table_name\nWHERE condition;\nIn this syntax, the column_name argument is the column in the table_name that you wish to find the maximum value of.\nExample\nConsider the following Employee table:\nID    NAME    SALARY\n1    John    1000\n2    Robert    2000\n3    Jim    3000\n4    Jessica    2500\nTo find the highest salary amongst all the employees, you would use the MAX() function as follows:\nSELECT MAX(SALARY) AS \"Highest Salary\"\nFROM Employee;\nThe above SQL returns 3000 as it’s the highest salary in the Employee table.\nWarning: SQL MAX() function will only return a single row as a result. If multiple rows hold the highest value and if you want to get all these rows, you should not use MAX(). A better option would be sorting the column and then LIMIT the result just to the first row.",
                                        "resources": []
                                    }
                                }
                            ]
                        }
                    },
                    {
                        "GROUP BY": {
                            "description": "Group By is an SQL clause that arranges identical data into groups. It is often used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result-set by one or multiple columns.\n\nSyntax:\nSELECT column1, column2, ..., aggregate_function(column_name)\nFROM table_name\nWHERE condition\nGROUP BY column1, column2, ...;\nExplanation:\ncolumn1, column2, these columns are not under the aggregate function or any operation. They will be used to group the data.\naggregate_function(column_name), Aggregate functions will apply on the group of the column_name specified, not individual rows.\nThe WHERE clause is optional. It adds conditions to select which rows will be grouped.\nExamples:\nHere’s an example of the Group By clause in action. Given is a table Sales:\n\norder_id    product_id    qty\n1    1001    20\n2    1002    10\n3    1003    50\n4    1001    10\n5    1002    20\n6    1003    50\nExample 1:\nSELECT product_id, SUM(qty)\nFROM SALES\nGROUP BY product_id;\nThe result will be:\n\nproduct_id    SUM(qty)\n1001    30\n1002    30\n1003    100\nExample 2:\nYou can perform group by operation on multiple columns. In the below example, ‘product_id’ and ‘order_id’ are used to group the data.\n\nSELECT product_id, order_id, SUM(qty)\nFROM SALES\nGROUP BY product_id, order_id;\nGroup By clause can be used with HAVING clause to add a condition on grouped data.",
                            "resources": []
                        }
                    },
                    {
                        "HAVING": {
                            "description": "The HAVING clause is used in combination with the GROUP BY clause to filter the results of GROUP BY. It is used to mention conditions on the group functions, like SUM, COUNT, AVG, MAX or MIN.\n\nIt’s important to note that where WHERE clause introduces conditions on individual rows, HAVING introduces conditions on groups created by the GROUP BY clause.\nAlso note, HAVING applies to summarized group records, whereas WHERE applies to individual records.\nSyntax:\nSELECT column_name(s)\nFROM table_name\nWHERE condition\nGROUP BY column_name(s)\nHAVING condition\nORDER BY column_name(s);\nExample\nConsider this “Orders” table:\nOrderID    Customer    Amount\n1    John    1000\n2    Mary    1500\n3    John    2000\n4    Jane    1000\n5    Mary    2000\n6    John    3000\n7    Jane    2000\n8    Mary    2500\nFor instance, if you wanted to find customers who have spent more than $3000 in total, you might use the HAVING clause as follows:\nSELECT Customer, SUM(Amount)\nFROM Orders\nGROUP BY Customer\nHAVING SUM(Amount) > 3000;\nAs a result, the query returns:\n\nCustomer    SUM(Amount)\nJohn    6000\nMary    6000\nIn this case, the HAVING clause filters out all Customers with a total Amount less than $3000. Only John and Mary have the total sum of Amount more than or equal to $3000. Thus, only these records satisfy the HAVING clause and are included in the result.",
                            "resources": []
                        }
                    }
                ]
            },
            "Data Constraints": {
                "description": "Data constraints in SQL are used to specify rules for the data in a table. Constraints are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the table.\n\nTypes of SQL Data Constraints\nNOT NULL Constraint: Ensures that a column cannot have a NULL value.\n\nFor Example:\nCREATE TABLE Students (\n    ID int NOT NULL,\n    Name varchar(255) NOT NULL,\n    Age int\n);\nUNIQUE Constraint: Ensures that all values in a column are different.\n\nFor Example:\nCREATE TABLE Students (\n    ID int NOT NULL UNIQUE,\n    Name varchar(255) NOT NULL,\n    Age int\n);\nPRIMARY KEY Constraint: Uniquely identifies each record in a database table. Primary keys must contain UNIQUE values. Exactly the same as the UNIQUE constraint but there can be many unique constraints in a table, but only one PRIMARY KEY constraint per table.\n\nFor Example:\nCREATE TABLE Students (\n    ID int NOT NULL,\n    Name varchar(255) NOT NULL,\n    Age int,\n    PRIMARY KEY (ID)\n);\nFOREIGN KEY Constraint: Prevents actions that would destroy links between tables. A FOREIGN KEY is a field (or collection of fields) in one table that refers to the PRIMARY KEY in another table.\n\nFor Example:\nCREATE TABLE Orders (\n    OrderID int NOT NULL,\n    OrderNumber int NOT NULL,\n    ID int,\n    PRIMARY KEY (OrderID),\n    FOREIGN KEY (ID) REFERENCES Students(ID)\n);\nCHECK Constraint: The CHECK constraint ensures that all values in a column satisfy certain conditions.\n\nFor Example:\nCREATE TABLE Students (\n    ID int NOT NULL,\n    Name varchar(255) NOT NULL,\n    Age int,\n    CHECK (Age>=18)\n);\nDEFAULT Constraint: Provides a default value for a column when none is specified.\n\nFor Example:\nCREATE TABLE Students (\n    ID int NOT NULL,\n    Name varchar(255) NOT NULL,\n    Age int,\n    City varchar(255) DEFAULT 'Unknown'\n);\nINDEX Constraint: Used to create and retrieve data from the database very quickly.\n\nFor Example:\nCREATE INDEX idx_name \nON Students (Name);\nNote: Indexes are not a part of the SQL standard and are not supported by all databases.",
                "resources": [],
                "order": 6,
                "options": [
                    {
                        "Primary Key": {
                            "description": "A primary key is a special relational database table field (or combination of fields) designated to uniquely identify all table records.\n\nA primary key’s main features are:\n\nIt must contain a unique value for each row of data.\nIt cannot contain null values.\nUsage of Primary Key\nYou define a primary key for a table using the PRIMARY KEY constraint. A table can have only one primary key. You can define a primary key in SQL when you create or modify a table.\nCreate Table With Primary Key\nIn SQL, you can create a table with a primary key by using CREATE TABLE syntax.\nCREATE TABLE Employees (\n    ID INT PRIMARY KEY,\n    NAME TEXT,\n    AGE INT,\n    ADDRESS CHAR(50)\n);\nIn this example, ID is the primary key which must consist of unique values and can’t be null.\nModify Table to Add Primary Key\nIf you want to add a primary key to an existing table, you can use ALTER TABLE syntax.\nALTER TABLE Employees\nADD PRIMARY KEY (ID);\nThis will add a primary key to ID column in the Employees table.\nComposite Primary Key\nWe can also use multiple columns to define a primary key. Such key is known as a composite key.\nCREATE TABLE Customers (\n    CustomerID INT,\n    StoreID INT,\n    CONSTRAINT pk_CustomerID_StoreID PRIMARY KEY (CustomerID,StoreID)\n);\nIn this case, each combination of CustomerID and StoreID must be unique across the whole table.",
                            "resources": []
                        }
                    },
                    {
                        "Foreign Key": {
                            "description": "A foreign key is a key used to link two tables together. It is a field (or collection of fields) in one table that refers to the primary key in another table. The table with the foreign key is called the child table, and the one with the primary key is called the referenced or parent table.",
                            "resources": []
                        }
                    },
                    {
                        "Unique": {
                            "description": "The UNIQUE constraint ensures that all values in a column are different; that is, each value in the column should occur only once. Both the UNIQUE and PRIMARY KEY constraints provide a guarantee for uniqueness for a column or set of columns.",
                            "resources": []
                        }
                    },
                    {
                        "NOT NULL": {
                            "description": "The NOT NULL constraint in SQL ensures that a column cannot have a NULL value. Thus, every row/record must contain a value for that column. It is a way to enforce certain fields to be mandatory while inserting records or updating records in a table.",
                            "resources": []
                        }
                    },
                    {
                        "CHECK": {
                            "description": "In SQL, CHECK is a constraint that limits the value range that can be placed in a column. It enforces domain integrity by limiting the values in a column to meet a certain condition.",
                            "resources": []
                        }
                    }
                ]
            },
            "JOIN Queries": {
                "description": "The JOIN clause is used to combine rows from two or more tables based on a related column between them. Different types of JOINs include INNER JOIN, LEFT (OUTER) JOIN, RIGHT (OUTER) JOIN, FULL (OUTER) JOIN, and SELF JOIN. Each type of JOIN serves a different purpose in combining and retrieving data from multiple tables.",
                "resources": [],
                "order": 7,
                "options": [
                    {
                        "INNER JOIN": {
                            "description": "An INNER JOIN in SQL is a type of join that returns the records with matching values in both tables. This operation compares each row of the first table with each row of the second table to find all pairs of rows that satisfy the join predicate.",
                            "resources": []
                        }
                    },
                    {
                        "LEFT JOIN": {
                            "description": "The SQL LEFT JOIN combines rows from two or more tables based on a related column between them and returns all rows from the left table (table1) and the matched rows from the right table (table2). If there is no match, the result is NULL on the right side.",
                            "resources": []
                        }
                    },
                    {
                        "RIGHT JOIN": {
                            "description": "The RIGHT JOIN keyword returns all records from the right table (table2), and the matched records from the left table (table1). If there is no match, the result is NULL on the left side.",
                            "resources": []
                        }
                    },
                    {
                        "FULL OUTER JOIN": {
                            "description": "A FULL OUTER JOIN in SQL combines rows from two or more tables, returning all rows from both the left and right tables. It includes matched and unmatched rows from both sides of the join clause. If a record in one table doesn't have a match in the other, it is still included in the result with NULL values.",
                            "resources": []
                        }
                    },
                    {
                        "Self Join": {
                            "description": "A SELF JOIN is a standard SQL operation where a table is joined to itself. It is useful for scenarios where comparison operations need to be made within a table by combining rows with other rows in the same table based on a given condition. Aliases for table(s) are used to avoid confusion during the join operation.",
                            "resources": []
                        }
                    },
                    {
                        "Cross Join": {
                            "description": "The cross join in SQL combines every row of the first table with every row of the second table, resulting in the Cartesian product of the two tables. It doesn't require any specific join condition. However, it can generate a large number of rows and should be used carefully.",
                            "resources": []
                        }
                    }
                ]
            },
            "Sub Queries": {
                "description": "In SQL, a subquery is a query embedded within another SQL query. You can alternately call it a nested or an inner query. The containing query is often referred to as the outer query. Subqueries are utilized to retrieve data that will be used in the main query as a condition to further restrict the data to be retrieved.\n\nSubqueries can be used in various parts of a query, including:\n\n- SELECT statement\n- FROM clause\n- WHERE clause\n- GROUP BY clause\n- HAVING clause",
                "resources": [],
                "order": 8,
                "options": [
                    {
                        "Types of Sub Queries": {
                            "description": "Subqueries, sometimes referred to as inner queries or nested queries, are queries that are embedded within the clause of another SQL query. There are different types of SQL subqueries that are frequently used including Scalar, Row, Column, and Table subqueries.",
                            "scalar_subqueries": {
                                "description": "Scalar subqueries return exactly one column with a single value. They can be used anywhere in your SQL where expressions are allowed.",
                                "example": "Example:\n\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  column_name operator\n       (SELECT column_name [, column_name ]\n        FROM table_name \n        WHERE condition);"
                            },
                            "row_subqueries": {
                                "description": "Row subqueries return one or more rows to the outer SQL select query. They return multiple columns and rows, so they cannot be directly used where scalar expressions are used.",
                                "example": "Example:\n\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  (column_name [, column_name ])\n      IN (SELECT column_name [, column_name ]\n          FROM table_name \n          WHERE condition);"
                            },
                            "column_subqueries": {
                                "description": "Column subqueries are used to return one or more columns to the outer SQL select query. They are used when the subquery is expected to return more than one column to the main query.",
                                "example": "Example:\n\nSELECT column_name [, column_name ]\nFROM   table1 [, table2 ]\nWHERE  (SELECT column_name [, column_name ]\n        FROM table_name \n        WHERE condition);"
                            },
                            "table_subqueries": {
                                "description": "Table subqueries are used in the FROM clause and return a table that can be used as a table-reference in an SQL statement. They come in handy when you want to perform operations such as joining multiple tables, union data from multiple sources, etc.",
                                "example": "Example:\n\nSELECT column_name [, column_name ]\nFROM\n    (SELECT column_name [, column_name ]\n     FROM   table1 [, table2 ])\nWHERE  condition;"
                            },
                            "note": "Remember that not all SQL databases support all types of subqueries. Learning how and when to utilize each form is an essential aspect of constructing effective SQL queries.",
                            "options": [
                                {
                                    "name": "Row",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, a 'row' refers to a record in a table. Each row in a table represents a set of related data, and every row in the table has the same structure.\n\nFor instance, in a table named 'customers', a row may represent one customer, with columns containing information like ID, name, address, email, etc.\n\nHere is a conceptual SQL table:\n\nID\tNAME\tADDRESS\tEMAIL\n1\tJohn\tNY\tjohn@example.com\n2\tJane\tLA\tjane@example.com\n3\tJim\tChicago\tjim@example.com\nEach of these lines of data is referred to as a 'row' in the SQL table.\n\nTo select a row, you would use a SELECT statement. Here's an example of how you might select a row:\n\nSELECT *\nFROM customers\nWHERE ID = 1;\nThis would output:\n\nID Name ADDRESS Email\n1 John NY john@example.com\nThe * in the statement refers to all columns. If you want to only select specific columns, you can replace * with the column name(s):\n\nSELECT NAME, EMAIL\nFROM customers\nWHERE ID = 1;\nIn this case, the output would be:\n\nName Email\nJohn john@example.com",
                                    "resources": []
                                },
                                {
                                    "name": "Table",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, a table is a collection of related data held in a structured format within a database. It consists of rows (records) and columns (fields).\n\nA table is defined by its name and the nature of data it will hold, i.e., each field has a name and a specific data type.\n\n**Table Creation**\nYou can create a table using the CREATE TABLE SQL statement. The syntax is as follows:\n\n```sqlCREATE TABLE table_name (column1 datatype,column2 datatype,column3 datatype,....);  ```\n\nHere, `table_name` is the name of the table, `column1`, `column2`… are the names of the columns, and `datatype` specifies the type of data the column can hold (e.g., varchar, integer, date, etc.).\n\n**Table Manipulation**\nOnce a table has been created, the INSERT INTO statement is used to insert new rows of data into the table.\n\n```sqlINSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...); ```\n\nThe SELECT statement is used to select data from the table.\n\n```sqlSELECT column1, column2,...FROM table_name;```\n\nThe UPDATE statement is used to modify existing records.\n\n```sqlUPDATE table_nameSET column1 = value1, column2 = value2,...WHERE condition;```\n\nAnd, finally, the DELETE statement is used to delete existing records.\n\n```sqlDELETE FROM table_name WHERE condition;```\n\nThese basic operations allow for full manipulation of tables in SQL, letting users manage their data effectively.",
                                    "resources": []
                                },
                                {
                                    "name": "Scalar",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, a scalar type is a type that holds a single value as opposed to composite types that hold multiple values. In simpler terms, scalar types represent a single unit of data.\n\nSome common examples of scalar types in SQL include:\n\n- Integers (INT)\n- Floating-point numbers (FLOAT)\n- Strings (VARCHAR, CHAR)\n- Date and Time (DATE, TIME)\n- Boolean (BOOL)\n\n**Examples**\nHere is how you can define different scalar types in SQL:\n\n**Integers**\nAn integer can be defined using the INT type. Here is an example of how to declare an integer:\n\n```sqlCREATE TABLE Employees (EmployeeID INT,FirstName VARCHAR(50),LastName VARCHAR(50));```\n\n**Floating-Point Numbers**\nFloating-point numbers can be defined using the FLOAT or REAL type. Here is an example of how to declare a floating-point number:\n\n```sqlCREATE TABLE Products (ProductID INT,Price FLOAT);```\n\n**Strings**\nStrings can be defined using the CHAR, VARCHAR, or TEXT type. Here is an example of how to declare a string:\n\n```sqlCREATE TABLE Employees (EmployeeID INT,FirstName VARCHAR(50)  LastName VARCHAR(50) );```\n\n**Date and Time**\nThe DATE, TIME, or DATETIME type can be used to define dates and times:\n\n```sqlCREATE TABLE Orders (OrderID INT,OrderDate DATE);```\n\n**Boolean**\nBooleans can be declared using the BOOL or BOOLEAN type. They hold either TRUE or FALSE.\n\n```sqlCREATE TABLE Employees (EmployeeID INT,IsActive BOOL);```\n\nRemember, the way these types are declared might slightly differ based on the SQL dialect you are using. It's crucial to refer to the specific documentation of the SQL flavor you're working with for the precise syntax and behavior.",
                                    "resources": []
                                },
                                {
                                    "name": "Column",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, columns are used to categorize the data in a table. A column serves as a structure that stores a specific type of data (ints, str, bool, etc.) in a table. Each column in a table is designed with a type, which configures the data that it can hold. Using the right column types and size can help to maintain data integrity and optimize performance.\n\n**Common SQL Column Types**\n- CHAR(n) - It is a fixed-length character string that holds n characters. The size can be 1 to 255. For example,\nCREATE TABLE Employee(ID CHAR(25));```\n\n- VARCHAR(n) - A variable-length character string up to n characters where n can be from 1 to 255. For example,\n\n```sqlCREATE TABLE Employee(ID VARCHAR(100));```\n\n- INT - This type is used for integers. For example,\n\n```sqlCREATE TABLE Customers(Age INT);```\n\n- DECIMAL(p,s) - This is a decimal type used for precision and scale. p represents the total number of digits and s for numbers after the decimal. For example,\n\n```sqlCREATE TABLE Products(Price DECIMAL(5,2));```\n\n- DATE - This type is used for date format 'YYYY-MM-DD'. For example,\n\n```sqlCREATE TABLE Orders(OrderedDate DATE);```\n\n- BOOL - It stores Boolean data types. It can only take True or False values. For example,\n\n```sqlCREATE TABLE Users(IsActive BOOL);```\n\nIn SQL, the column type helps in interpreting what kind of data to store in which column, whether it's number, text, date, or logical data. Remember, a table contains multiple columns and each column should have its unique name.\n\nWhen creating a table, you should specify the column names, types, and maximum length of the type [if required].",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "name": "Nested Subqueries",
                        "recommendation-type": "opinion",
                        "description": "In SQL, a subquery is a query that is nested inside a main query. If a subquery is nested inside another subquery, it is called a nested subquery. They can be used in SELECT, INSERT, UPDATE, or DELETE statements or inside another subquery.\n\nNested subqueries can get complicated quickly, but they are essential for performing complex database tasks.\n\n**Basic Syntax**:\n```sqlSELECT column_name [, column_name ]FROM   table1 [, table2 ]WHERE  column_name OPERATOR(SELECT column_name [, column_name ]FROM table1 [, table2 ][WHERE])```\n\n**How They Work**:\nIn a nested subquery, the inner subquery will run first, and its result will be used to run the outer query.\n\n**Example**:\nHere's an example where we want to find the customer names who made orders above the average order amount.\n```sqlSELECT CustomerName, CountryFROM CustomersWHERE CustomerID IN(SELECT CustomerID FROM OrdersWHERE Amount > (SELECT AVG(Amount) FROM Orders))```\n\nIn the above code:\n- The innermost query calculates the average order amount.\n- The middle subquery finds the CustomerIDs from the Orders table where the order Amount is greater than the average.\n- The outer query then gets the CustomerName from the Customers table where the CustomerID is in the list of CustomerIDs fetched from the middle subquery.\n\nThese are the basic aspects of nested subqueries in SQL. They can go as deep as the task requires, but keep in mind that too many nested subqueries can cause performance issues.",
                        "resources": [
                            {
                                "name": "",
                                "link": ""
                            }
                        ]
                    },
                    {
                        "name": "Correlated Subqueries",
                        "recommendation-type": "opinion",
                        "description": "In SQL, a correlated subquery is a subquery that uses values from the outer query in its WHERE clause. The correlated subquery is evaluated once for each row processed by the outer query. It exists because it depends on the outer query and cannot execute independently of the outer query because the subquery is correlated with the outer query as it uses its column in its WHERE clause.\n\n**Syntax**:\n```sqlSELECT column_name [, column_name...]FROM   table1 [, table2...]WHERE  column_name OPERATOR(SELECT column_name [, column_name...]FROM table_nameWHERE condition [table1.column_name = table2.column_name...]);```\n\n**Code Example**:\nFor instance, if you want to get the employees whose salaries are above their department’s average salaries, it can be queried with a correlated subquery as follows:\n```sqlSELECT e1.employee_name, e1.salaryFROM employee e1WHERE salary > (SELECT AVG(salary)FROM employee e2WHERE e1.department = e2.department);```\n\nIn the example above, the correlated subquery (the inner query) calculates the average salary for each department. The outer query then compares the salary of each employee to the average salary of their respective department. It returns the employees whose salaries are above their department’s average. The correlated subquery is executed once for each row selected by the outer query.\n\nAlso note that e1 and e2 are the aliases of the employee table so that we can use it in both the inner query and outer query. Here, e2.department in the inner query comes from the outer query’s e1.department.\n\nThus, a correlated subquery is a subquery that depends on the outer SQL query for its values. This means that the subquery is run once for every row in the outer query, often resulting in quite a bit of processing and thus slower results.",
                        "resources": [
                            {
                                "name": "",
                                "link": ""
                            }
                        ]
                    }
                ]
            },
            "Advanced SQL Functions": {
                "description": "Advanced SQL functions provide complex data manipulation and query capabilities enabling the user to perform tasks that go beyond the capabilities of basic SQL commands.\n\n**Window Function**\nWindowing Functions provide the ability to perform calculations across sets of rows related to the current query row.\n```sqlSELECT productName, productLine, buyPrice,AVG(buyPrice) OVER(PARTITION BY productLine) as avg_priceFROM productsORDER BY productLine, buyPrice;```\n\n**Aggregate Function**\nAggregate functions return a single result row based on groups of rows, rather than on single rows.\n```sqlSELECT COUNT(*) FROM products;```\n\n**Analytic Functions**\nAnalytic functions compute an aggregate value based on a group of rows. They differ from aggregate functions in that they return multiple rows for each group.\n```sqlSELECT department_id, last_name, hire_date, COUNT(*) OVER (PARTITION BY department_id) as dept_count,RANK() OVER (PARTITION BY department_id ORDER BY hire_date) as rankingFROM employees;```\n\n**Scalar Function**\nA scalar function returns a single value each time it is invoked. It is based on the input value.\n```sqlSELECT UPPER(productName) FROM products;```\n\n**Stored Procedures**\nStored Procedures are a prepared SQL code that you can save so the code can be reused over and over again.\n```sqlCREATE PROCEDURE SelectAllProducts @Product varchar(50)ASSELECT * FROM products WHERE Product = @ProductGO;```\n\n**String Functions**\nFunctions that manipulate the string data types. For example, LEFT(), LENGTH(), LOWER(), etc.\n```sqlSELECT LEFT('This is a test', 4);```\n\n**Date Functions**\nFunctions that manipulate the date data types. For example, GETDATE(), DATEADD(), DATEDIFF(), etc.\n```sqlSELECT GETDATE() AS CurrentDateTime;```\n\nRemember, not all types or functions are supported by every SQL distribution, but most of them have some sort of equivalent.",
                "resources": [],
                "order": 9,
                "options": [
                    {
                        "Numeric": {
                            "description": "SQL numeric functions are used to perform operations on numeric data types such as integer, decimal, and float. They’re fundamental in manipulating data in SQL commands and are commonly used in SELECT, UPDATE, DELETE, and INSERT statements.\n\n**Examples of SQL Numeric Functions**:\n- ABS() Function: This function returns the absolute (positive) value of a number.\n```sqlSELECT ABS(-243);```\nOutput:\n```plaintext243```\n- AVG() Function: This function returns the average value of a column.\n```sqlSELECT AVG(price) FROM products;```\n- COUNT() Function: This function returns the number of rows that match a specified criterion.\n```sqlSELECT COUNT(productID) FROM products;```\n- SUM() Function: This function returns the total sum of a numeric column.\n```sqlSELECT SUM(price) FROM products;```\n- MIN() & MAX() Functions: MIN() function returns the smallest value of the selected column, and MAX() function returns the largest value of the selected column.\n```sqlSELECT MIN(price) FROM products;SELECT MAX(price) FROM products;```\n- ROUND() Function: This function is used to round a numeric field to the nearest integer. You can, however, specify the number of decimals to be returned.\n```sqlSELECT ROUND(price, 2) FROM products;```\n- CEILING() Function: This function returns the smallest integer which is greater than or equal to the specified numeric expression.\n```sqlSELECT CEILING(price) FROM products;```\n- FLOOR() Function: This function returns the largest integer which is less than or equal to the specified numeric expression.\n```sqlSELECT FLOOR(price) FROM products;```\n- SQRT() Function: This function returns the square root of a number.\n```sqlSELECT SQRT(price) FROM products;```\n- PI() Function: This function returns the constant Pi.\n```sqlSELECT PI();```\n\nThese are just a few examples; SQL supports many more mathematical functions such as SIN, COS, TAN, COT, POWER, etc. Understanding and using these SQL numeric functions allows you to perform complex operations on the numeric data in your SQL tables.",
                            "resources": [],
                            "options": [
                                {
                                    "name": "ROUND",
                                    "recommendation-type": "opinion",
                                    "description": "The ROUND function in SQL is used to round a numeric field to the nearest specified decimal or integer.\n\nMost usually, ROUND accepts two arguments. The first one is the value that needs to be rounded, and the second is the number of decimal places to which the first argument will be rounded off. When dealing with decimals, SQL will round up when the number after the decimal point is 5 or higher, whereas it will round down if it’s less than 5.\n\n**Syntax**\nThe basic syntax for ROUND can be described as follows:\n```sqlROUND ( numeric_expression, length [ , function ] )```\n- `numeric_expression`: A floating point number to round.\n- `length`: The precision to which `numeric_expression` is to be rounded. When length is a positive number, rounding affects the right side of the decimal point. If length is negative, rounding affects the left side of the decimal point.\n- `function`: Optional parameter to determine the operation to perform. If this is omitted or 0, the `numeric_expression` is rounded. If this is 1, the `numeric_expression` is truncated.\n\n**Example 1**:\nRound off a decimal to the nearest whole number.\n```sqlSELECT ROUND(125.215);```\nThis will result in 125.\n\n**Example 2**:\nRound off a number to a specified decimal place.\n```sqlSELECT ROUND(125.215, 1);```\nThis will result in 125.2 as the second decimal place (5) is less than 5.\n\n**Example 3**:\nRound off the left side of the decimal.\n```sqlSELECT ROUND(125.215, -2);```\nThis will result in 100 as rounding now affects digits before the decimal point.\n\nWhenever you need to round off numeric data in SQL, the ROUND function is a valuable tool to have in your kit. It proficiently handles both positive and negative rounding, and its simple syntax makes it extremely user-friendly.",
                                    "resources": []
                                },
                                {
                                    "name": "CEILING",
                                    "recommendation-type": "opinion",
                                    "description": "CEILING is an advanced SQL function that is used to round up values. The function takes a single argument, which is a numeric or decimal number, and returns the smallest integer that is greater than or equal to the supplied number.\n\nThe syntax for using the CEILING function is:\n```sqlCEILING (numeric_expression)```\nThe `numeric_expression` is an expression of the exact numeric or approximate numeric data type categories, or types that can be implicitly converted to one of these categories.\n\nFor example, you have a table called ‘Products’ with a ‘Price’ column. Here's how you can use the CEILING function to round up all the prices to the nearest whole number:\n```sqlSELECT ProductName, Price, CEILING (Price) AS RoundedUpPriceFROM Products;```\nIn this example, if the original price was $10.25, the `RoundedUpPrice` will be $11. This is because the CEILING function rounds up the ‘Price’ value to the nearest whole number.\n\nIt’s essential to remember that CEILING always rounds up. So even if the Price is $10.01, the `RoundedUpPrice` according to CEILING would still be $11. If you want to round to the nearest whole number, you might want to use the ROUND function instead.\n\nAnother important note is that the return type of CEILING will be of the same type as the provided numeric expression. For instance, if you supply a numeric expression of type decimal, the return type will also be of type decimal.",
                                    "resources": []
                                },
                                {
                                    "name": "FLOOR",
                                    "recommendation-type": "opinion",
                                    "description": "The SQL FLOOR function is used to round down any specific decimal or numeric value to its nearest whole integer. The returned number will be less than or equal to the number given as an argument.\n\nOne important aspect to note is that the FLOOR function’s argument must be a number and it always returns an integer.\n\n**Syntax**\nThe syntax of using the FLOOR function in SQL is as follows:\n```sqlFLOOR (number);```\n**Example Usage**\nHere’s a simple example of its usage:\n```sqlSELECT FLOOR(25.75);```\nThe above query will return 25 as the result, as that’s the nearest integer less than 25.75.\n\nSuppose we have a table called Orders with a column SalePrice that includes decimal values. If we wanted to round down the SalePrice values to the nearest whole numbers, we could use a query like this:\n```sqlSELECT FLOOR(SalePrice) AS RoundedSalePriceFROM Orders;```\nThis would output a new column RoundedSalePrice where all the sale prices have been rounded down to the nearest integers.",
                                    "resources": []
                                },
                                {
                                    "name": "ABS",
                                    "recommendation-type": "opinion",
                                    "description": "The ABS function in SQL is used to return the absolute value of a number, i.e., the numeric value without its sign. The function takes a single argument which must be a number (integer, float, etc.) and returns the absolute, non-negative equivalent.\n\nThe general syntax for the ABS function is as follows:\n```sqlABS(expression)```\nInthesyntaxabove,theexpressionisrequiredandcaneither be a literal number, a column name, the result of another function, or any valid SQL expression that resolves to a numeric value.\n\n**Examples**\nConsider a database table Orders:\n```plaintextOrderIDProductQuantity1Apple-52Banana103Cherry-15```\nIf you want to get the absolute value of the ‘Quantity’ column, you could use the ABS function like this:\n```sqlSELECTOrderID,Product,ABS(Quantity)as'Absolute Quantity'FROMOrders;```\nThe output will be:\n```plaintextOrderIDProductAbsoluteQuantity1Apple52Banana103Cherry15```\nAs you can see, the negative values in the ‘Quantity’ column have been converted to positive values by the ABS function.",
                                    "resources": []
                                },
                                {
                                    "name": "MOD",
                                    "recommendation-type": "opinion",
                                    "description": "The SQL MOD() function is a mathematical function that returns the remainder of the values from the division of two numbers. It calculates the modulo operation. This function is very useful when you want to find the remainder value after one number is divided by another.\n\n**Syntax**\nThe syntax of the MOD function in SQL is:\n```sqlMOD(expression1, expression2)```\n`Expression1` and `Expression2` are the values that you want to apply the function to.\n\n**Basic Usage**\nFor instance, if you want to find the remainder of the division of 15 by 4 you would write:\n```sqlSELECT MOD(15, 4) as result;```\nThe result would be 3 because 3 is the remainder after dividing 15 by 4.\n\n**Usage with Table Columns**\nThe MOD() function can also be applied to table columns. Let’s imagine that you have a table named “Orders” with an “OrderNumber” column and you want to find the remainder of every order number when divided by 7, you would do:\n```sqlSELECT OrderNumber, MOD(OrderNumber, 7) as resultFROM Orders;```\nThis will return a list of all order numbers, along with the remainder when each order number is divided by 7.\n\nKeep in mind that the SQL MOD() function may not work in the same way, or might not support all features, in every SQL database. Always refer to the documentation specific to the SQL database you are using.",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "String Functions": {
                            "description": "In SQL, you can perform various operations on strings, including extracting a string, combining two or more strings, and converting the case of a string.\n\n**CONCAT Function**\nThe CONCAT function combines two or more strings into one string. The following is the syntax:\n```sqlCONCAT(string1, string2, ...., string_n)```\n**Example**:\n```sqlSELECT CONCAT('Hello ', 'World');```\nThe output of the above SQL statement will be ‘Hello World’.\n\n**SUBSTRING Function**\nThe SUBSTRING function extracts a string from a given string. The syntax looks as follows:\n```sqlSUBSTRING(string, start, length)```\n**Example**:\n```sqlSELECT SUBSTRING('SQL Tutorial', 1, 3);```\nThe output of the above query will be ‘SQL’.\n\n**LENGTH Function**\nThe LENGTH function returns the length of a string. The syntax is:\n```sqlLENGTH(string)```\n**Example**:\n```sqlSELECT LENGTH('Hello World');```\nThe output of the above SQL statement will be 11.\n\n**UPPER and LOWER Function**\nThe UPPER function converts all the letters in a string to uppercase, whereas the LOWER function to lowercase.\n\n**Syntax**:\n```sqlUPPER(string)\n\nLOWER(string)```\n**Examples**:\n```sqlSELECT UPPER('Hello World');\n\nSELECT LOWER('Hello World');```\nThe output of the above SQL statements will be ‘HELLO WORLD’ and ‘hello world’ respectively.\n\n**TRIM Function**\nThe TRIM function removes leading and trailing spaces of a string. You can also remove other specified characters.\n\n**Syntax**:\n```sqlTRIM([LEADING|TRAILING|BOTH] [removal_string] FROM original_string)```\n**Example**:\n```sqlSELECT TRIM('   Hello World   ');\nSELECT TRIM('h' FROM 'hello');```\nThe output of the first query will be ‘Hello World’ and that of the second query will be ‘ello’.",
                            "resources": [],
                            "options": [
                                {
                                    "name": "UPPER",
                                    "recommendation-type": "opinion",
                                    "description": "UPPER() is a built-in string function in SQL. As the name suggests, it is used to convert all letters in a specified string to uppercase. If the string already consists of all uppercase characters, the function will return the original string.\n\n**Syntax for this function is**:\n```sqlUPPER(string)```\nHere ‘string’ can be a string value or a column of a table of string(s) type.\n\nLet’s assume a table ‘students’ with column ‘name’ as below:\n```plaintextnameJohn DoeJane SmithKelly Will```\nIf we want all the names in uppercase, we’ll use UPPER() function as:\n```sqlSELECT UPPER(name) as 'Upper Case Name' FROM students;```\nAnd we will get:\n```plaintextUpper Case NameJOHN DOEJANE SMITHKELLY WILL```\nSo, UPPER() function helps us to bring an entire string to uppercase for easier comparison and sorting.",
                                    "resources": []
                                },
                                {
                                    "name": "LOWER",
                                    "recommendation-type": "opinion",
                                    "description": "LOWER is a built-in function in SQL used to return all uppercase character(s) in a string to lowercase. It can be quite useful when performing case-insensitive comparisons or searches in your queries.\n\n**Syntax**:\nThe basic syntax for LOWER in SQL is:\n```sqlLOWER(string)```\nHere, ‘string’ can be a literal string or a column of a table, and the function will return the string with all alphabetic characters converted to lowercase.\n\n**Example**:\nLet’s take a look at a very basic example. Assuming we have the following string “SQL is BAE!” and we want to convert it to lower case.\n```sqlSELECT LOWER('SQL is BAE!') AS LowerCaseString;```\n**Output**:\n```plaintextlowercasestring----------------sql is bae!```\nIf you are using a column from a table, let’s say we have a table ‘students’ with a column ‘Name’ and we want to convert all the entries in that column to lowercase:\n```sqlSELECT LOWER(Name) AS LowerCaseName FROM students;```\nHere, the LOWER function will return all the names from the ‘Name’ column in the ‘students’ table in their lowercase forms.\n\nRemember, the LOWER function doesn’t affect the numbers and special characters in the input string, it only converts uppercase alphabetical characters to lowercase.",
                                    "resources": []
                                },
                                {
                                    "name": "SUBSTRING",
                                    "recommendation-type": "opinion",
                                    "description": "The SQL SUBSTRING function is used to extract a part of a string, where you can specify the start position and the length of the text. This function can be very beneficial when you only need a specific part of a string.\n\n**Syntax**\nThe standardized SQL syntax for SUBSTRING is as follows:\n```sqlSUBSTRING(string, start, length)```\nWhere:\n\n- 'string' is the source string from which you want to extract.\n- 'start' is the position to start extraction from. The first position in the string is always 1.\n- 'length' is the number of characters to extract.\n\n**Usage**\nFor instance, if you want to extract the first 5 characters from the string ‘Hello World’:\n```sqlSELECT SUBSTRING('Hello World', 1, 5) as ExtractedString;```\n**Result**:\n```plaintext| ExtractedString || --------------- || Hello           |```\nYou can also use SUBSTRING on table columns, like so:\n```sqlSELECT SUBSTRING(column_name, start, length) FROM table_name;```\n**SUBSTRING with FROM and FOR**\nIn some database systems (like PostgreSQL and SQL Server), the SUBSTRING function uses a different syntax:\n```sqlSUBSTRING(string FROM start FOR length)```\nThis format functions the same way as the previously mentioned syntax.\n\nFor example:\n```sqlSELECT SUBSTRING('Hello World' FROM 1 FOR 5) as ExtractedString;```\nThis would yield the same result as the previous example - ‘Hello’.\n\n**Note**\nSQL is case-insensitive, meaning SUBSTRING, substring, and Substring will all function the same way.",
                                    "resources": []
                                },
                                {
                                    "name": "REPLACE",
                                    "recommendation-type": "opinion",
                                    "description": "You can use the REPLACE() function in SQL to substitute all occurrences of a specified string.\n\n**Synopsis**\n\nREPLACE(input_string, string_to_replace, replacement_string)\n\n**Parameters**\n\n- 'input_string': This is the original string where you want to replace some characters.\n- 'string_to_replace': This is the string that will be searched for in the original string.\n- 'replacement_string': This is the string that will replace the 'string_to_replace' in the original string.\n\nThe REPLACE() function is handy when it comes to manipulating and modifying data in various ways, particularly when used in combination with other SQL data-manipulation functions.\n\n**Examples**\n\nSuppose we have the following table, Employees:\n\n| EmpId | EmpName          |\n|-------|------------------|\n| 1     | John Doe         |\n| 2     | Jane Doe         |\n| 3     | Jim Smith Doe    |\n| 4     | Jennifer Doe Smith |\n\nHere’s how you can use the REPLACE() function:\n```sqlSELECT EmpId, EmpName,REPLACE(EmpName, 'Doe', 'Roe') as ModifiedNameFROM Employees;```\nAfter the execution of the above SQL, we will receive:\n\n| EmpId | EmpName          | ModifiedName    |\n|-------|------------------|-----------------|\n| 1     | John Doe         | John Roe        |\n| 2     | Jane Doe         | Jane Roe        |\n| 3     | Jim Smith Doe    | Jim Smith Roe   |\n| 4     | Jennifer Doe Smith | Jennifer Roe Smith |\n\nYou can see that all occurrences of ‘Doe’ are replaced with ‘Roe’.",
                                    "resources": []
                                },
                                {
                                    "name": "CONCAT",
                                    "recommendation-type": "opinion",
                                    "description": "CONCAT is a SQL function that allows you to concatenate, or join, two or more strings together. This is extremely useful whenever you need to combine text from multiple columns into a single column.\n\nThe syntax for the CONCAT function is quite simple:\n\nCONCAT(string1, string2, ..., string_n)\nThis function accepts as input any number of string arguments, from two to as many as needed, and returns a new string which is the result of all the input strings joined together. The strings are concatenated in the order in which they are passed to the function.\n\nHere’s a simple example:\n```sql\nSELECT CONCAT('Hello', ' ', 'World');\n```\nThis will return the string:\n\n'Hello World'\n\nYou can also use CONCAT with columns from a table:\n```sql\nSELECT CONCAT(first_name, ' ', last_name) AS full_name\nFROM employees;\n```\nThe above query will return a new column full_name which is the result of first_name and last_name with a space in between. If first_name is ‘John’ and last_name is ‘Doe’, the returned full name would be ‘John Doe’.\n\nHowever, keep in mind that CONCAT will return NULL if any of the input strings is NULL. To avoid this, you can use the CONCAT_WS function which accepts a separator as the first argument and then a list of strings to concatenate.\n```sql\nSELECT CONCAT_WS(' ', first_name, last_name) AS full_name\nFROM employees;\n```\nThe CONCAT_WS function will ignore any NULL values, only joining the non-NULL values with the provided separator. Hence, ‘John NULL’ would become just ‘John’.",
                                    "resources": []
                                },
                                {
                                    "name": "LENGTH",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, LENGTH is a built-in function that allows you to find the number of characters in a string or the length of a string.\n\nSyntax:\n\nLENGTH ( string )\nHere, string can be any string literal, column or expression resulting in a string.\n\nExamples\nConsider an “employees” table:\n\nid\tfirst_name\tlast_name\n1\tJohn\tDoe\n2\tJane\tSmith\n3\tAlice\tMurphy\nTo compute the length of the first_name field for all records, use the following SQL statement:\n```sql\nSELECT first_name, LENGTH(first_name) as length_of_first_name\nFROM employees;\n```\nOutput:\n```plaintext\nfirst_name\tlength_of_first_name\nJohn\t4\nJane\t4\nAlice\t5\n```\nUsage with DISTINCT\nLENGTH can also be used in conjunction with DISTINCT to find the number of distinct lengths of a specific field.\n```sql\nSELECT DISTINCT LENGTH(first_name) as distinct_length_of_first_name\nFROM employees;\n```\nUsage with WHERE Clause\nIt can work in the WHERE clause to return only those records where the length of a specific field meets a certain condition.\n```sql\nSELECT *\nFROM employees\nWHERE LENGTH(first_name) > 4;\n```\nDo note that the LENGTH function may return different results in different SQL systems due to character set and collation differences. In some systems, LENGTH() returns length in characters while in others it could return length in bytes.\n\nFor example, MySQL has separate CHAR_LENGTH() and LENGTH() functions. CHAR_LENGTH() returns the length of the string in characters, while LENGTH() in MySQL returns the length of the string in bytes. This can make a difference if your string includes multibyte characters (like UTF-8). In such scenarios, it’s always recommended to be sure how your specific SQL system implements LENGTH function.",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "Conditional": {
                            "description": "In SQL, Conditional expressions can be used in the SELECT statement, WHERE clause, and ORDER BY clause to evaluate multiple conditions. These are SQL’s version of the common if…then…else statement in other programming languages.\n\nThere are two kinds of conditional expressions in SQL:\n\nCASE expression\n\nThe CASE expression is a flow-control statement that allows you to add if-else logic to a query. It comes in two forms: simple and searched.\n\nHere is an example of a simple CASE expression:\n```sql\nSELECT OrderID, Quantity,\n    CASE\n        WHEN Quantity > 30 THEN 'Over 30'\n        ELSE 'Under 30'\n    END AS QuantityText\nFROM OrderDetails;\n```\nA searched CASE statement:\n```sql\nSELECT FirstName, City,\n    CASE\n        WHEN City = 'Berlin' THEN 'Germany'\n        WHEN City = 'Madrid' THEN 'Spain'\n        ELSE 'Unknown'\n    END AS Country\nFROM Customers;\n```\nCOALESCE expression\n\nThe COALESCE function returns the first non-null value in a list. It takes a comma-separated list of values and returns the first value that is not null.\n\nAn example of a COALESCE statement:\n```sql\nSELECT ProductName,\n    COALESCE(UnitsOnOrder, 0) As UnitsOnOrder,\n    COALESCE(UnitsInStock, 0) As UnitsInStock,\nFROM Products;\n```\nNULLIF expression\n\nNULLIF returns null if the two given expressions are equal.\n\nExample of using NULLIF:\n```sql\nSELECT NULLIF(5,5) AS Same,\n       NULLIF(5,7) AS Different;\n```\nIIF expression\n\nIIF function returns value_true if the condition is TRUE, or value_false if the condition is FALSE.\n\nExample of using IIF:\n```sql\nSELECT IIF (1>0, 'One is greater than zero', 'One is not greater than zero');\n```\nThese are essential constructs that can greatly increase the flexibility and functionality of your SQL code, particularly when dealing with elaborate conditions and specific data selections.",
                            "resources": [],
                            "options": [
                                {
                                    "name": "CASE",
                                    "recommendation-type": "opinion",
                                    "description": "CASE is a conditional statement in SQL that performs different actions based on different conditions. It allows you to perform IF-THEN-ELSE logic within SQL queries. It can be used in any statement or clause that allows a valid expression.\n\nThere are two forms of the CASE statement:\n\nSimple CASE expression - It compares an expression to a set of simple expressions to return a result.\n```sql\nSELECT column1, column2, \n(CASE \n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n    ...\n    ELSE result \nEND) \nFROM table_name;\n```\nSearched CASE expression - It evaluates a set of Boolean expressions to return a result.\n```sql\nSELECT column1, column2,\n(CASE\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n    ...\n    ELSE result\nEND) \nFROM table_name;\n```\nIn both forms, CASE returns a result_1, result_2, …, if condition_1, condition_2, … is true. If no conditions are true, it returns the value in the ELSE clause. If the ELSE clause is omitted and no conditions are true, it returns NULL.\n\nHere’s a concrete example:\n```sql\nSELECT OrderID, Quantity,\n (CASE\n     WHEN Quantity > 30 THEN 'Over 30'\n     WHEN Quantity = 30 THEN 'Equals 30'\n     ELSE 'Under 30'\n END) AS QuantityText\nFROM OrderDetails;\n```\nFrom the “OrderDetails” table, the statement lists ‘OrderID’, ‘Quantity’, and a column named ‘QuantityText’ that displays ‘Over 30’ if ‘Quantity > 30’ or ‘Equals 30’ if ‘Quantity = 30’ or ‘Under 30’ if both conditions are false.",
                                    "resources": []
                                },
                                {
                                    "name": "NULLIF",
                                    "recommendation-type": "opinion",
                                    "description": "NULLIF is a built-in conditional function in SQL Server. The NULLIF function compares two expressions and returns NULL if they are equal or the first expression if they are not.\n\nSyntax\nHere’s the syntax of the NULLIF function:\n\nNULLIF(expression1, expression2);\nNULLIF compares expression1 to expression2. If expression1 and expression2 are equal, the function returns NULL. Otherwise, it returns expression1. Both expressions must have the same data type.\n\nExample\nConsider the following example:\n\nSELECT \n    first_name, \n    last_name,\n    NULLIF(email, 'NA') AS email\nFROM \n    users;\nIn this SQL Server NULLIF function example, if the field email is ‘NA’, then NULL would be returned. Otherwise the actual email field value is returned.\n\nIn another example, consider a division operation:\n\nSELECT \n    avg_salary,\n    NULLIF(avg_salary, 0) AS avg_salary_no_zero\nFROM \n    positions;\nIn this SQL Server NULLIF function example, if avg_salary field is 0, then NULL would be returned. This is useful to avoid division by zero errors.\n\nIn nutshell, the SQL NULLIF function can be handy in many scenarios such as to circumvent division by zero errors or to translate known sentinel values into NULL values that can be handled by SQL’s NULL handling functions.",
                                    "resources": []
                                },
                                {
                                    "name": "COALESCE",
                                    "recommendation-type": "opinion",
                                    "description": "The COALESCE function in SQL is used to manage NULL values in data. It scans from left to right through the arguments and returns the first argument that is not NULL. The COALESCE function allows handling the case where you have possible NULL values in your data and you want to replace it with some other value.",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "Date and Time": {
                            "description": "In SQL, DATE is a data type that stores the date. It does not store time information. The format of the date is, 'YYYY-MM-DD'. SQL provides several functions to handle and manipulate dates.GETDATE()GETDATE() returns the current date and time as a DateTime datatype. It does not require any arguments.SELECT GETDATE() AS CurrentDateTime;DATEDIFF()DATEDIFF() returns the difference between two date values based on the unit of time you want to use. The syntax is DATEDIFF(datepart, startdate, enddate).SELECT DATEDIFF(day, '2022-01-01', '2022-01-15') AS DiffInDays;DATEADD()DATEADD() adds or subtracts a specified time interval from a date. Its syntax is DATEADD(datepart, number, date).SELECT DATEADD(year, 1, '2022-01-01') AS NewDate;CONVERT()CONVERT() is used to convert from one data type to another, and it is commonly used to format DateTime values. Its syntax is CONVERT(data_type(length), expression, style).SELECT CONVERT(VARCHAR(19), GETDATE()) AS FormattedDateTime;Remember to replace date with your date in above queries.DateTime FormatBy using appropriate format codes, SQL allows us to present dates and times in various formats.SELECT FORMAT(GETDATE(), 'MM/dd/yyyy') AS DateFormatted;Also, by using specific column names instead of GETDATE(), the same patterns can be applied to DateTime values in your data.Note: All dates are stored as numeric values under the hood, with the integer portion representing the date and the decimal portion representing the time. Also, different database systems may use slightly different functions for handling dates and times, so be sure to check the documentation for your specific DBMS.",
                            "resources": [
                                {
                                    "name": "SQL Date Functions",
                                    "link": "https://example.com/sql-date-functions"
                                }
                            ],
                            "options": [
                                {
                                    "name": "DATE in SQL",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, DATE is a data type that stores the date. It does not store time information. The format of the date is, 'YYYY-MM-DD'. SQL provides several functions to handle and manipulate dates.}Below are some common examples of how to use the DATE data type in SQLCreate a table with DATE data typeCREATE TABLE Orders (OrderId int,ProductName varchar(255),OrderDate date);In this example, the OrderDate column uses the DATE data type to store the date of the orderInsert a date value into a tableINSERT INTO Orders (OrderId, ProductName, OrderDate)VALUES (1, 'Product 1', '2022-01-01');This command inserts a new row into the Orders table with a date.Retrieve data with a specific dateSELECT * FROM Orders WHERE OrderDate = '2022-01-01';This command retrieves all orders made on January 1, 2022.Update a date value in a tableUPDATE Orders SET OrderDate = '2022-01-02' WHERE OrderId = 1;This command updates the date from January 1, 2022 to January 2, 2022, for the order with the order ID 1.SQL Date FunctionsSQL also provides several built-in functions to work with the DATE data type:CURRENT_DATEReturns the current date.SELECT CURRENT_DATE;DATEADDAdd or subtract a specified time interval from a date.SELECT DATEADD(day, 5, OrderDate) AS Due DateFROM Orders;In this example, we are adding 5 days to each OrderDate in the table Orders.DATEDIFFGet the difference between two dates.SELECT DATEDIFF(day, '2022-01-01', '2022-01-06') AS Difference;It will return 5, that is the difference in days between the two dates.",
                                    "resources": []
                                },
                                {
                                    "name": "TIME in SQL",
                                    "recommendation-type": "opinion",
                                    "description": "In SQL, the TIME data type is used to store time values in the database, allowing you to store hours, minutes, and seconds. The format of a TIME is 'HH:MI:SS'. SQL provides functions for working with TIME data type in SQL: }CREATE TABLE table_name (column_name TIME);You can store data using the following syntax:INSERT INTO table_name (column_name) values ('17:34:20');RangeThe time range in SQL is ‘00:00:00’ to ‘23:59:59’.Fetching DataTo fetch the data you can use the SELECT statement. For example:SELECT column_name FROM table_name;It will return the time values from the table.FunctionsSQL provides several functions to work with the TIME data type. Some of them include:CURTIME()Return the current time.SELECT CURTIME();ADDTIME()Add time values.SELECT ADDTIME('2007-12-31 23:59:59','1 1:1:1');TIMEDIFF()Subtract time values.SELECT TIMEDIFF('2000:01:01 00:00:00', '2000:01:01 00:01:01');ConversionConversion of TIME data type is also possible in SQL. It can be converted into other data types, like INT, and vice versa. Here is a conversion example of TIME to INT:SELECT TIME_TO_SEC('22:23:00');This was a brief summary about “TIME” in SQL.",
                                    "resources": []
                                },
                                {
                                    "name": "DATEPART in SQL",
                                    "recommendation-type": "opinion",
                                    "description": "DATEPART is a useful function in SQL that allows you to extract a specific part of a date or time field. You can use it to get the year, quarter, month, day of the year, day, week, weekday, hour, minute, second, or millisecond from any date or time expression.Here’s the basic syntax of DATEPART:DATEPART(datepart, date)Here datepart is the part of the date that you want to extract, and date is the date value from which the part should be extracted.Here are some examples:Extracting the year from a date:SELECT DATEPART(year, '2021-07-14') AS 'Year';In this example, it would return 2021.Extracting the month:SELECT DATEPART(month, '2021-07-14') AS 'Month';The result of this command would be 7.Extracting the day:SELECT DATEPART(day, '2021-07-14') AS 'Day';This would return 14.Extracting the hour, minute, or second from a datetime:SELECT DATEPART(hour, '2021-07-14T13:30:15') AS 'Hour',DATEPART(minute, '2021-07-14T13:30:15') AS 'Minute',DATEPART(second, '2021-07-14T13:30:15') AS 'Second';This would return 13, 30, and 15 respectively.Remember, the DATEPART function returns an integer value. It is essential when you want to compare or group by a specific part of a date or time field in SQL.",
                                    "resources": []
                                },
                                {
                                    "name": "DATEADD in SQL",
                                    "recommendation-type": "opinion",
                                    "description": "DATEADD is a built-in function in SQL that allows you to add or subtract units of time from a specified date. The function is useful for performing operations on dates, such as finding a date 'n' days before or after a specified date. It takes three parameters: an interval type, a number, and a date from which the calculation is based.DATEADD(interval, number, date)Here’s what each param means:interval: The part of date to which an integer value will be added. This could be a year, quarter, month, day, hour, minute, second, millisecond, microsecond, or nanosecond.number: The value to add. The value can either be negative to get dates in the past or positive to get dates in the future.date: The date or datetime expression to which the interval and number are added.For example, if we want to add three days to the date ‘2022-01-01’, we would write:SELECT DATEADD(day, 3, '2022-01-01') as NewDateThe result would be: 2022-01-04.You can substitute ‘day’ with any of the accepted interval types to add different units of time.Sample QueryIf you have a table called Orders with a DateTime field OrderDate and you want to find all orders placed in the next seven days, you can use the DATEADD function as follows:SELECT * FROM OrdersWHERE OrderDate <= DATEADD(day, 7, GETDATE())This will return all orders from now until a week from now.",
                                    "resources": []
                                },
                                {
                                    "name": "TIMESTAMP in SQL",
                                    "recommendation-type": "opinion",
                                    "description": "SQL TIMESTAMP is a data type that allows you to store both date and time. It is commonly used to track updates and changes made to a record, providing a chronological timeline of events. The format and storage size of TIMESTAMP may vary slightly depending on the SQL platform. For example, MySQL uses the 'YYYY-MM-DD HH:MI:SS' format, and PostgreSQL stores it in a similar format but with the ability to include microseconds. Here is how you can define a column with a TIMESTAMP type in an SQL tableCREATE TABLE table_name (column1 TIMESTAMP,column2 VARCHAR(100),...);A common use-case of TIMESTAMP is to have an automatically updated timestamp each time the row is updated. This can be achieved by setting the DEFAULT constraint to CURRENT_TIMESTAMP:CREATE TABLE table_name (column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,column2 VARCHAR(100),...);In MySQL, ON UPDATE CURRENT_TIMESTAMP can be used to automatically update the TIMESTAMP field to the current date and time whenever there is any change in other fields of the rowCREATE TABLE table_name (column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,column2 VARCHAR(100),...);You can also insert or update records with a specific timestamp:INSERT INTO table_name (column1, column2) VALUES ('2019-06-10 10:20:30', 'example data');UPDATE table_name SET column1 = '2020-07-20 15:30:45' WHERE column2 = 'example data';Remember that the format of the date and time you enter must correspond to the format used by the SQL platform you are using.",
                                    "resources": []
                                }
                            ]
                        }
                    }
                ]
            },
            "Views": {
                "description": "SQL views are virtual tables that do not store data directly. They are essentially a saved SQL query and can pull data from multiple tables or present data from one table in a different way.Creating ViewsYou can create a view using the CREATE VIEW statement. In the following example, a new view named CustomerView is created which contains customer’s ID, name, and address from the Customers table:CREATE VIEW CustomerView ASSELECT CustomerID, Name, AddressFROM Customers;Querying ViewsAfter a view has been created, it can be used in the FROM clause of a SELECT statement, as if it’s an actual table. For instance, to select all from CustomerView:SELECT *FROM CustomerView;Updating ViewsThe CREATE OR REPLACE VIEW statement is used to update a view. Consider the CustomerView we created earlier. If we want to include the customer’s phone, we can update it as follows:CREATE OR REPLACE VIEW CustomerView ASSELECT CustomerID, Name, Address, PhoneFROM Customers;Dropping ViewsTo delete a view, use the DROP VIEW statement:DROP VIEW CustomerView;Keep in mind that not all database systems support the CREATE OR REPLACE VIEW statement. Also, the updatability of a view depends on whether it includes functions, expressions, or multiple tables. Some databases might not let you update a view at all.RestrictionsThere are a few restrictions to bear in mind when working with views. SQL views can’t:Contain a ORDER BY clause in the view definitionBe indexedHave triggers or default valuesEach database may have its own specific limitations and capabilities with using views, so always refer to the official documentation for more information.Note: The above examples use a hypothetical Customers table. Replace this with your actual table name when trying these in your environment.",
                "resources": [
                    {
                        "name": "SQL Views Overview",
                        "link": "https://example.com/sql-views-overview"
                    }
                ],
                "order": 10,
                "options": [
                    {
                        "name": "Creating Views in SQL",
                        "recommendation-type": "opinion",
                        "description": "In SQL, creating views can be achieved through the CREATE VIEW statement. A view is a virtual table based on the result-set of an SQL statement. It contains rows and columns from one or more tables. The syntax for the CREATE VIEW statement is provided with an example.\nCREATEVIEWview_nameASSELECTcolumn1,column2,...FROM table_nameWHEREcondition;Here:CREATEVIEWview_name:Itcreatesanewviewhatyoudefinwithview_name.ASSELECTcolumn1column2...:Thesearethecolumnsyouwantinyourview.Yocachooseoneormorecolumnsfromoneormoretables.FROMtable_name:table_name is the name of the table from which you want to create the view.WHERE : It is an optional clause that you can use to specify conditions for displaying records.Example:Let’s say you have a table named Employees having following data:IDNAMESALARYDEPARTMENT_ID1John300022Sue350033Phil450024Anna50001You can create a view that shows only the employees from department 2:CREATE VIEW Department2ASSELECTName,SalaryFROMEmployeesWHEREDepartment_ID=2;Afterrunningthisstatement,Department2willbeasavedviewinyourdatabase, and you can query it likeyouwouldwithastandardtable:SELECTFROMDepartment2ThiswouldbringupNAMESALARYJohn3000Phil4500Intotal,theCREATEVIEWstatementisausefulcommandwhenyouwanttosaveaparticularqueryanditsresultsetforfutureuse.Thiscansimplifycomplexqueriesbybreakingthemupintomanageableparts",
                        "resources": []
                    },
                    {
                        "name": "Modifying Views in SQL",
                        "recommendation-type": "opinion",
                        "description": "In SQL, you can modify a VIEW in two ways: using CREATE OR REPLACE VIEW to change the VIEW's definition while keeping the VIEW name intact or by using the DROP VIEW and CREATE VIEW approach. The text provides syntax and examples for both methods, along with a caution about the potential impact on other dependencies when dropping a view. It also explains how to modify data through a VIEW and mentions the limitations of modifying complex views.Modifying VIEW Using CREATE OR REPLACE VIEWSyntax:CREATE OR REPLACE VIEW view_name ASSELECT column1, column2, ...FROM table_nameWHERE condition;Example:CREATE OR REPLACE VIEW customer_view ASSELECT customer_name, countryFROM customersWHERE country='USA';In this example, ‘customer_view’ will show the names and countries of customers only from the USA.Modifying VIEW Using DROP VIEW and CREATE VIEWSyntax: Drop the VIEW:DROP VIEW view_name;Create a new VIEW:CREATE VIEW view_name ASSELECT column1, column2, ...FROM table_nameWHERE condition;Example: Drop the VIEWDROP VIEW customer_view;Create a new VIEW:CREATE VIEW customer_view ASSELECT customer_name, countryFROM customersWHERE country='UK';In this example, we first removed ‘customer_view’. Then, we created it again with the new definition where it now shows the names and countries of the customers only from the UK.CAUTION: If other views, stored procedures, or programs depend on this view, they will be affected after you drop the view. For this reason, using CREATE OR REPLACE VIEW is generally safer.Modifying Data through VIEWIn some cases, you can modify the data of the underlying tables via a VIEW.Syntax:UPDATE view_nameSET column1 = value1, column2 = value2, ...WHERE condition;Example:UPDATE customer_viewSET country = 'USA'WHERE customer_name = 'John Doe';This command will update the country of ‘John Doe’ to ‘USA’ in both the VIEW and the underlying table.However, not every VIEW is updatable. You can only modify the data if the VIEW you’re modifying is a simple VIEW that returns results from a single table without any aggregation or complex clauses. If you attempt to modify a complex view (i.e., it includes JOIN, GROUP BY, HAVING, DISTINCT), you will get an error",
                        "resources": []
                    },
                    {
                        "name": "Dropping Views in SQL",
                        "recommendation-type": "opinion",
                        "description": "In SQL, 'dropping' is the process of deleting an existing database object. When it comes to views, 'dropping' means deleting an existing view from the database. The text explains the importance of caution when dropping views and provides the basic syntax for dropping a view in SQL. It also covers the use of the IF EXISTS parameter to check for the existence of a view before dropping it.Dropping ViewsYou can drop a view in SQL using the DROP VIEW statement. The DROP VIEW statement removes one or more views from the database. You specify the name of the view that you want to remove after the DROP VIEW clause.Here is the basic syntax to drop an existing view:DROP VIEW view_name;To drop multiple views in a single command, you use a list of comma-separated views.DROP VIEW view_name1, view_name2, ..., view_name_n;Note: Be careful when dropping views. Once a view is dropped, all the permissions granted on it will also be dropped.Before dropping a view, you can check if the view exists by using the IF EXISTS parameter. If you drop a view that does not exist, you will get an error. To prevent this, you can use the IF EXISTS parameter.Here is how you do it:DROP VIEW IF EXISTS view_name;In this case, if the view exists, it will be dropped. If the view does not exist, nothing happens and you don’t get an error.",
                        "resources": []
                    }
                ]
            },
            "Indexes": {
                "description": "An index in SQL is a database object used to improve the speed of data retrieval operations on a database table. This text explains the concept of indexes and covers various types of indexes, including clustered and non-clustered indexes, composite indexes, unique indexes, explicit and implicit indexes, and full-text indexes. It also mentions the trade-off between query speed and update costs when working with indexes. Creating IndexesTo create an index, you use the CREATE INDEX command followed by the index name, the table name, and the columns you want to use in the index.CREATE INDEX index_nameON table_name(column_name);Removing IndexesIf an index is no longer required or if it’s causing performance issues due to too much storage consumption, it can be dropped using the DROP INDEX command.DROP INDEX index_name;Listing IndexesYou can get a list of all the indexes on a table using the SHOW INDEXES command.SHOW INDEXES IN table_name;Remember that most SQL databases automatically create indexes for primary keys, and they do not need to be managed manually.Modifying IndexesModifying an existing index often means dropping the old index and creating a new one. PostgreSQL, MySQL, and MS SQL Server provide a way to reindex without dropping and recreating them manually.For example, in PostgreSQL:REINDEX INDEX index_name;Indexes and PerformanceWhile indexes can improve read speed, they also slow down write operations because each write must also update the index. That’s why it’s essential to find a balance between the number of indexes and database performance. Too many indexes can negatively impact performance.Therefore, you should only create indexes when they are likely to be needed and when they will have a significant impact on improving query performance. You can use the SQL Server Profiler, MySQL’s slow query log, or other database-specific tools to identify the queries that are running slow, and then create indexes to optimize those queries. Regularly monitor your database performance to make sure that the indexes are still needed and that they are providing the expected improvements.",
                "resources": [],
                "order": 11,
                "options": [
                    {
                        "name": "Managing Indexes in SQL",
                        "recommendation-type": "opinion",
                        "description": "Indexes can significantly enhance data retrieval speed in SQL databases, but they also come with storage costs and potential performance trade-offs during data modification operations. This text discusses managing indexes, including creating, removing, listing, and modifying indexes. It also addresses the impact of indexes on database performance and offers tips on when and how to strategically add and clean up indexes. Creating IndexesTo create an index, you use the CREATE INDEX command followed by the index name, the table name, and the columns you want to use in the index.CREATE INDEX index_nameON table_name(column_name);Removing IndexesIf an index is no longer required or if it’s causing performance issues due to too much storage consumption, it can be dropped using the DROP INDEX command.DROP INDEX index_name;Listing IndexesYou can get a list of all the indexes on a table using the SHOW INDEXES command.SHOW INDEXES IN table_name;Remember that most SQL databases automatically create indexes for primary keys, and they do not need to be managed manually.Modifying IndexesModifying an existing index often means dropping the old index and creating a new one. PostgreSQL, MySQL, and MS SQL Server provide a way to reindex without dropping and recreating them manually.For example, in PostgreSQL:REINDEX INDEX index_name;Indexes and PerformanceWhile indexes can improve read speed, they also slow down write operations because each write must also update the index. That’s why it’s essential to find a balance between the number of indexes and database performance. Too many indexes can negatively impact performance.Therefore, you should only create indexes when they are likely to be needed and when they will have a significant impact on improving query performance. You can use the SQL Server Profiler, MySQL’s slow query log, or other database-specific tools to identify the queries that are running slow, and then create indexes to optimize those queries. Regularly monitor your database performance to make sure that the indexes are still needed and that they are providing the expected improvements.",
                        "resources": []
                    },
                    {
                        "name": "Query Optimization in SQL",
                        "recommendation-type": "opinion",
                        "description": "Query optimization is a function of SQL that involves tuning and optimizing a SQL statement so that the system executes it in the fastest and most efficient way possible. It includes optimizing the costs of computation, communication, and disk I/O.The primary approaches of query optimization involve the following:Rewriting QueriesThis means changing the original SQL query to an equivalent one which requires fewer system resources. It’s usually done automatically by the database system. SELECT * FROM Customers WHERE state = 'New York' AND city = 'New York';The above query can be rewritten using a subquery for better optimization:SELECT * FROM Customers WHERE state = 'New York' AND city IN (SELECT city FROM Customers WHERE city = 'New York');Choosing the right indexIndexes are used to find rows with specific column values quickly. Without an index, SQL has to begin with the first row and then read through the entire table to find the appropriate rows. The larger the table, the more costly the operation. Choosing a right and efficient index greatly influence on query performance.For example,CREATE INDEX index_nameON table_name (column1, column2, ...);Fine-tuning Database DesignImproper database schema designs could result in poor query performances. While not strictly a part of query optimization, tuning the database design can speed up the query execution time drastically.Changes such as the separation of specific data to different tables (Normalization), combining redundant data (Denormalization), or changing the way how tables are linked (Optimized Join Operations), can be implemented to optimize the schema.Use of SQL Clauses wiselyThe usage of certain SQL clauses can help in query optimization like LIMIT, BETWEEN etc.Example,SELECT column1, column2FROM table_nameWHERE conditionLIMIT 10;System ConfigurationMany database systems allow you to configure system parameters that control its behavior during query execution. For instance, in MySQL, you can set parameters like sort_buffer_size or join_buffer_size to tweak how MySQL would use memory during sorting and joining operations.In PostgreSQL, you can set work_mem to control how much memory is utilized during operations such as sorting and hashing.Always remember the goal of query optimization is to lessen the system resources usage in terms of memory, CPU time, and thus improve the query perform",
                        "resources": [
                            {
                                "name": "SQL Query Optimization Guide",
                                "link": "https://example.com/sql-query-optimization-guide"
                            }
                        ]
                    }
                ]
            },
            "Transactions": {
                "description": "Transactions in SQL are crucial for maintaining data integrity and handling database errors. They are executed as units of work, ensuring that a series of operations occur in a logical order. This text covers the essential SQL transaction commands: BEGIN TRANSACTION to start a new transaction, COMMIT to save changes to the database, and ROLLBACK to undo uncommitted changes. It also provides a transaction example to illustrate their usage and the importance of successful execution for a transaction to be considered successful.",
                "resources": [
                    {
                        "name": "SQL Transactions Guide",
                        "link": "https://example.com/sql-transactions-guide"
                    }
                ],
                "order": 12,
                "options": [
                    {
                        "name": "ACID Properties in Relational Databases",
                        "recommendation-type": "opinion",
                        "description": "ACID, which stands for Atomicity, Consistency, Isolation, and Durability, represents the four essential properties of relational database systems. These properties ensure reliable and consistent transaction processing. This JSON provides a brief introduction to ACID properties and offers links to external resources for in-depth exploration.",
                        "resources": [
                            {
                                "name": "What is ACID Compliant Database?",
                                "link": "https://retool.com/blog/whats-an-acid-compliant-database/"
                            },
                            {
                                "name": "What is ACID Compliance?: Atomicity, Consistency, Isolation",
                                "link": "https://fauna.com/blog/what-is-acid-compliance-atomicity-consistency-isolation"
                            },
                            {
                                "name": "ACID Explained: Atomic, Consistent, Isolated & Durable",
                                "link": "https://www.youtube.com/watch?v=yaQ5YMWkxq4"
                            }
                        ]
                    },
                    {
                        "name": "SAVEPOINT in Relational Databases",
                        "recommendation-type": "opinion",
                        "description": "A SAVEPOINT is a feature in relational database management systems that allows the creation of a point within a transaction to which you can rollback in case of failure. It's a valuable tool for maintaining data integrity and handling errors within transactions. This JSON provides an overview of SAVEPOINT with its syntax and usage. Additionally, it offers subscription options for further SQL-related topics.",
                        "resources": []
                    },
                    {
                        "name": "Understanding the ROLLBACK Command in SQL",
                        "recommendation-type": "opinion",
                        "description": "The ROLLBACK command is a crucial element in transaction control language (TCL) that allows the reversal of undesirable changes made during a transaction. This JSON provides insights into the usage of ROLLBACK in SQL, with practical examples and scenarios. Learn how to undo operations, maintain data integrity, and leverage SAVEPOINTs for more granular control within your SQL transactions.",
                        "resources": []
                    },
                    {
                        "name": "Understanding the SQL COMMIT Command",
                        "recommendation-type": "opinion",
                        "description": "The SQL COMMIT command is a crucial element of transaction control language (TCL) that finalizes and permanently saves the changes made within a transaction. Learn how to properly utilize COMMIT to make your database modifications permanent. This JSON provides insights into the syntax of COMMIT, its use cases, and the essential distinction between COMMIT and ROLLBACK in SQL transactions.",
                        "resources": []
                    },
                    {
                        "name": "Understanding the SQL BEGIN Command",
                        "recommendation-type": "opinion",
                        "description": "The SQL BEGIN command marks the initiation of a transaction, a fundamental concept in managing database integrity. This JSON provides insights into the syntax and usage of BEGIN, illustrating its role in ensuring data consistency and explaining its interaction with subsequent SQL statements. Learn how to effectively utilize BEGIN to control transactions in SQL databases.",
                        "resources": []
                    },
                    {
                        "name": "Understanding SQL Transaction Isolation Levels",
                        "recommendation-type": "opinion",
                        "description": "Learn about the four transaction isolation levels in SQL and how they impact data consistency and performance. This JSON provides a concise overview of READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, and SERIALIZABLE isolation levels, along with the SQL statements to set each level. Understand the trade-offs between consistency and performance when choosing an isolation level for your database transactions.",
                        "resources": []
                    }
                ]
            },
            "Data Integrity and Security": {
                "name": "Understanding Data Integrity and Security in SQL",
                "recommendation-type": "opinion",
                "description": "Explore the concepts of data integrity and security in SQL databases. Learn about various forms of data integrity, including entity integrity, domain integrity, referential integrity, and user-defined integrity. Understand how these concepts help maintain data accuracy and consistency, ensuring the reliability of your database. Discover best practices for enhancing data security and preventing unauthorized access.",
                "resources": [],
                "order": 13,
                "options": [
                    {
                        "name": "Understanding Data Integrity Constraints in SQL",
                        "recommendation-type": "opinion",
                        "description": "Explore the importance of data integrity constraints in SQL databases. Learn about different types of constraints, including NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, and CHECK. Understand how these constraints enforce rules to maintain the accuracy and reliability of your data. Discover best practices for implementing and managing data integrity in your SQL tables.",
                        "resources": []
                    },
                    {
                        "name": "Understanding SQL GRANT and REVOKE Commands",
                        "recommendation-type": "opinion",
                        "description": "Explore the role of GRANT and REVOKE commands in SQL's Data Control Language (DCL). Learn how these commands are used to assign and revoke user privileges and permissions on database objects. Discover the significance of permission management in maintaining data integrity and security in SQL databases.",
                        "resources": []
                    },
                    {
                        "name": "Best Practices for Securing Your SQL Databases",
                        "recommendation-type": "opinion",
                        "description": "Discover essential best practices to enhance the security of your SQL databases. From implementing the least privilege principle to safeguarding against SQL injection, these practices are vital in protecting sensitive data and maintaining data integrity.",
                        "resources": []
                    }
                ]
            },
            "Stored Procedures and Functions": {
                "description": "Explore the concept of SQL stored procedures and functions. This JSON provides an overview of how stored procedures can be created and called in SQL. It also explains the two types of SQL functions, scalar and table-valued functions, and demonstrates their usage. Learn how to improve code reusability and modularity with stored procedures and functions.",
                "resources": [],
                "order": 14,
                "options": []
            },
            "Performance Optimization": {
                "description": "Learn how to enhance the performance of your SQL queries and databases. From creating efficient indexes to using JOIN clauses and avoiding common performance pitfalls, these practices can significantly boost database performance.1. IndexesCreating indexes is one of the prominent ways to optimize SQL performance. They accelerate lookup and retrieval of data from a database.CREATE INDEX index_nameON table_name (column1, column2, ...);Remember, though indexes speed up data retrieval, they can slow down data modification such as INSERT, UPDATE, and DELETE.2. Avoid SELECT *Get only the required columns instead of fetching all columns using SELECT *. It reduces the amount of data that needs to be read from the disk.SELECT required_column FROM table_name;3. Use Join Instead of Multiple QueriesUsing join clauses can combine rows from two or more tables in a single query based on a related column between them. This reduces the number of queries hitting the database, improving performance.SELECT Orders.OrderID, Customers.CustomerNameFROM OrdersINNER JOIN CustomersON Orders.CustomerID=Customers.CustomerID;4. Use LIMITIf only a certain number of rows are necessary, use the LIMIT keyword to restrict the number of rows returned by the query.SELECT column FROM table LIMIT 10;5. Avoid using LIKE Operator with Wildcards at the StartUsing wildcard at the start of a query (LIKE '%search_term') can lead to full table scans.SELECT column FROM table WHERE column LIKE 'search_term%';6. Optimize Database SchemaDatabase schema involves how data is organized and should be optimized for better performance.7. Use EXPLAINMany databases have ‘explain plan’ functionality that shows the plan of the database engine to execute the query.EXPLAIN SELECT * FROM table_name WHERE column = 'value';This can give insight into performance bottlenecks like full table scans, missing indices, etc.8. DenormalizationIn some cases, it might be beneficial to denormalize the database to a certain extent to reduce complex joins and queries. Keep in mind that this is usually the last resort and may not always yield the desired results.Remember, each query and database is unique, so what might work in one scenario might not work in another. It is always crucial to test the queries in a controlled and isolated environment before pushing them into production.",
                "resources": [],
                "order": 15,
                "options": [
                    {
                        "Query Optimization Techniques": {
                            "description": "Learn how to improve the performance of your SQL queries with these optimization techniques. From creating effective indexes to using JOIN statements and avoiding common performance pitfalls, these practices can significantly enhance query efficiency.",
                            "resources": [],
                            "options": [
                                {
                                    "name": "Using Indexes",
                                    "recommendation-type": "opinion",
                                    "description": "Learn how to use SQL indexes to improve query performance. Discover the types of indexes, including single-column, unique, composite, and implicit indexes, and understand how they work to speed up data retrieval. Be cautious with index usage to balance performance gains and storage considerations.",
                                    "resources": []
                                },
                                {
                                    "name": "Optimizing Joins",
                                    "recommendation-type": "opinion",
                                    "description": "Discover techniques to optimize SQL joins and improve query execution speed. Learn how to minimize the number of tables in joins, choose the right order for table joins, use indexes effectively, consider subqueries for specific scenarios, and adopt explicit join syntax for better understanding. Optimizing joins requires a deep understanding of database design and thorough testing for different scenarios.",
                                    "resources": []
                                },
                                {
                                    "name": "Reducing Subqueries",
                                    "recommendation-type": "opinion",
                                    "description": "Discover techniques to reduce subqueries in SQL queries for better performance. Learn how to use JOIN clauses to replace subqueries in many scenarios and leverage the 'EXISTS' operator to streamline query execution. While minimizing subqueries is crucial for performance, there may be cases where replacing them is not feasible.",
                                    "resources": []
                                },
                                {
                                    "name": "Selective Projection",
                                    "recommendation-type": "opinion",
                                    "description": "Learn about selective projection in SQL, a fundamental concept for optimizing queries. Discover how to retrieve specific columns from a table, rather than fetching all columns, to improve query efficiency. Using selective projection reduces the amount of data scanned and fetched, resulting in better performance. Examples and best practices included.In SQL, a projection refers to the operation in which we choose certain columns (instead of all columns) from the table for our query results. If a table has numerous columns, and we only need data from a few of them, it’s more efficient to only select those specific columns in the SQL query. This reduces the amount of data that needs to be scanned and fetched from the database, thereby improving performance.  Let’s take an example where you have a “students” table with the following columns: Id, Name, Age, Gender, Department, and City. If you only need Name and Department information, you should use a selective projection to specify only these columns in your SELECT statement:SELECT Name, Department FROM studentsThis query returns just the Name and Department columns, rather than all fields in the students table.In contrast, if you used a SELECT * statement:SELECT * FROM studentsThis would return all columns from the “students” table which can be inefficient if you don’t need all that data.Selective projection can greatly optimize your SQL queries by minimizing the amount of data handled. It’s especially beneficial when tables have large amounts of data and many columns, but only a subset of information is required.",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "name": "Query Analysis Techniques in SQL for Performance Optimization",
                        "recommendation-type": "opinion",
                        "description": "Explore the importance of query analysis in optimizing SQL performance. Learn how to use the 'EXPLAIN PLAN' statement to examine the execution plan of a query, identify bottlenecks, and estimate resource costs. Query analysis is a crucial step in enhancing SQL query performance.EXPLAIN PLAN FOR SELECT * FROM table_name;Index UsageUsing appropriate indexes is crucial for query performance. Unnecessary full table scans can be avoided if the correct indexes are present. Even though SQL will automatically determine the appropriate index to use, it can be helpful to manually specify which index to use for complex queries.CREATE INDEX idx_column ON table_name(column_name);Join OptimizationThe order in which tables are joined can have a large impact on query performance. In general, you should join tables in a way that results in the smallest result set as early as possible.Look out for “Nested Loops” in your explain plan. These can be a cause of slow performance if a large number of rows are being processed.SELECT *FROM table1INNER JOIN table2 ON table1.id = table2.id;Regular Performance TestsRegular query performance testing can catch slow queries before they become a problem. Utilizing tools that can monitor and report query performance can help you keep an eye on your database’s performance.Also, continual analysis of the query performance should be done as your data grows. A query that performs well with a small dataset may not do so when the dataset grows.",
                        "resources": []
                    }
                ]
            },
            "Advanced SQL Concepts": {
                "description": "Discover the power of advanced SQL concepts, including Stored Procedures, Triggers, Views, JOINs, Subqueries, and Set Operators. These advanced SQL operations offer sophisticated ways to query and manipulate your database. Learn how to leverage these techniques for enhanced data management and analysis.",
                "resources": [],
                "order": 16,
                "options": [
                    {
                        "name": "Recursive Queries",
                        "recommendation-type": "opinion",
                        "description": "Recursive queries are advanced SQL queries used for data analysis, especially when working with hierarchical or tree-structured data. These queries are implemented using Common Table Expressions (CTEs). CTEs have the same structure as a standard SELECT statement but are prefixed with WITH, followed by the CTE name and an optional list of columns.CTEs can be recursive and non-recursive. The non-recursive CTE is a query that is executed once and then goes out of scope.A recursive CTE is a CTE that references itself. Recursive CTEs have a minimum of two queries, an anchor member (runs only once), and a recursive member (runs repeatedly). Include a UNION ALL statement between these queries.Here’s a sample of a recursive CTE:WITH RECURSIVE ancestors AS (SELECT employee_id, manager_id, full_nameFROM employeesHERE manager_id IS NULLUNION ALLSELECT e.employee_id, e.manager_id, e.full_nameFROM employees eINNER JOIN ancestors a ON a.employee_id = e.manager_id)SELECT * FROM ancestors;In this code snippet, the first query is the anchor member that fetches the employees with no manager. The second part is the recursive member, continuously fetching managers until none are left.Syntax of Recursive CTEHere’s the general structure of a recursive CTE:WITH RECURSIVE cte_name (column_list) AS (-- Anchor memberSELECT column_listFROM table_nameWHERE conditionUNION ALL-- Recursive memberSELECT column_listFROM table_nameINNER JOIN cte_name ON condition)SELECT * FROM cte_name;Note: some database systems such as MySQL, PostgreSQL, and SQLite use WITH RECURSIVE for recursive CTEs. Others like SQL Server, Oracle, and DB2 use just WITH.Remember to be careful when setting the conditions for your recursive query to avoid infinite loops.",
                        "resources": []
                    },
                    {
                        "name": "Pivot and Unpivot Operations",
                        "recommendation-type": "opinion",
                        "description": "The PIVOT operator is used in SQL to rotate the table data from rows to columns, essentially transforming the data into a matrix format. This operator allows you to create a crosstab view of the data, with selected columns as rows and others as columns, providing a summary view.Here is a general example of the syntax:SELECT ...FROM ...PIVOT (aggregate_function(column_to_aggregate)FOR column_to_pivot IN (list_of_values))Example: Let’s assume we have a ‘Sales’ table with ‘Year’, ‘Quarter’ and ‘Amount’ columns. If we want to turn ‘Quarter’ values into columns, we might use:SELECT * FROM (SELECT Year, Quarter, AmountFROM Sales) PIVOT (SUM(Amount)FOR Quarter IN ('Q1' 'Q2' 'Q3' 'Q4'))This would give us each year as a row and each quarter as a column, with the total sales for each quarter in the cells.UNPIVOTThe UNPIVOT operator performs the reverse operation to PIVOT, rotating columns into rows. If the columns you’re converting have a certain relationship, this can be factored into a single column instead.Here is a general example of the syntax:SELECT ...FROM ...UNPIVOT (column_for_values FOR column_for_names IN (list_of_columns))Example: Conversely, if we want to transform the quarter columns back into rows from the previous ‘Sales’ pivot table, we would use:SELECT * FROM (SELECT Year, Q1, Q2, Q3, Q4FROM Sales) UNPIVOT (AmountFOR Quarter IN (Q1, Q2, Q3, Q4))This would result in each combination of year and quarter as a row, with the amount sold in that quarter as the ‘Amount’ column. Keep in mind, the UNPIVOTed data isn’t equivalent to the original data as the original data might have had multiple rows for each year/quarter ",
                        "resources": []
                    },
                    {
                        "Window Functions": {
                            "description": "SQL Window functions enable you perform calculations on a set of rows related to the current row. This set of rows is known as a ‘window’, hence ‘Window FunctionThese are termed so because they perform a calculation across a set of rows which are related to the current row - somewhat like a sliding window.There are four types of window functions in SQL:Aggregate functions: These functions compute a single output value for a group of input values (like averages, sums).SELECT department, salary,AVG(salary) OVER (PARTITION BY department) as avg_departmental_salaryFROM employee;Ranking functions: These functions allocate a unique rank to each row within each window partition.SELECT department, salary,RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rankFROM employee;Value functions: These functions provide information about the window partition or the row’s position within it, for example - FIRST_VALUE, LAST_VALUE, NTH_VALUE.SELECT department, salary,FIRST_VALUE(salary) OVER (PARTITION BY department ORDER BY salary DESC) as highest_salaryFROM employee;Offset functions: The offset functions provide a way of accessing data from another row in the same result set without joining the table to itself. They can answer questions concerning the value on the row before or after the current row, for example - LEAD, LAG.SELECT department, salary,LAG(salary) OVER (PARTITION BY department ORDER BY salary) as previous_salary,LEAD(salary) OVER (PARTITION BY department ORDER BY salary) as next_salaryFROM employee;In using window functions, the OVER clause defines the windows or group of rows for function to consider, PARTITION BY breaks up the window by a specific column(s), and ORDER BY orders rows within the window.It’s important to note that SQL window functions do not cause rows to become grouped into a single output row like aggregate methods do. Therefore, they do not reduce the number of rows returned by the query, each row maintains its individual iden",
                            "options": [
                                {
                                    "name": "Row_number",
                                    "recommendation-type": "opinion",
                                    "description": " Row_numberROW_NUMBER() is a SQL window function that assigns a unique number to each row in the result setSyntaxROW_NUMBER() OVER ([ORDER BY column_name])Features:Numbers are assigned based on the ORDER BY clause of ROW_NUMBER().In case of identical values in the ORDER BY clause, the function assigns numbers arbitrarily.In other words, the sequence of numbers generated by ROW_NUMBER() is not guaranteed to be the same for the same set of data.Examples:Example 1: Basic usage of ROW_NUMBER() on a single columSELECT name, ROW_NUMBER() OVER (ORDER BY name) row_numberFROM employees;In this example, ROW_NUMBER() is used to assign a unique number to each row in the employees table, ordered by the employee names alphabeticallyExample 2: Using ROW_NUMBER() to rank rows in each partitioSELECT department_id, first_name, salary, ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) row_numberFROM employees;In this example, ROW_NUMBER() is used to rank employee salaries within each department (i.e., partitioned by department_id). In each departm",
                                    "resources": []
                                },
                                {
                                    "name": "rank",
                                    "recommendation-type": "opinion",
                                    "description": "rankRANK() is a window function in SQL that assigns a unique rank to each distinct row within a partition of a result set. The rank of the first row within each partition is one. The RANK() function adds the number of tied rows to the tied rank to calculate the next rank. So the ranks may not be consecutive numbers.Parameters of RANK FunctionThere are no arguments for the RANK() function. However, since it’s a window function, the function operates on a set of rows (window) defined by the OVER clause, which is mandatory.SyntaxThe syntax of RANK function is:RANK () OVER ([PARTITION BY column_1, column_2,…]ORDER BY column_3,column_4,… )PARTITION BY: This clause divides the rows into multiple groups or partitions upon which the RANK() function is applied.ORDER BY: This clause sorts the rows in each partition.If PARTITION BY is not specified, the function treats all rows in the result set as a single partition.ExamplesHere’s an example query using the RANK() function:SELECTproduct_name, brand, RANK () OVER (PARTITION BY brandORDER BY product_name ASC) Product_rankFROMproducts;In this example, it generates a list of products, grouped by brand, and ranked by product_name within each brand. The product_name with the smallest value (alphabetically first when sorting ASC) gets a rank of 1 within its partition.Important NotesRANK() function may return duplicate rankings if the column on which the function is applied contains duplicate values.The RANK() function will leave a gap and create a non-consecutive ranking if there are equal rankings (ties).RANK() function offers a very efficient way to solve top-N problems.You might also be interested in looking at other similar ranking functions in SQL like DENSE_RANK(), ROW_NUMBER(), e",
                                    "resources": []
                                },
                                {
                                    "name": "dense_rank",
                                    "recommendation-type": "opinion",
                                    "description": "Explore the concept of DENSE_RANK(), a versatile SQL window function that provides row rankings without gaps. Learn how DENSE_RANK() differs from RANK() and when to use it. Dive into its syntax, with a practical example that demonstrates how to rank employees by their salaries. Gain insights into the behavior and benefits of this function.",
                                    "resources": []
                                },
                                {
                                    "name": "lead",
                                    "recommendation-type": "opinion",
                                    "description": "Dive into the world of SQL's LEAD function, a versatile window function that lets you access data from subsequent rows for calculations. Learn how to use LEAD with its parameters: value_expression, offset, and default_value. Explore its syntax and see a practical example where you compare monthly sales with the sales of the next month. Understand how LEAD handles cases with no subsequent rows in the window frame.",
                                    "resources": []
                                },
                                {
                                    "name": "lag",
                                    "recommendation-type": "opinion",
                                    "description": "Discover the power of SQL's LAG function, a valuable window function that allows you to retrieve data from preceding rows without the need for self-joins. Learn how to use LAG with its parameters: expression, offset, and default. Explore its syntax and see a practical example where you compare yearly sales with the sales of the previous year. Understand how LAG handles cases where there is no previous row to fetch data from.",
                                    "resources": []
                                }
                            ]
                        }
                    },
                    {
                        "name": "CTEs (Common Table Expressions)",
                        "recommendation-type": "opinion",
                        "description": "Explore the power of CTEs (Common Table Expressions) in SQL. Learn how to define temporary result sets within a single query to simplify subqueries and enhance query readability. Discover the basic syntax for creating and using CTEs in your SQL statements. Dive into practical examples, including using CTEs to join and process data efficiently. Delve into the world of recursive CTEs for hierarchical data traversal. Gain mastery over this essential SQL feature.",
                        "resources": []
                    },
                    {
                        "name": "Dynamic SQL",
                        "recommendation-type": "opinion",
                        "description": "Unlock the power of dynamic SQL, a programming method that allows you to build SQL statements on the fly. Explore how dynamic SQL can make your applications more adaptable by creating SQL statements at runtime based on changing conditions and user inputs. Learn about two ways to execute dynamic SQL: the EXECUTE IMMEDIATE statement and the OPEN-FOR, FETCH, CLOSE statements. Dive into code examples that demonstrate the flexibility of dynamic SQL in real-world scenarios. Discover best practices for using dynamic SQL securely, including how to mitigate potential risks like SQL Injection.",
                        "resources": []
                    }
                ]
            }
        }
    }
}