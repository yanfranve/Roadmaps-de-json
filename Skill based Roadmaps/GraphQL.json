{
    "Skill": {
        "GraphQL": {
            "description": "Step by step guide to learn GraphQL in 2023 ",
            "Introduction to GraphQL": {
                "description": "GraphQL is a query language and runtime for APIs. It is used to build and consume web service APIs.\nGraphQL allows clients to make a single API call to request exactly the data they need, in a predictable format. This allows for more efficient and flexible data retrieval, compared to traditional REST APIs where the client has to make multiple API calls to different endpoints, and may receive more data than it needs.\nWith GraphQL, the client defines the structure of the data it needs, by sending a query to the server. The server then returns the requested data in the same structure, as defined by the query. The client can also make mutations to update or create data on the server.",
                "resources": [
                    {
                        "name": "Introduction to GraphQL",
                        "link": "https://graphql.org/learn/"
                    },
                    {
                        "name": "Getting started with GraphQL",
                        "link": "https://graphql.org/"
                    }
                ],
                "order": 1,
                "options": [
                    {
                        "name": "GraphQL on the Frontend",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, the frontend refers to the client-side of the application, typically the web or mobile app that the end-user interacts with.\n\nWhen using GraphQL on the frontend, developers can use a GraphQL client library, such as Apollo Client or Relay, to interact with the GraphQL server. These libraries provide a way to easily send GraphQL queries and mutations to the server and handle the response.\n\nBy using GraphQL on the frontend, developers can benefit from the flexibility and efficiency of GraphQL when querying data. Instead of having to make multiple REST API calls or hardcode data into the frontend, the client can specify exactly the data it needs in a single request, and the server will return it in a predictable format.",
                        "resources": [
                            {
                                "name": "Get started with GraphQL on the frontend",
                                "link": "https://www.howtographql.com/react-apollo/0-introduction/"
                            }
                        ]
                    },
                    {
                        "name": "GraphQL on the Backend",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, the backend refers to the server-side of the application, where the data is stored and processed.\n\nWhen using GraphQL on the backend, developers can create a GraphQL server that handles the incoming GraphQL queries and mutations from the frontend. This can be implemented using a GraphQL library or framework, such as Apollo Server, Express-GraphQL, or GraphQL-Java.\n\nThe GraphQL server is responsible for handling the incoming queries and mutations, validating them against a schema, and executing them by fetching data from the database or other data sources. The server then returns the requested data to the client in a predictable format, as defined by the schema.",
                        "resources": [
                            {
                                "name": "How to use GraphQL in Backend?",
                                "link": "https://www.howtographql.com/"
                            }
                        ]
                    },
                    {
                        "name": "What is GraphQL",
                        "recommendation-type": "opinion",
                        "description": "GraphQL is a query language for your API, and a server-side runtime for executing queries using a type system you define for your data. GraphQL isn’t tied to any specific database or storage engine and is instead backed by your existing code and data.\n\nA GraphQL service is created by defining types and fields on those types, then providing functions for each field on each type.",
                        "resources": [
                            {
                                "name": "Introduction to GraphQL",
                                "link": "https://graphql.org/learn/"
                            },
                            {
                                "name": "Tutorial - What is GraphQL?",
                                "link": "https://www.howtographql.com/basics/0-introduction/"
                            }
                        ]
                    },
                    {
                        "name": "Problems GraphQL Solves",
                        "recommendation-type": "opinion",
                        "description": "GraphQL solves several problems commonly faced when building APIs, including:\n\n- Over-fetching: With REST APIs, the client often receives more data than it needs, resulting in wasted bandwidth and slow performance. GraphQL allows the client to specify exactly the data it needs, reducing over-fetching.\n- Under-fetching: With REST, the client often has to make multiple requests to different endpoints to gather all the data it needs, resulting in additional latency and complexity. GraphQL allows the client to request all the necessary data in a single request.\n- Inefficient versioning: With REST, creating a new endpoint for each version of an API can quickly become cumbersome and hard to maintain. GraphQL allows for seamless versioning by adding new fields and types, rather than creating new endpoints.\n- Lack of flexibility: REST APIs are typically fixed, meaning that the client has to work with the data structure provided by the API. GraphQL allows the client to request exactly the data it needs and receive it in a predictable format, increasing flexibility.",
                        "resources": []
                    },
                    {
                        "name": "Thinking in Graphs",
                        "recommendation-type": "opinion",
                        "description": "“Thinking in Graphs” is a mindset or approach when working with GraphQL. It refers to the way that data is organized and queried in GraphQL, which is based on the concept of a graph.\n\nIn GraphQL, data is represented as a graph, where nodes represent objects and edges represent relationships between them. This allows for a more flexible and intuitive way of querying data, as the client can specify exactly the data it needs by following the relationships between nodes in the graph.",
                        "resources": [
                            {
                                "name": "Learn More About Thinking in Graphs",
                                "link": "https://graphql.org/learn/thinking-in-graphs/"
                            }
                        ]
                    }
                ]
            },
            "GraphQL Queries": {
                "description": "GraphQL is a query language for APIs. It provides a simple and flexible syntax for making requests to a server to retrieve specific data. In GraphQL, a query is a request made to the server to fetch data. The query specifies the fields of the data that should be returned, and the server responds with the requested data.\n\nA GraphQL query is structured as a single object, with a “query” or “mutation” field at the top level. The “query” field is used to retrieve data, while the “mutation” field is used to make changes to the data. The query is written in a specific format and is executed by the server to retrieve the requested data.",
                "resources": [
                    {
                        "name": "Learn More About GraphQL Queries",
                        "link": "https://graphql.org/learn/queries/"
                    }
                ],
                "order": 2,
                "options": [
                    {
                        "Variables": {
                            "description": "Variables in GraphQL are a way to pass dynamic values to a query or a mutation. They allow the client to make a query more dynamic and flexible by passing in different values for the same argument. They are defined in the query or mutation using the $ symbol followed by the variable name and a type, and their values must be passed in a separate JSON object. They also are type-safe, this means that variables must be passed values that are of the same type as defined in the query.",
                            "resources": [
                                {
                                    "name": "GraphQL Variables Documentation",
                                    "link": "https://graphql.org/learn/queries/#variables"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Definitions",
                                    "recommendation-type": "opinion",
                                    "description": "Variables in GraphQL are a way to pass dynamic values to a query or a mutation. They allow the client to make a query more dynamic and flexible by passing in different values for the same argument. They are defined in the query or mutation using the $ symbol followed by the variable name and a type, and their values must be passed in a separate JSON object. They also are type-safe, this means that variables must be passed values that are of the same type as defined in the query.",
                                    "resources": [
                                        {
                                            "name": "GraphQL Variables Documentation",
                                            "link": "https://graphql.org/learn/queries/#variables"
                                        }
                                    ]
                                },
                                {
                                    "name": "Defaults",
                                    "recommendation-type": "opinion",
                                    "description": "Variables in GraphQL are a way to pass dynamic values to a query or a mutation. They allow the client to make a query more dynamic and flexible by passing in different values for the same argument. They are defined in the query or mutation using the $ symbol followed by the variable name and a type, and their values must be passed in a separate JSON object. They also are type-safe, this means that variables must be passed values that are of the same type as defined in the query.",
                                    "resources": [
                                        {
                                            "name": "GraphQL Variables Documentation",
                                            "link": "https://graphql.org/learn/queries/#variables"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "Fragments": {
                            "description": "In GraphQL, a fragment is a reusable piece of a GraphQL query that can be used to retrieve specific fields from one or more types of data. A fragment is defined using the 'fragment' keyword, followed by the name of the fragment and the type of data it is querying. The fields to be retrieved are then specified within curly braces.",
                            "resources": [
                                {
                                    "name": "GraphQL Fragments Documentation",
                                    "link": "https://graphql.org/learn/queries/#fragments"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Variables in Fragments",
                                    "recommendation-type": "opinion",
                                    "description": "In GraphQL, a fragment is a reusable piece of a GraphQL query that can be used to retrieve specific fields from one or more types of data. A fragment is defined using the 'fragment' keyword, followed by the name of the fragment and the type of data it is querying. The fields to be retrieved are then specified within curly braces.",
                                    "resources": [
                                        {
                                            "name": "GraphQL Fragments Documentation",
                                            "link": "https://graphql.org/learn/queries/#fragments"
                                        }
                                    ]
                                },
                                {
                                    "name": "Inline Fragments /Meta Fields",
                                    "recommendation-type": "opinion",
                                    "description": "In GraphQL, a fragment is a reusable piece of a GraphQL query that can be used to retrieve specific fields from one or more types of data. A fragment is defined using the 'fragment' keyword, followed by the name of the fragment and the type of data it is querying. The fields to be retrieved are then specified within curly braces.",
                                    "resources": [
                                        {
                                            "name": "GraphQL Fragments Documentation",
                                            "link": "https://graphql.org/learn/queries/#fragments"
                                        }
                                    ]
                                }
                                
                                
                            ]
                        }
                    },
                    {
                        "name": "What are Queries",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, a query is a request made by the client to the server to retrieve data. Queries are used to fetch data from the server and are structured as a hierarchical tree of fields, which correspond to the properties of the data being requested.",
                        "resources": [
                            {
                                "name": "Introduction of GraphQL - Query",
                                "link": "https://graphql.org/learn/queries/"
                            }
                        ]
                    },
                    
                    {
                        "name": "Fields",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, fields are the individual pieces of data that can be queried or modified. They represent the properties of the data being requested or modified, and are the building blocks of queries and mutations. Fields are defined in the GraphQL schema, which is a blueprint of the data that can be queried and modified. The schema defines the types of data that can be queried, and the fields that are available for each type.",
                        "resources": [
                            {
                                "name": "GraphQL: Types and Fields",
                                "link": "https://graphql.org/learn/queries/#fields"
                            }
                        ]
                    },
                    {
                        "name": "Aliases",
                        "recommendation-type": "opinion",
                        "description": "Aliases in GraphQL are a way to rename fields when they are requested in a query. They are useful in situations where a field is requested multiple times, but with different arguments, or when the field has a name that is not suitable for the client’s usage. They make it easy to distinguish and work with fields in the response and make the query more readable.",
                        "resources": [
                            {
                                "name": "What are GraphQL Aliases?",
                                "link": "https://graphql.org/learn/queries/#aliases"
                            }
                        ]
                    },
                    {
                        "name": "Arguments",
                        "recommendation-type": "opinion",
                        "description": "Arguments in GraphQL are pieces of information that are passed to a field or a directive to specify additional details about how the field should be executed. They can be used to filter, sort, or paginate data, or to specify additional options when creating, updating, or deleting data. They can be passed as key-value pairs, defined as variables, and can be optional or required.",
                        "resources": [
                            {
                                "name": "GraphQL - Arguments",
                                "link": "https://graphql.org/learn/queries/#arguments"
                            }
                        ]
                    },
                    {
                        "name": "Directives",
                        "recommendation-type": "opinion",
                        "description": "Directives in GraphQL are a way to modify the execution of a query or a field. They are used to add additional behavior or validation to a query or a field, and can be applied to fields, operations (queries and mutations) and fragments. Directives can take one or more arguments to configure their behavior, and can be defined by the developer or used one of the built-in directives provided by GraphQL.",
                        "resources": [
                            {
                                "name": "Directives in GraphQL",
                                "link": "https://graphql.org/learn/queries/#directives"
                            }
                        ]
                    }
                    
                    
                    
                    
                ]
            },
            "Mutations": {
                "description": "In GraphQL, a mutation is a type of query used to make changes to the data on the server, such as creating, updating, or deleting data. A mutation is structured similarly to a query, but with a “mutation” field at the top level instead of a “query” field.\n\nThe mutation includes fields that specify the data to be changed, the operation to be performed (create, update, or delete), and can also include arguments to specify the specific data to be affected.",
                "resources": [
                    {
                        "name": "Learn More About Mutations in GraphQL",
                        "link": "https://graphql.org/learn/queries/#mutations"
                    }
                ],
                "order": 3,
                "options": [
                    {
                        "name": "What are Mutations",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, a mutation is a type of query used to make changes to data on the server. It is used to create, update, or delete data, and is structured similarly to a query, but with a “mutation” field at the top level instead of a “query” field. A mutation typically includes fields that specify the data to be changed and the operation to be performed (e.g. “create”, “update”, or “delete”). It can also include arguments to specify the specific data to be affected.",
                        "resources": [
                            {
                                "name": "Get started with Mutations",
                                "link": "https://graphql.org/learn/queries/#mutations"
                            }
                        ]
                    },
                    {
                        "name": "Multiple Mutation Fields",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, it is possible to perform multiple mutations in a single query by including multiple “mutation” fields in the query. This is called “batching” or “chaining” mutations.",
                        "resources": [
                            {
                                "name": "Guide to Multiple fields in mutations",
                                "link": "https://graphql.org/learn/queries/#multiple-fields-in-mutations"
                            }
                        ]
                    },
                    {
                        "name": "Operation Name",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, an operation name is an optional identifier that can be used to uniquely identify a query or a mutation in a document containing multiple operations. It can be used to provide more meaningful names for operations, making it easier to understand the purpose of the operation and to identify it in the event of an error.",
                        "resources": [
                            {
                                "name": "Intro to Operation Name",
                                "link": "https://graphql.org/learn/queries/#operation-name"
                            }
                        ]
                    }
                ]
            },
            "Subscriptions": {
                "description": "In GraphQL, subscriptions are a way to push real-time updates to the client. They allow a client to subscribe to specific events or data changes on the server, and receive updates in real-time as soon as the event occurs or the data changes. Subscriptions are defined on the server and are structured similarly to queries and mutations.",
                "resources": [
                    {
                        "name": "Subscriptions and Live Queries - Real Time with GraphQL",
                        "link": "https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql"
                    }
                ],
                "order": 4,
                "options": [
                    {
                        "name": "What are Subscriptions",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, subscriptions are a way to push real-time updates to the client. They allow a client to subscribe to a specific event or data change on the server, and receive updates in real-time as soon as the event occurs or the data changes. Subscriptions are defined on the server and are structured similar to queries and mutations. They have a “subscription” field at the top level, followed by the fields that define the event or data change to be subscribed to.",
                        "resources": [
                            {
                                "name": "How GraphQL Subscriptions Work?",
                                "link": "https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql"
                            }
                        ]
                    },
                    {
                        "name": "Event Based Subscriptions",
                        "recommendation-type": "opinion",
                        "description": "Event-based subscriptions in GraphQL are a way to push real-time updates to the client based on specific events that occur on the server. These events can be triggered by external sources such as user actions, sensor data, or other systems, or by internal actions such as database updates. With event-based subscriptions, the client can subscribe to a specific event or set of events and receive updates in real-time as soon as the event occurs. This allows the client to receive notifications about important changes in the system without the need to constantly poll the server for updates.",
                        "resources": [
                            {
                                "name": "",
                                "link": ""
                            }
                        ]
                    },
                    {
                        "name": "Live Queries",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, live queries, also known as “real-time queries” or “subscriptions to queries”, is a way to push real-time updates to the client when the data that is being queried changes on the server. It allows the client to subscribe to a specific query and receive updates in real-time as soon as the data changes. With live queries, the client can subscribe to a specific query and receive updates when the data that is being queried changes on the server. The client can also specify the fields and arguments of the query, and the server will only send updates for the fields that the client has requested.",
                        "resources": [
                            {
                                "name": "GraphQL Live Queries",
                                "link": "https://the-guild.dev/blog/collecting-graphql-live-query-resource-identifier-with-graphql-tools"
                            }
                        ]
                    },
                    {
                        "name": "Defer Stream Directives",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, the “defer” and “stream” directives are used to control the handling of fields and their associated data. These directives allow developers to control how data is fetched and sent over the network and can be used to optimize the performance of a GraphQL API. The “defer” directive is used to delay the fetching of a field’s data until the data is actually needed by the client. This can be useful for improving the performance of an API by reducing the amount of data that needs to be fetched upfront.",
                        "resources": [
                            {
                                "name": "Defer and Stream in GraphQL",
                                "link": "https://the-guild.dev/graphql/yoga-server/docs/features/defer-stream"
                            }
                        ]
                    }
                ]
            },
            "Schema": {
                "description": "In GraphQL, a schema is a blueprint that defines the types, fields, and operations (queries and mutations) that are available to clients. The schema is the contract between the client and the server, specifying what data can be requested and how it can be modified. A GraphQL schema is defined using the GraphQL Schema Definition Language (SDL), which is a human-readable syntax for defining the structure of a GraphQL API. The SDL includes keywords such as type, query, mutation, field, and argument to define the different components of a schema.",
                "resources": [
                    {
                        "name": "Get started with Schema",
                        "link": "https://graphql.org/learn/schema/"
                    }
                ],
                "order": 5,
                "options": [
                    {
                        "name": "Type System",
                        "recommendation-type": "opinion",
                        "description": "GraphQL is a strongly typed language. Type System defines various data types that can be used in a GraphQL application. The type system helps to define the schema, which is a contract between client and server. The commonly used GraphQL data types are as follows:\n\nScalar\nObject\nQuery\nMutation\nEnum",
                        "resources": [
                            {
                                "name": "GraphQL Type System Documentation",
                                "link": "https://graphql.org/learn/schema/"
                            }
                        ]
                    },
                    {
                        "Scalars": {
                            "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                            "resources": [
                                {
                                    "name": "GraphQL Scalars Documentation",
                                    "link": "https://graphql.org/learn/schema/#scalar-types"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Int",
                                    "recommendation-type": "opinion",
                                    "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                                    "resources": [
                                        {
                                            "name": "GraphQL Scalars Documentation",
                                            "link": "https://graphql.org/learn/schema/#scalar-types"
                                        }
                                    ]
                                },
                                {
                                    "name": "Floot",
                                    "recommendation-type": "opinion",
                                    "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                                    "resources": [
                                        {
                                            "name": "GraphQL Scalars Documentation",
                                            "link": "https://graphql.org/learn/schema/#scalar-types"
                                        }
                                    ]
                                },
                                {
                                    "name": "String",
                                    "recommendation-type": "opinion",
                                    "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                                    "resources": [
                                        {
                                            "name": "GraphQL Scalars Documentation",
                                            "link": "https://graphql.org/learn/schema/#scalar-types"
                                        }
                                    ]
                                },
                                {
                                    "name": "Boolean",
                                    "recommendation-type": "opinion",
                                    "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                                    "resources": [
                                        {
                                            "name": "GraphQL Scalars Documentation",
                                            "link": "https://graphql.org/learn/schema/#scalar-types"
                                        }
                                    ]
                                },
                                {
                                    "name": "ID",
                                    "recommendation-type": "opinion",
                                    "description": "Scalars are “leaf” values in GraphQL. There are several built-in scalars, and you can define custom scalars, too. (Enums are also leaf values.) The built-in scalars are:\n\nString, like a JSON or Ruby string\nInt, like a JSON or Ruby integer\nFloat, like a JSON or Ruby floating point decimal\nBoolean, like a JSON or Ruby boolean (true or false)\nID, which a specialized String for representing unique object identifiers\nISO8601DateTime, an ISO 8601-encoded datetime\nISO8601Date, an ISO 8601-encoded date\nJSON, This returns arbitrary JSON (Ruby hashes, arrays, strings, integers, floats, booleans and nils). Take care: by using this type, you completely lose all GraphQL type safety. Consider building object types for your data instead.\nBigInt, a numeric value which may exceed the size of a 32-bit integer",
                                    "resources": [
                                        {
                                            "name": "GraphQL Scalars Documentation",
                                            "link": "https://graphql.org/learn/schema/#scalar-types"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "name": "Fields",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, a field is a unit of data that can be queried or manipulated in a request. Each field has a name, a type, and an optional description. Fields are defined within an object type in a GraphQL schema.\n\nEach field in a GraphQL schema can return a scalar value (such as a string or an integer) or another object, allowing for the creation of complex, nested data structures. The fields can also take arguments, which allows to filter or modify the data being returned.",
                        "resources": [
                            {
                                "name": "GraphQL Fields Documentation",
                                "link": "https://graphql.org/learn/schema/#fields"
                            }
                        ]
                    },
                    {
                        "name": "Enums",
                        "recommendation-type": "opinion",
                        "description": "Enums, also called enumeration types, are a special kind of scalar that is restricted to a particular set of allowed values. This allows you to:\n\n- Validate that any arguments of this type are one of the allowed values\n- Communicate through the type system that a field will always be one of a finite set of values",
                        "resources": [
                            {
                                "name": "GraphQL Enums Documentation",
                                "link": "https://graphql.org/learn/schema/#enumeration-types"
                            }
                        ]
                    },
                    {
                        "name": "Objects",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, an object is a type that represents a group of fields. Objects can be used to define the structure of a query or a mutation. Each field of an object can return a scalar value (such as a string or an integer) or another object, allowing for the creation of complex, nested data structures. In a GraphQL schema, objects are defined using the type keyword, followed by the object’s name and a set of fields in curly braces.",
                        "resources": [
                            {
                                "name": "GraphQL Object Types Documentation",
                                "link": "https://graphql.org/learn/schema/#object-types"
                            }
                        ]
                    },
                    {
                        "name": "Lists",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, a list is a type that represents an ordered collection of items. Lists are defined using square brackets, with the type of the items inside. Lists are used to represent an array of items in a GraphQL schema, and can be used as the return type for a field in an object type. Lists can contain any type of items, including scalars and other objects, and can also be nested within other lists.",
                        "resources": [
                            {
                                "name": "GraphQL Lists Documentation",
                                "link": "https://graphql.org/learn/schema/#lists"
                            }
                        ]
                    },
                    {
                        "name": "Interfaces",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, an interface is a type that defines a set of fields that a type must implement. Interfaces are defined using the interface keyword, and can be used to define common fields for multiple types. In GraphQL, lists can also be used within interfaces to define the return type for fields.",
                        "resources": [
                            {
                                "name": "GraphQL Interfaces Documentation",
                                "link": "https://graphql.org/learn/schema/#interfaces"
                            }
                        ]
                    },
                    {
                        "name": "Unions",
                        "recommendation-type": "opinion",
                        "description": "Unions are useful in cases where a field can return multiple types and you want to handle those types differently in your client. They also allow for more flexibility in how you structure your schema, as you can group types together that share common fields. Unions don’t allow to specify a common set of fields to be queried across multiple types, but it allows to handle multiple types differently in your client.",
                        "resources": [
                            {
                                "name": "GraphQL Unions Documentation",
                                "link": "https://graphql.org/learn/schema/#union-types"
                            }
                        ]
                    },
                    {
                        "Arguments": {
                            "description": "In GraphQL, an argument is a value that is passed to a field in a query or mutation. Arguments allow you to filter or modify the data being returned by a field. Arguments are defined within a field in a GraphQL schema, and have a name, a type, and an optional default value.",
                            "resources": [
                                {
                                    "name": "GraphQL Arguments Documentation",
                                    "link": "https://graphql.org/learn/queries/#arguments"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Arguments",
                                    "recommendation-type": "opinion",
                                    "description": "In GraphQL, an argument is a value that is passed to a field in a query or mutation. Arguments allow you to filter or modify the data being returned by a field. Arguments are defined within a field in a GraphQL schema, and have a name, a type, and an optional default value.",
                                    "resources": [
                                        {
                                            "name": "GraphQL Arguments Documentation",
                                            "link": "https://graphql.org/learn/queries/#arguments"
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ]
            },
            "Validation": {
                "description": "Validation in GraphQL refers to the process of checking whether a GraphQL query or mutation conforms to the rules and constraints defined in the GraphQL schema. This can include checking that the query or mutation includes the required fields, that the arguments passed to a field are of the correct type, and that the values passed to fields or arguments fall within the expected range.",
                "resources": [
                    {
                        "name": "Get Started with Validation in GraphQL",
                        "link": "https://graphql.org/learn/validation/"
                    }
                ],
                "order": 6,
                "options": []
            },
            "Execution": {
                "description": "In GraphQL, execution refers to the process of executing a query or mutation and returning the result to the client. The execution process includes several steps such as parsing, validation, and data retrieval, that are performed by the GraphQL engine to produce the final response to the client.",
                "resources": [
                    {
                        "name": "Get Started with Execution in GraphQL",
                        "link": "https://graphql.org/learn/execution/"
                    },
                    {
                        "name": "Intro to Execution",
                        "link": "https://graphql.org/graphql-js/execution/"
                    }
                ],
                "order": 7,
                "options": [
                    {
                        "name": "Root Fields",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, the root fields are the top-level fields that are available to clients in a query or mutation. They are defined in the schema and are the entry point for client requests. The root fields represent the operations that can be performed on the data, such as querying for data or modifying data.\n\nThere are two types of root fields in GraphQL:\n\nQuery: defines the fields that can be queried to retrieve data from the server.\nMutation: defines the fields that can be used to create, update, or delete data on the server.",
                        "resources": [
                            {
                                "name": "Get Started with Root Fields",
                                "link": "https://graphql.org/learn/execution/#root-fields-resolvers"
                            }
                        ]
                    },
                    {
                        "name": "Validation",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, validation refers to the process of ensuring that a query or mutation adheres to the rules defined in the schema. This includes verifying that the query or mutation only accesses fields and types that are defined in the schema, and that the input values for fields are of the correct type and within the specified constraints.\n\nGraphQL servers perform validation on all incoming queries and mutations to ensure that they are valid before executing them. If a query or mutation is invalid, the server will return an error, indicating which parts of the query or mutation are invalid and why.",
                        "resources": [
                            {
                                "name": "Get Started with Validation in GraphQL",
                                "link": "https://graphql.org/learn/validation/"
                            }
                        ]
                    },
                    {
                        "name": "Producing The Result",
                        "recommendation-type": "opinion",
                        "description": "In GraphQL, producing the result refers to the process of generating the final response to a query or mutation. This includes executing the resolvers for the selected fields, gathering the data, and formatting the response according to the requirements of the query or mutation.\n\nWhen a client sends a query or mutation to a GraphQL server, the server performs several steps to produce the result:\n\nParsing: The query or mutation is parsed and converted into an abstract syntax tree (AST)\nValidation: The query or mutation is validated against the schema to ensure that it is well-formed and adheres to the schema definition.\nExecution: The resolvers for the selected fields are executed, and the data is retrieved from the data source.\nFormatting: The data is formatted and organized into the final response, according to the requirements of the query or mutation.",
                        "resources": [
                            {
                                "name": "Get Started with GraphQL",
                                "link": "https://graphql.org/learn/"
                            }
                        ]
                    }
                ],
                "Resolvers": {
                    "description": "In GraphQL, a resolver is a function that is responsible for fetching the data for a field in a query or mutation. Resolvers are defined in the schema and are executed by the GraphQL server when a query or mutation is received.\n\nEach field in a GraphQL schema has a corresponding resolver function that is responsible for returning the data for that field. The resolver function can retrieve the data from a database, a third-party API, or any other source, and return it to the client.",
                    "resources": [
                        {
                            "name": "Guide to Resolver",
                            "link": "https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen"
                        }
                    ],
                    "options": [
                        {
                            "name": "Synchronous",
                            "recommendation-type": "opinion",
                            "description": "In GraphQL, a resolver is a function that is responsible for fetching the data for a field in a query or mutation. Resolvers are defined in the schema and are executed by the GraphQL server when a query or mutation is received.\n\nA synchronous resolver is a type of resolver that runs and completes its execution before returning any value. It directly returns the result of the computation, without waiting for any external event such as a database query or a third-party API call.",
                            "resources": []
                        },
                        {
                            "name": "Asynchronous",
                            "recommendation-type": "opinion",
                            "description": "In GraphQL, a resolver is a function that is responsible for fetching the data for a field in a query or mutation. Resolvers are defined in the schema and are executed by the GraphQL server when a query or mutation is received.\n\nAn asynchronous resolver is a type of resolver that runs, but instead of returning the final value, it returns a promise that will be resolved with the final value. This allows the resolver to wait for an external event such as a database query or a third-party API call to complete before returning the result.",
                            "resources": [
                                {
                                    "name": "Learn More about Asynchronous Resolvers",
                                    "link": "https://graphql.org/learn/execution/#asynchronous-resolvers"
                                }
                            ]
                        },
                        {
                            "name": "Scalar Coercion",
                            "recommendation-type": "opinion",
                            "description": "In GraphQL, scalar coercion is the process of converting a value from one type to another, as it flows through the resolvers. This is needed when the input value for a field does not match the expected type, but can still be successfully converted to the correct type.\n\nScalar coercion can be implemented in the resolvers by using the GraphQLScalarType constructor to define a custom scalar type and providing a coerce function that can convert the input value to the correct type.",
                            "resources": [
                                {
                                    "name": "Learn More about Scalar Coercion",
                                    "link": "https://graphql.org/learn/execution/#scalar-coercion"
                                }
                            ]
                        },
                        {
                            "name": "Lists",
                            "recommendation-type": "opinion",
                            "description": "In GraphQL, a list is a type that represents an ordered collection of items. Lists can be used as the return type for a field in a query or mutation, and can contain any type of items, including scalars and objects.\n\nThe resolver function for a list field can retrieve the data from a database or a third-party API and return it as an array.",
                            "resources": [
                                {
                                    "name": "Learn More about Lists",
                                    "link": "https://graphql.org/learn/schema/#lists-and-non-null"
                                }
                            ]
                        }
                    ]
                }
            },
            "Serving Over Internet": {
                "description": "In GraphQL, a list is a type that represents an ordered collection of items. Lists can be used as the return type for a field in a query or mutation, and can contain any type of items, including scalars and objects.\n\nThe resolver function for a list field can retrieve the data from a database or a third-party API and return it as an array.",
                "resources": [
                    {
                        "name": "Learn More about Lists",
                        "link": "https://graphql.org/learn/serving-over-http/"
                    }
                ],
                "order": 8,
                "options": [
                    {
                        "Over Websocket": {
                            "description": "The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between the user’s browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply.",
                            "resources": [
                                {
                                    "name": "Learn More about GraphQL Over WebSockets",
                                    "link": "https://the-guild.dev/blog/graphql-over-websockets"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Authorization",
                                    "recommendation-type": "opinion",
                                    "description": "Authorization in GraphQL refers to the process of controlling access to specific fields, types, or operations in a GraphQL schema based on user roles or permissions. It allows you to restrict access to certain data or functionality in your application based on the user’s role or permissions.",
                                    "resources": [
                                        {
                                            "name": "Learn More about GraphQL Authorization",
                                            "link": "https://graphql.org/learn/authorization/"
                                        }
                                    ]
                                },
                                {
                                    "name": "Real Time",
                                    "recommendation-type": "opinion",
                                    "description": "Real-time in GraphQL refers to the ability to receive real-time updates from a GraphQL server. This allows clients to receive updates from the server as soon as they occur, rather than having to periodically poll the server for new data.",
                                    "resources": [
                                        {
                                            "name": "Learn More about Real-Time in GraphQL",
                                            "link": "https://the-guild.dev/blog/subscriptions-and-live-queries-real-time-with-graphql"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "Over SSE": {
                            "description": "GraphQL over SSE (Server-Sent Events) is a way to use the Server-Sent Events (SSE) protocol to send real-time updates from the server to the client over a single HTTP connection. SSE is a simple and efficient protocol for sending real-time updates from the server to the client over a single HTTP connection. It’s supported by most modern web browsers and it’s easy to implement on the server side. To implement GraphQL over SSE, you can use a library such as graphql-sse which provides a way to send GraphQL updates over SSE. This library allows you to handle SSE connections and events, and to send and receive GraphQL updates over the SSE connection.",
                            "resources": [
                                {
                                    "name": "Learn More about GraphQL Over SSE",
                                    "link": "https://the-guild.dev/blog/graphql-over-sse"
                                }
                            ],
                            "options": []
                        }
                    },
                    {
                        "Over HTTP": {
                            "description": "GraphQL over HTTP refers to the ability to send GraphQL queries and mutations over the HTTP protocol. This allows clients to interact with a GraphQL server using the same standard HTTP methods and headers that are used for other types of web requests. The most common way to send GraphQL queries and mutations over HTTP is by using the POST method, where the query or mutation is sent in the request body as a JSON payload. The server will then execute the query or mutation and return the result in the response body.",
                            "resources": [
                                {
                                    "name": "Learn More about GraphQL Over HTTP",
                                    "link": "https://graphql.org/learn/serving-over-http/"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Caching",
                                    "recommendation-type": "opinion",
                                    "description": "Caching is a technique that is used to improve the performance of a GraphQL server by reducing the number of requests that need to be made to the data source. It works by storing a copy of the data that has been requested by a client in a cache, and then returning that data from the cache instead of the data source when the same data is requested again. There are several types of caching that can be used in GraphQL: Client-side caching, Server-side caching, CDN caching.",
                                    "resources": [
                                        {
                                            "name": "Learn More about GraphQL Caching",
                                            "link": "Get started with Caching"
                                        }
                                    ]
                                },
                                {
                                    "name": "Batching",
                                    "recommendation-type": "opinion",
                                    "description": "Batching in GraphQL refers to the process of sending multiple queries or mutations in a single request. This allows the client to reduce the number of round trips to the server, and can improve the performance of the application. There are several ways to implement batching in GraphQL: Using a batching library, Using a middleware, Using a serverless function.",
                                    "resources": []
                                },
                                {
                                    "name": "Authorization",
                                    "recommendation-type": "opinion",
                                    "description": "Authorization in GraphQL refers to the process of controlling access to specific fields, types, or operations in a GraphQL schema based on user roles or permissions. It allows you to restrict access to certain data or functionality in your application based on the user’s role or permissions. There are several ways to implement authorization in GraphQL: Using middleware, Using schema directives, Using a data source layer.",
                                    "resources": [
                                        {
                                            "name": "Learn More about GraphQL Authorization",
                                            "link": "https://graphql.org/learn/authorization/"
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ]
            },
            "Pagination": {
                "description": "Pagination in GraphQL refers to the process of breaking up large sets of data into smaller chunks, also known as pages, and providing a way to navigate between these pages. This allows clients to retrieve a specific subset of data, rather than having to retrieve all of the data at once, which can be beneficial for performance, especially when working with large datasets.\n\nThere are several ways to implement pagination in GraphQL:\n\nCursor-based pagination\nOffset-based pagination\nRelay-style pagination",
                "resources": [
                    {
                        "name": "Learn More about Pagination in GraphQL",
                        "link": "https://graphql.org/learn/pagination/"
                    }
                ],
                "order": 9,
                "options": []
            },
            "Frontend Implementations": {
                "description": "In GraphQL, the frontend refers to the client-side of the application, typically the web or mobile app that the end-user interacts with. When using GraphQL on the frontend, developers can use a GraphQL client library, such as Apollo Client or Relay, to interact with the GraphQL server. These libraries provide a way to easily send GraphQL queries and mutations to the server and handle the response.",
                "resources": [
                    {
                        "name": "Guide to GraphQL for Front-End Developers",
                        "link": "https://www.howtographql.com/react-apollo/0-introduction/"
                    }
                ],
                "order": 10,
                "options": [
                    {
                        "name": "Relay",
                        "recommendation-type": "opinion",
                        "description": "Relay is a JavaScript framework that was developed by Facebook to build data-driven applications using GraphQL. It provides a set of tools and conventions that make it easier to build efficient and scalable applications that use GraphQL. Relay is designed to work with GraphQL on the server and provides a set of client-side libraries for building client applications. It provides a set of components and hooks that make it easy to build efficient and scalable applications.",
                        "resources": [
                            {
                                "name": "GraphQL Code Generator & Relay Compiler",
                                "link": "https://the-guild.dev/blog/graphql-codegen-relay-compiler"
                            }
                        ]
                    },
                    {
                        "name": "Apollo Client",
                        "recommendation-type": "opinion",
                        "description": "Apollo Client is a popular JavaScript library for building client applications that consume GraphQL APIs. It is developed and maintained by the Apollo team and is widely used in the industry. Apollo Client provides a set of features that make it easy to interact with a GraphQL server, such as querying, mutating, and subscribing to data. It also provides a caching system to store the results of previous queries, which improves the performance of the application.",
                        "resources": [
                            {
                                "name": "Why Apollo Client - Frontend?",
                                "link": "https://www.howtographql.com/react-apollo/0-introduction/"
                            }
                        ]
                    },
                    {
                        "name": "URQL",
                        "recommendation-type": "opinion",
                        "description": "URQL is a highly customizable and versatile GraphQL client with which you add on features like normalized caching as you grow. It’s built to be both easy to use for newcomers to GraphQL, and extensible, to grow to support dynamic single-app applications and highly customized GraphQL infrastructure.",
                        "resources": [
                            {
                                "name": "urql - Formidable Labs",
                                "link": "https://formidable.com/open-source/urql/"
                            }
                        ]
                    }
                ]
            },
            "Backend Implementations": {
                "description": "There are several ways to implement a GraphQL backend, depending on the use case, the technology stack, and the complexity of the application. The most common ways to implement a GraphQL backend are:\n\nBuilding a custom GraphQL server\nUsing a GraphQL backend-as-a-service\nWrapping a REST API with a GraphQL layer\nUsing a microservices architecture",
                "resources": [
                    {
                        "name": "How to use GraphQL to build Backend?",
                        "link": "https://www.howtographql.com/typescript-apollo/0-introduction/"
                    }
                ],
                "options": [
                    {
                        "name": "GraphQL HTTP",
                        "recommendation-type": "opinion",
                        "description": "GraphQL HTTP is a specification for serving GraphQL over HTTP. It defines a standard way of sending GraphQL queries and mutations over the HTTP protocol, and it is widely supported by GraphQL servers and clients. The GraphQL HTTP specification defines two main HTTP methods:\n\nPOST: Used to send queries and mutations to the server. The query or mutation is sent in the request body as a JSON payload, and the server returns the result in the response body.\nGET: Used to send queries to the server, but it’s not recommended to use GET for queries because it’s not as efficient as POST method.",
                        "resources": [
                            {
                                "name": "Overview of GraphQL HTTP",
                                "link": "https://graphql.org/graphql-js/express-graphql/#graphqlhttp"
                            },
                            {
                                "name": "Get Started with GraphQL HTTP",
                                "link": "https://graphql.org/learn/serving-over-http/"
                            }
                        ]
                    },
                    {
                        "name": "GraphQL Yoga",
                        "recommendation-type": "opinion",
                        "description": "GraphQL Yoga is a popular open-source GraphQL server library for Node.js. It is built on top of the popular Express.js web framework and provides a simple and flexible way to build GraphQL servers with minimal boilerplate code. One of the key features of GraphQL Yoga is that it provides a set of built-in functionality that makes it easy to handle common tasks such as authentication, authorization, and data validation. It also provides support for subscriptions, which allow clients to receive real-time updates from the server.",
                        "resources": [
                            {
                                "name": "GraphQL Armor - for Yoga Server 2",
                                "link": "https://the-guild.dev/blog/improved-security-with-graphql-armor-support-for-yoga-server-2"
                            }
                        ]
                    },
                    {
                        "name": "GraphQL Yoga",
                        "recommendation-type": "opinion",
                        "description": "GraphQL Yoga is a popular open-source GraphQL server library for Node.js. It is built on top of the popular Express.js web framework and provides a simple and flexible way to build GraphQL servers with minimal boilerplate code. One of the key features of GraphQL Yoga is that it provides a set of built-in functionality that makes it easy to handle common tasks such as authentication, authorization, and data validation. It also provides support for subscriptions, which allow clients to receive real-time updates from the server.",
                        "resources": [
                            {
                                "name": "GraphQL Armor - for Yoga Server 2",
                                "link": "https://www.howtographql.com/react-apollo/0-introduction/"
                            }
                        ]
                    },
                    {
                        "name": "Apollo Server",
                        "recommendation-type": "opinion",
                        "description": "Apollo Server is a popular open-source library for building GraphQL servers in JavaScript. It provides a simple and flexible way to build GraphQL servers by providing a set of tools and features for handling common tasks such as parsing and validating queries, executing resolvers, and formatting responses. One of the key features of Apollo Server is that it provides a set of built-in functionality that makes it easy to handle common tasks such as authentication, authorization, and data validation. It also provides support for subscriptions, which allow clients to receive real-time updates from the server.",
                        "resources": [
                            {
                                "name": "Apollo Tutorial - Introduction",
                                "link": "https://www.howtographql.com/react-apollo/0-introduction/"
                            }
                        ]
                    },
                    {
                        "name": "Mercurius",
                        "recommendation-type": "opinion",
                        "description": "Mercurius is an open-source library for building real-time GraphQL servers in Node.js. It provides a simple and flexible way to build GraphQL servers by providing a set of tools and features for handling real-time subscriptions. One of the key features of Mercurius is that it is built on top of the popular WebSockets protocol and it allows the client to subscribe to real-time updates from the server. It also supports batching and caching of queries and mutations, which allows for efficient and fast data transfer between the client and server.",
                        "resources": [
                            {
                                "name": "Mercurius GitHub Repository",
                                "link": "https://github.com/mercurius-js/mercurius"
                            }
                        ]
                    }
                ]
            }
           
        }
    }
}