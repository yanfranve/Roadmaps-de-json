{
    "Skill": {
        "TypeScript": {
            "description": "Everything you need to learn about TypeScript in 2023 ",
            "introduction": {
                "description": "TypeScript is a statically-typed programming language that is a superset of JavaScript. It was developed and is maintained by Microsoft. TypeScript was created to address the challenges of building large-scale JavaScript applications and adds optional type annotations, classes, interfaces, and other features to the language. The main benefits of using TypeScript include:",
                "resources": [
                    {
                        "name": "Overview of TypeScript",
                        "link": "https://www.typescriptlang.org/docs/"
                    },
                    {
                        "name": "TypeScript Handbook",
                        "link": "https://www.typescriptlang.org/docs/handbook/"
                    },
                    {
                        "name": "What Is TypeScript?",
                        "link": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
                    },
                    {
                        "name": "Video: Where TypeScript Excels",
                        "link": "https://www.youtube.com/watch?v=HkE5tB0Jw4E"
                    }
                ],
                "order": 1,
                "options": [
                    {
                        "Running TypeScript": {
                            "description": "To run TypeScript code, you’ll need to have a TypeScript compiler installed. Here’s a general process to run TypeScript code:\nWrite TypeScript code in a .ts file (e.g. app.ts)Compile the TypeScript code into JavaScript using the TypeScript compiler:\ntsc app.ts Run the generated JavaScript code using a JavaScript runtime environment such as Node.js:node app.jsLearn more from the following link: ",
                            "resources": [
                                {
                                    "name": "Running your TypeScript",
                                    "link": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
                                }
                            ],
                            "options": [
                                {
                                    "name": "tsc",
                                    "recommendation-type": "opinion",
                                    "description": "tsc is the command line tool for the TypeScript compiler. It compiles TypeScript code into JavaScript code, making it compatible with the browser or any JavaScript runtime environment.You can use the tsc command to compile your TypeScript code by running the following command in your terminal or command prompt tsc This command will compile all TypeScript files in your project that are specified in your tsconfig.json file. If you want to compile a specific TypeScript file, you can specify the file name after the tsc command, like this:tsc index.ts The tsc command has several options and flags that you can use to customize the compilation process. For example, you can use the --target option to specify the version of JavaScript to compile to, or the --outDir option to specify the output directory for the compiled JavaScript files.You can run tsc --help to see a list of all the available options and flags. Learn more from the following links:",
                                    "resources": [
                                        {
                                            "name": "tsc CLI Options",
                                            "link": "https://www.typescriptlang.org/tsconfig"
                                        }
                                    ]
                                },
                                {
                                    "name": "ts-node",
                                    "recommendation-type": "opinion",
                                    "description": "ts-node is a TypeScript execution and REPL for node.js, with source map and native ESM support.",
                                    "resources": [
                                        {
                                            "name": "ts-node - GitHub Project",
                                            "link": "https://github.com/TypeStrong/ts-node"
                                        },
                                        {
                                            "name": "How To Run TypeScript Scripts with ts-node",
                                            "link": "https://www.twilio.com/blog/how-to-run-typescript-with-ts-node"
                                        }
                                    ]
                                },
                                {
                                    "name": "TS Playground",
                                    "recommendation-type": "opinion",
                                    "description": "The TypeScript Playground is a great tool to learn TypeScript. It allows you to write TypeScript code and see the JavaScript output. It also allows you to share your code with others.",
                                    "resources": [
                                        {
                                            "name": "TypeScript - Playground",
                                            "link": "https://www.typescriptlang.org/play"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "name": "TypeScript vs JavaScript",
                        "recommendation-type": "opinion",
                        "description": "TypeScript is a superset of JavaScript that adds optional type annotations and other features such as interfaces, classes, and namespaces. JavaScript is a dynamically-typed language that is primarily used for client-side web development and can also be used for server-side development. Here are a few key differences between TypeScript and JavaScript:\nTypes: TypeScript has optional type annotations while JavaScript is dynamically-typed. This means that in TypeScript, you can specify the data type of variables, parameters, and return values, which can help catch type-related errors at compile-time.\nSyntax: TypeScript extends JavaScript syntax with features like interfaces, classes, and namespaces. This provides a more robust and organized structure for large-scale projects.\nTooling: TypeScript has better tooling support, such as better editor integration, type checking, and code refactoring.\nBackwards Compatibility: TypeScript is fully compatible with existing JavaScript code, which means you can use TypeScript in any JavaScript environment.Learn more from the following links:",
                        "resources": [
                            {
                                "name": "Learning JavaScript and TypeScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
                            },
                            {
                                "name": "TypeScript vs. JavaScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
                            }
                        ]
                    },
                    {
                        "name": "TS/JS Interoperability",
                        "recommendation-type": "opinion",
                        "description": "TypeScript and JavaScript have full interoperability, meaning you can use TypeScript code in JavaScript projects and vice versa. TypeScript is a superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code.\nYou can use JavaScript libraries in TypeScript projects by either including the JavaScript files directly or using type definitions for the library. Type definitions provide type information for JavaScript libraries, making it easier to use them in TypeScript.\nOn the other hand, you can use TypeScript code in JavaScript projects by simply compiling the TypeScript code into JavaScript. The generated JavaScript code can be used in any JavaScript environment, and it will work the same way as regular JavaScript code.",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - JavaScript Interoperability",
                                "link": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html"
                            }
                        ]
                    },
                    {
                        "Installation and Configure": {
                            "description": "To install and configure TypeScript in your project, you need to perform the following steps:Initialize npm in your project directory by running the following command:npm initInstall TypeScript as a project dependency by running the following command:npm install --save-dev typescript Create a tsconfig.json file in your project directory to specify the compiler options for building your project. For example:Compile your TypeScript code using the following command:tsc Note: You can also compile individual TypeScript files by specifying the file name after the tsc command.For example:tsc index.ts And you’re all set! You can now start writing TypeScript code in your project.",
                            "resources": [
                                {
                                    "name": "Install and Configure TypeScript",
                                    "link": "https://www.typescriptlang.org/docs/"
                                },
                                {
                                    "name": "TypeScript Getting Started",
                                    "link": "https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"
                                }
                            ],
                            "options": [
                                {
                                    "name": "Compiler Options",
                                    "recommendation-type": "opinion",
                                    "description": "TypeScript compiler accepts a number of command line options that allow you to customize the compilation process. These options can be passed to the compiler using the -- prefix, for example:",
                                    "resources": [
                                        {
                                            "name": "Compiler Options",
                                            "link": "https://www.typescriptlang.org/docs/handbook/compiler-options.html"
                                        }
                                    ]
                                },
                                {
                                    "name": "tsconfig.json",
                                    "recommendation-type": "opinion",
                                    "description": "tsconfig.json is a configuration file in TypeScript that specifies the compiler options for building your project. It helps the TypeScript compiler understand the structure of your project and how it should be compiled to JavaScript. Some common options include:",
                                    "resources": [
                                        {
                                            "name": "What is a tsconfig.json",
                                            "link": "https://www.typescriptlang.org/tsconfig"
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ]
            },
            "Typescript Types": {
                "description": "TypeScript has several built-in types, including: number, string, boolean, any, void, null and undefined, never, object, symbol, Enumerated types (enum), Tuple types, Array types, Union types, Intersection types, Type aliases, and Type assertions. You can also create custom types in TypeScript using interfaces, classes, and type aliases.",
                "resources": [
                    {
                        "name": "TypeScript - Everyday Types",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html"
                    }
                ],
                "order": 2,
                "options": [
                    {
                        "Primitive Types": {
                            "options": [
                                {
                                    "name": "boolean",
                                    "recommendation-type": "opinion",
                                    "description": "boolean is a primitive data type in TypeScript that represents a boolean value i.e. either true or false. Given below is an example of a boolean variable declaration:\n\nlet isTrue: boolean = true;\nlet isFalse: boolean = false;",
                                    "resources": [
                                        {
                                            "name": "Number, String, Boolean, Symbol and Object",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
                                        }
                                    ]
                                },
                                {
                                    "name": "number",
                                    "recommendation-type": "opinion",
                                    "description": "It is a primitive data type in TypeScript that represents numeric values. It includes both integer and floating-point values.\n\nlet intValue: number = 42;\nlet floatValue: number = 3.14;",
                                    "resources": [
                                        {
                                            "name": "Number, String, Boolean, Symbol and Object",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
                                        }
                                    ]
                                },
                                {
                                    "name": "string",
                                    "recommendation-type": "opinion",
                                    "description": "It is a primitive data type in TypeScript that represents textual data. It is a set of elements of the 16-bit Unicode character set.\n\nlet name: string = 'John Doe';",
                                    "resources": [
                                        {
                                            "name": "Number, String, Boolean, Symbol and Object",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"
                                        }
                                    ]
                                },
                                {
                                    "name": "void",
                                    "recommendation-type": "opinion",
                                    "description": "void represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements:\n\n// The inferred return type is void\nfunction noop() {\n  return;\n}\nIn JavaScript, a function that doesn’t return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter.",
                                    "resources": [
                                        {
                                            "name": "void - TypeScript Docs",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/functions.html#void"
                                        }
                                    ]
                                },
                                {
                                    "name": "undefined",
                                    "recommendation-type": "opinion",
                                    "description": "JavaScript has two primitive values used to signal absent or uninitialized value: null (absent) and undefined (unintialized).\n\nTypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.\n\nWith strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; TypeScript always recommend people turn strictNullChecks on if it’s practical to do so in the codebase.\n\nWith strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:\n\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}",
                                    "resources": [
                                        {
                                            "name": "null and undefined",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined"
                                        }
                                    ]
                                },
                                {
                                    "name": "null",
                                    "recommendation-type": "opinion",
                                    "description": "JavaScript has two primitive values used to signal absent or uninitialized value: null (absent) and undefined (unintialized).\n\nTypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.\n\nWith strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; TypeScript always recommend people turn strictNullChecks on if it’s practical to do so in the codebase.\n\nWith strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:\n\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}",
                                    "resources": [
                                        {
                                            "name": "null and undefined",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "object types": {
                            "options": [
                                {
                                    "name": "Interface",
                                    "recommendation-type": "opinion",
                                    "description": "TypeScript allows you to specifically type an object using an interface that can be reused by multiple objects.\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\nfunction greet(person: Person) {\n  return 'Hello ' + person.name;\n}",
                                    "resources": [
                                        {
                                            "name": "Object Types - Interfaces",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/objects.html"
                                        }
                                    ]
                                },
                                {
                                    "name": "Class",
                                    "recommendation-type": "opinion",
                                    "description": "In TypeScript, a class is a blueprint for creating objects with specific properties and methods. Classes are a fundamental concept in object-oriented programming. Here is an example of a simple class in TypeScript:\n\nclass Car {\n  make: string;\n  model: string;\n  year: number;\n\n  constructor(make: string, model: string, year: number) {\n    this.make = make;\n    this.model = model;\n    this.year = year;\n  }\n\n  drive() {\n    console.log(`Driving my ${this.year} ${this.make} ${this.model}`);\n  }\n}",
                                    "resources": [
                                        {
                                            "name": "TypeScript Classes",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html"
                                        }
                                    ]
                                },
                                {
                                    "name": "Enum",
                                    "recommendation-type": "opinion",
                                    "description": "Enums is not a type-level extension of JavaScript. It allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.\n\nHere is an example of a numeric enum in TypeScript:\n\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\nAbove, we have a numeric enum where Up is initialized with 1. All of the following members are auto-incremented from that point on. In other words, Direction.Up has the value 1, Down has 2, Left has 3, and Right has 4.\n\nIf we left off the initializer for Up, it would have the value 0 and the rest of the members would be auto-incremented from there.",
                                    "resources": [
                                        {
                                            "name": "TypeScript - Enums",
                                            "link": "https://www.typescriptlang.org/docs/handbook/enums.html"
                                        }
                                    ]
                                },
                                {
                                    "name": "Array",
                                    "recommendation-type": "opinion",
                                    "description": "To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array<number>, which means the same thing.\n\nconst numbers: number[] = [1, 2, 3];",
                                    "resources": [
                                        {
                                            "name": "Arrays",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays"
                                        }
                                    ]
                                },
                                {
                                    "name": "Tuple",
                                    "recommendation-type": "opinion",
                                    "description": "A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\ntype StringNumberPair = [string, number];\n\nconst pair: StringNumberPair = ['hello', 42];\n\nconst first = pair[0];\nconst second = pair[1];\n\n// Error: Index out of bounds\nconst third = pair[2];",
                                    "resources": [
                                        {
                                            "name": "Tuple Types",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "Other Types": {
                            "options": [
                                {
                                    "name": "Any",
                                    "recommendation-type": "opinion",
                                    "description": "TypeScript has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.\n\nWhen a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:\n\nlet obj: any = { x: 0 };\n// None of the following lines of code will throw compiler errors.\n// Using `any` disables all further type checking, and it is assumed\n// you know the environment better than TypeScript.\nobj.foo();\nobj();\nobj.bar = 100;\nobj = 'hello';\nconst n: number = obj;",
                                    "resources": [
                                        {
                                            "name": "any type in TypeScript",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any"
                                        }
                                    ]
                                },
                                {
                                    "name": "Object",
                                    "recommendation-type": "opinion",
                                    "description": "To define an object type, we simply list its properties and their types.\n\nFor example, here’s a function that takes a point-like object:\n\n// The parameter's type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\nprintCoord({ x: 3, y: 7 });",
                                    "resources": [
                                        {
                                            "name": "Object Types in TypeScript",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#object-types"
                                        }
                                    ]
                                },
                                {
                                    "name": "Unknown",
                                    "recommendation-type": "opinion",
                                    "description": "unknown is the type-safe counterpart of any. Anything is assignable to unknown, but unknown isn’t assignable to anything but itself and any without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an unknown without first asserting or narrowing to a more specific type.\n\nfunction f1(a: any) {\n  a.b(); // OK\n}\n\nfunction f2(a: unknown) {\n  // Error: Property 'b' does not exist on type 'unknown'.\n  a.b();\n}",
                                    "resources": [
                                        {
                                            "name": "Unknown Type in TypeScript",
                                            "link": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type"
                                        }
                                    ]
                                },
                                {
                                    "name": "Never",
                                    "recommendation-type": "opinion",
                                    "description": "The never type represents the type of values that never occur. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type never when narrowed by any type guards that can never be true.\n\nThe never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never.\n\nExamples of functions returning never:\n\n// Function returning never must not have a reachable end point\nfunction error(message: string): never {\n  throw an Error(message);\n}\n\n// Inferred return type is never\nfunction fail() {\n  return error('Something failed');\n}\n\n// Function returning never must not have a reachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}",
                                    "resources": [
                                        {
                                            "name": "Never",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "Assertions": {
                            "description": "Type assertions in TypeScript are a way to tell the compiler to treat a value as a specific type, regardless of its inferred type.\n\nThere are two syntaxes for type assertions in TypeScript:\n\nThe “angle-bracket” syntax: <T>value\nThe “as” syntax: value as T\nFor example:\n\nlet num = 42;\n\n// using angle-bracket syntax\nlet str = <string>num;\n\n// using as syntax\nlet str2 = num as string;\n\nIn both examples, num is a number, but the type assertions tell the compiler to treat the value as a string.",
                            "resources": [
                                {
                                    "name": "Type Assertions",
                                    "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions"
                                }
                            ],
                            "options": [
                                {
                                    "name": "As Const",
                                    "recommendation-type": "opinion",
                                    "description": "as const is a type assertion in TypeScript that allows you to assert that an expression has a specific type, and that its value should be treated as a read-only value.\n\nFor example:\n\nconst colors = ['red', 'green', 'blue'] as const;\n\n// colors is now of type readonly ['red', 'green', 'blue']\n\nUsing as const allows TypeScript to infer more accurate types for constants, which can lead to improved type checking and better type inference in your code.",
                                    "resources": [
                                        {
                                            "name": "const assertions",
                                            "link": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions"
                                        }
                                    ]
                                },
                                {
                                    "name": "As Type",
                                    "recommendation-type": "opinion",
                                    "description": "as is a type assertion in TypeScript that allows you to tell the compiler to treat a value as a specific type, regardless of its inferred type.\n\nFor example:\n\nlet num = 42;\nlet str = num as string;\n\n// str is now of type string, even though num is a number\n\nIt’s important to note that type assertions do not change the runtime type of a value, and do not cause any type of conversion. They simply provide a way for the programmer to override the type inference performed by the compiler.",
                                    "resources": [
                                        {
                                            "name": "Type assertions",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions"
                                        }
                                    ]
                                },
                                {
                                    "name": "As Any",
                                    "recommendation-type": "opinion",
                                    "description": "any is a special type in TypeScript that represents a value of any type. When a value is declared with the any type, the compiler will not perform any type checks or type inference on that value.\n\nFor example:\n\nlet anyValue: any = 42;\n\n// we can assign any value to anyValue, regardless of its type\nanyValue = 'Hello, world!';\nanyValue = true;",
                                    "resources": [
                                        {
                                            "name": "TypeScript Documentation",
                                            "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any"
                                        }
                                    ]
                                }
                            ]
                        }
                    },
                    {
                        "name": "Non Null Assertion",
                        "recommendation-type": "opinion",
                        "description": "The non-null assertion operator (!) is a type assertion in TypeScript that allows you to tell the compiler that a value will never be null or undefined.\n\nlet name: string | null = null;\n\n// we use the non-null assertion operator to tell the compiler that name will never be null\nlet nameLength = name!.length;\nThe non-null assertion operator is used to assert that a value is not null or undefined, and to tell the compiler to treat the value as non-nullable. However, it’s important to be careful when using the non-null assertion operator, as it can lead to runtime errors if the value is actually null or undefined.",
                        "resources": [
                            {
                                "name": "TypeScript Documentation",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator"
                            }
                        ]
                    },
                    {
                        "name": "Satisfies Keyword",
                        "recommendation-type": "opinion",
                        "description": "TypeScript developers are often faced with a dilemma: we want to ensure that some expression matches some type, but also want to keep the most specific type of that expression for inference purposes.\n\nFor example:\n\n// Each property can be a string or an RGB tuple.\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n  bleu: [0, 0, 255],\n  //  ^^^^ sacrebleu - we've made a typo!\n};\n\n// We want to be able to use array methods on 'red'...\nconst redComponent = palette.red.at(0);\n\n// or string methods on 'green'...\nconst greenNormalized = palette.green.toUpperCase();\n\nNotice that we’ve written bleu, whereas we probably should have written blue. We could try to catch that bleu typo by using a type annotation on palette, but we’d lose the information about each property.\n\ntype Colors = 'red' | 'green' | 'blue';\ntype RGB = [red: number, green: number, blue: number];\n\nconst palette: Record<Colors, string | RGB> = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n  bleu: [0, 0, 255],\n  //  ~~~~ The typo is now correctly detected\n};\n// But we now have an undesirable error here - 'palette.red' \"could\" be a string.\nconst redComponent = palette.red.at(0);\nThe satisfies operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression. As an example, we could use satisfies to validate that all the properties of palette are compatible with string | number[]:\n\ntype Colors = 'red' | 'green' | 'blue';\ntype RGB = [red: number, green: number, blue: number];\n\nconst palette = {\n  red: [255, 0, 0],\n  green: '#00ff00',\n  bleu: [0, 0, 255],\n  //  ~~~~ The typo is now caught!\n} satisfies Record<Colors, string | RGB>;\n\n// Both of these methods are still accessible!\nconst redComponent = palette.red.at(0);\nconst greenNormalized = palette.green.toUpperCase();",
                        "resources": [
                            {
                                "name": "TypeScript Documentation",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#as-const"
                            }
                        ]
                    }
                ]
            },
            "Type Inference": {
                "description": "Type inference in TypeScript refers to the process of automatically determining the type of a variable based on the value assigned to it. This allows you to write code that is more concise and easier to understand, as the TypeScript compiler can deduce the types of variables without you having to explicitly specify them.\n\nHere’s an example of type inference in TypeScript:\n\nlet name = 'John Doe';\nIn this example, the TypeScript compiler automatically infers that the type of the name variable is string. This means that you can use the name variable just like any other string in your code, and the TypeScript compiler will ensure that you don’t perform any invalid operations on it.",
                "resources": [
                    {
                        "name": "TypeScript Handbook - Type Inference",
                        "link": "https://www.typescriptlang.org/docs/handbook/type-inference.html#handbook-content"
                    }
                ],
                "order": 3,
                "options": []
            },
            "Type Compatibility": {
                "description": "TypeScript uses structural typing to determine type compatibility. This means that two types are considered compatible if they have the same structure, regardless of their names.\n\nHere’s an example of type compatibility in TypeScript:\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\nlet p1: Point = { x: 10, y: 20 };\nlet p2: { x: number; y: number } = p1;\n\nconsole.log(p2.x); // Output: 10\nIn this example, p1 has the type Point, while p2 has the type { x: number; y: number }. Despite the fact that the two types have different names, they are considered compatible because they have the same structure. This means that you can assign a value of type Point to a variable of type { x: number; y: number }, as we do with p1 and p2 in this example.",
                "resources": [
                    {
                        "name": "TypeScript Handbook - Type Compatibility",
                        "link": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html"
                    }
                ],
                "order": 4,
                "options": []
            },
            "Combining Types": {
                "description": "In TypeScript, you can combine types using type union and type intersection.\n\nType Union:\nThe union operator | is used to combine two or more types into a single type that represents all the possible types. For example:\n\ntype stringOrNumber = string | number;\nlet value: stringOrNumber = 'hello';\n\nvalue = 42;\nType Intersection:\nThe intersection operator & is used to intersect two or more types into a single type that represents the properties of all the types. For example:\n\ninterface A {\n  a: string;\n}\n\ninterface B {\n  b: number;\n}\n\ntype AB = A & B;\nlet value: AB = { a: 'hello', b: 42 };",
                "resources": [
                    {
                        "name": "TypeScript Handbook - Union Types",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types"
                    },
                    {
                        "name": "TypeScript Handbook - Intersection Types",
                        "link": "https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/"
                    },
                    {
                        "name": "Type Aliases",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"
                    },
                    {
                        "name": "Keyof Type Operator",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html#handbook-content"
                    }
                ],
                "order": 5,
                "options": [
                    {
                        "name": "Union Types",
                        "recommendation-type": "opinion",
                        "description": "Union Types in TypeScript allow you to specify multiple possible types for a single variable or parameter. A union type is written as a vertical bar | separated list of types.\n\nFor example, consider a function that takes either a string or a number as an argument:\n\nfunction combine(input1: string | number, input2: string | number) {\n  return input1 + input2;\n}",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - Union Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types"
                            }
                        ]
                    },
                    {
                        "name": "Intersection Types",
                        "recommendation-type": "opinion",
                        "description": "An intersection type creates a new type by combining multiple existing types. The new type has all features of the existing types.\n\nTo combine types, you use the & operator as follows:\n\ntype typeAB = typeA & typeB;\nThe typeAB will have all properties from both typeA and typeB.\n\nNote that the union type uses the | operator that defines a variable which can hold a value of either typeA or typeB.",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - Intersection Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#intersection-types"
                            }
                        ]
                    },
                    {
                        "name": "Type Aliases",
                        "recommendation-type": "opinion",
                        "description": "A Type Alias in TypeScript allows you to create a new name for a type.\n\nHere’s an example:\n\ntype Name = string;\ntype Age = number;\ntype User = { name: Name; age: Age };\n\nconst user: User = { name: 'John', age: 30 };\nIn the example above, Name and Age are type aliases for string and number respectively. And User is a type alias for an object with properties name of type Name and age of type Age.",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - Type Aliases",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"
                            }
                        ]
                    },
                    {
                        "name": "keyof Operator",
                        "recommendation-type": "opinion",
                        "description": "The keyof operator in TypeScript is used to get the union of keys from an object type. Here’s an example of how it can be used:\n\ninterface User {\n  name: string;\n  age: number;\n  location: string;\n}\n\ntype UserKeys = keyof User; // \"name\" | \"age\" | \"location\"\nconst key: UserKeys = 'name';\nIn this example, UserKeys is a type that represents the union of keys from the User interface, which is \"name\" | \"age\" | \"location\". And a constant named key with the type UserKeys is declared with the value \"name\".",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - keyof",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/keyof-types.html"
                            }
                        ]
                    }
                ]
            },
            "Type Guards / Narrowing": {
                "description": "Type guards are a way to narrow down the type of a variable. This is useful when you want to do something different depending on the type of a variable.",
                "resources": [
                    {
                        "name": "TypeScript Handbook - User-Defined Type Guards",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/guards.html"
                    }
                ],
                "order": 6,
                "options": [
                    {
                        "name": "typeof Operator",
                        "recommendation-type": "opinion",
                        "description": "The typeof operator is used to check the type of a variable. It returns a string value representing the type of the variable.\n\nlet value: string | number = 'hello';\n\nif (typeof value === 'string') {\n  console.log('value is a string');\n} else {\n  console.log('value is a number');\n}",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - typeof type guards",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards"
                            }
                        ]
                    },
                    {
                        "name": "instanceof operator",
                        "recommendation-type": "opinion",
                        "description": "The instanceof operator is a way to narrow down the type of a variable. It is used to check if an object is an instance of a class.\n\nclass Bird {\n  fly() {\n    console.log('flying...');\n  }\n  layEggs() {\n    console.log('laying eggs...');\n  }\n}\n\nconst pet = new Bird();\n\n// instanceof\nif (pet instanceof Bird) {\n  pet.fly();\n} else {\n  console.log('pet is not a bird');\n}",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - instanceof type guards",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-type-guards"
                            },
                            {
                                "name": "Equality",
                                "recommendation-type": "opinion",
                                "description": "TypeScript also uses switch statements and equality checks like ===, !==, ==, and != to narrow types. For example:\n\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // We can now call any 'string' method on 'x' or 'y'.\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\nWhen we checked that x and y are both equal in the above example, TypeScript knew their types also had to be equal. Since string is the only common type that both x and y could take on, TypeScript knows that x and y must be a string in the first branch.",
                                "resources": [
                                    {
                                        "name": "TypeScript Handbook - Equality narrowing",
                                        "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#equality-narrowing"
                                    }
                                ]
                            },
                            {
                                "name": "Truthiness",
                                "recommendation-type": "opinion",
                                "description": "Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.\n\nIn JavaScript, we can use any expression in conditionals, &&s, ||s, if statements, Boolean negations (!), and more. As an example, if statements don’t expect their condition to always have the type boolean.\n\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `There are ${numUsersOnline} online now!`;\n  }\n\n  return \"Nobody's here. :(\";\n}",
                                "resources": [
                                    {
                                        "name": "TypeScript Handbook - Truthiness narrowing",
                                        "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#truthiness-narrowing"
                                    },
                                    {
                                        "name": "Type Predicates",
                                        "recommendation-type": "opinion",
                                        "description": "Type predicates are functions that return a boolean value. They are used to narrow the type of a variable. Type predicates are used in type guards.\n\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction example(x: unknown) {\n  if (isString(x)) {\n    // We can now call any 'string' method on 'x'.\n    x.toUpperCase();\n  } else {\n    console.log(x);\n  }\n}",
                                        "resources": [
                                            {
                                                "name": "TypeScript Handbook - Type predicates",
                                                "link": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            "GTypeScript Functions": {
                "description": "Functions are a core building block in TypeScript. Functions allow you to wrap a piece of code and reuse it multiple times. Functions in TypeScript can be either declared using function declaration syntax or function expression syntax.\n\nFunction Declaration Syntax:\n\nfunction name(param1: type1, param2: type2, ...): returnType {\n  return value;\n}\nFunction Expression Syntax:\n\nlet name = function(param1: type1, param2: type2, ...): returnType {\n  return value;\n};",
                "resources": [
                    {
                        "name": "TypeScript Handbook - Functions",
                        "link": "https://www.typescriptlang.org/docs/handbook/functions.html"
                    }
                ],
                "order": 7,
                "options": [
                    {
                        "name": "Typing Functions",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, functions can be typed in a few different ways to indicate the input parameters and return type of the function.\n\nFunction declaration with types:\n\nfunction add(a: number, b: number): number {\n  return a + b;\n}\nArrow function with types:\n\nconst multiply = (a: number, b: number): number => {\n  return a * b;\n};\nFunction type:\n\nlet divide: (a: number, b: number) => number;\n\ndivide = (a, b) => {\n  return a / b;\n};",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - Functions",
                                "link": "https://www.typescriptlang.org/docs/handbook/functions.html"
                            }
                        ]
                    },
                    {
                        "name": "Function Overloading",
                        "recommendation-type": "opinion",
                        "description": "Function Overloading in TypeScript allows multiple functions with the same name but with different parameters to be defined. The correct function to call is determined based on the number, type, and order of the arguments passed to the function at runtime.\n\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\n\nfunction add(a: any, b: any): any {\n  return a + b;\n}\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add('Hello', ' World')); // \"Hello World\"",
                        "resources": [
                            {
                                "name": "TypeScript Handbook - Function Overloads",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads"
                            }
                        ]
                    }
                ]
            },
            "TypeScript Interfaces": {
                "description": "Interfaces in TypeScript provide a way to define a contract for a type, which includes a set of properties, methods, and events. It’s used to enforce a structure for an object, class, or function argument. Interfaces are not transpiled to JavaScript and are only used by TypeScript at compile-time for type-checking purposes.\n\nHere’s an example of defining and using an interface in TypeScript:\n\ninterface User {\n  name: string;\n  age: number;\n}\n\nconst user: User = {\n  name: 'John Doe',\n  age: 30,\n};",
                "resources": [
                    {
                        "name": "TypeScript Handbook - Interfaces",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/objects.html#interfaces"
                    }
                ],
                "order": 8,
                "options": [
                    {
                        "name": "Types vs Interfaces",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, both types and interfaces can be used to define the structure of objects and enforce type checks. However, there are some differences between the two.\n\nTypes are used to create a new named type based on an existing type or to combine existing types into a new type. They can be created using the type keyword. For example:\n\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst person: Person = {\n  name: 'John Doe',\n  age: 30,\n};\nInterfaces, on the other hand, are used to describe the structure of objects and classes. They can be created using the interface keyword. For example:\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst person: Person = {\n  name: 'John Doe',\n  age: 30,\n};",
                        "resources": [
                            {
                                "name": "TypeScript Deep Dive - Types vs Interfaces",
                                "link": "https://basarat.gitbook.io/typescript/type-system/types-vs-interfaces"
                            },
                            {
                                "name": "TypeScript Handbook - Type vs Interface",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/types-vs-interfaces.html"
                            },
                            {
                                "name": "Extending Interfaces",
                                "recommendation-type": "opinion",
                                "description": "In TypeScript, you can extend an interface by creating a new interface that inherits from the original interface using the “extends” keyword. The new interface can include additional properties, methods, or redefine the members of the original interface.\n\ninterface Shape {\n  width: number;\n  height: number;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square: Square = {\n  width: 10,\n  height: 10,\n  sideLength: 10,\n};\nIn this example, the Square interface extends the Shape interface and adds an additional property sideLength. A variable of type Square must have all the properties defined in both Shape and Square interfaces.",
                                "resources": [
                                    {
                                        "name": "TypeScript Handbook - Extending Interfaces",
                                        "link": "https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces"
                                    }
                                ]
                            },
                            {
                                "name": "Interface Declaration",
                                "recommendation-type": "opinion",
                                "description": "An interface in TypeScript is a blueprint for creating objects with specific structure. An interface defines a set of properties, methods, and events that a class or object must implement. The interface is a contract between objects and classes and can be used to enforce a specific structure for objects in your code.\n\nHere is an example of an interface declaration in TypeScript:\n\ninterface Person {\n  firstName: string;\n  lastName: string;\n  age?: number;\n\n  getFullName(): string;\n}\nIn this example, the Person interface defines four properties: firstName, lastName, age, and a method getFullName(). The age property is optional, indicated by the ? symbol. Any class or object that implements the Person interface must have these properties and method.",
                                "resources": [
                                    {
                                        "name": "TypeScript Handbook - Interfaces",
                                        "link": "https://www.typescriptlang.org/docs/handbook/2/objects.html#interfaces"
                                    }
                                ]
                            },
                            {
                                "name": "Hybrid Types",
                                "recommendation-type": "opinion",
                                "description": "In TypeScript, a hybrid type is a type that combines multiple types into a single type. The resulting type is considered a union of those types. This allows you to specify that a value can have multiple types, rather than just one.\n\nFor example, you can create a hybrid type that can accept either a string or a number:\n\ntype StringOrNumber = string | number;\n\nYou can also use hybrid types to create more complex types that can represent a combination of several different types of values. For example:\n\ntype Education = {\n  degree: string;\n  school: string;\n  year: number;\n};\n\ntype User = {\n  name: string;\n  age: number;\n  email: string;\n  education: Education;\n};",
                                "resources": []
                            }
                        ]
                    }
                ]
            },
            "Classes": {
                "description": "Classes in TypeScript are a blueprint for creating objects (instances of a class), providing a way to structure objects and encapsulate data and behavior. Classes in TypeScript have a similar syntax to classes in other object-oriented programming languages, such as Java and C#.\n\nA class in TypeScript is defined using the class keyword, followed by the name of the class. The class definition can include fields (also known as properties or attributes), methods (functions), and a constructor.\n\n```typescript\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  makeSound(): void {\n    console.log(`${this.name} is making a sound`);\n  }\n}\n\nconst dog = new Animal('Dog');\ndog.makeSound(); // Output: Dog is making a sound\n```\n\nIn this example, the Animal class has a name field, a constructor that sets the value of the name field, and a makeSound method. An instance of the Animal class can be created using the new keyword, and its methods and properties can be accessed using dot notation.",
                "resources": [
                    {
                        "name": "Tutorial - Classes",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html"
                    }
                ],
                "order": 9,
                "options": [
                    {
                        "name": "Constructor Params",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, constructor parameters can be declared with access modifiers (e.g. public, private, protected) and/or type annotations. The parameters are then automatically assigned to properties of the same name within the constructor, and can be accessed within the class.",
                        "resources": [
                            {
                                "name": "TypeScript - Constructors",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors"
                            }
                        ]
                    },
                    {
                        "name": "Constructor Overloading",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, you can achieve constructor overloading by using multiple constructor definitions with different parameter lists in a single class. Given below is the example where we have multiple definitions for the constructor:class Point {// Overloadsconstructor(x: number, y: string);constructor(s: string);constructor(xs: any, y?: any) {  // TBD }Note that, similar to function overloading, we only have one implementation of the consructor and it’s the only the signature that is overloaded.",
                        "resources": [
                            {
                                "name": "Constructors - TypeScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors"
                            }
                        ]
                    },
                    {
                        "name": "Access Modifiers",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, access modifiers are keywords used to control the visibility and accessibility of class properties and methods. There are three access modifiers in TypeScript:public: This is the default access modifier. Properties and methods declared as public can be accessed from anywhere, both inside and outside the class.private: Properties and methods declared as private can only be accessed within the same class. They are not accessible from outside the class.protected: Properties and methods declared as protected can be accessed within the class and its subclasses. They are not accessible from outside the class and its subclasses.Access modifiers in TypeScript allow you to define the level of visibility and accessibility of properties and methods in your class, making your code more maintainable and secure.",
                        "resources": [
                            {
                                "name": "TypeScript Access Modifiers",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#access-modifiers"
                            }
                        ]
                    },
                    {
                        "name": "Abstract Classes",
                        "recommendation-type": "opinion",
                        "description": "Abstract classes in TypeScript are classes that cannot be instantiated on their own and must be subclassed by other classes. Abstract classes provide a blueprint for other classes and can have abstract methods, which are methods without a body and must be overridden by the subclass. These classes are useful for defining a common interface or basic functionality that other classes can inherit and build upon.",
                        "resources": [
                            {
                                "name": "Abstract Classes",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes"
                            }
                        ]
                    },
                    {
                        "name": "Inheritance vs Polymorphism",
                        "recommendation-type": "opinion",
                        "description": "Inheritance and polymorphism are two fundamental concepts in object-oriented programming, and they are supported in TypeScript as well.Inheritance refers to a mechanism where a subclass inherits properties and methods from its parent class. This allows a subclass to reuse the code and behavior of its parent class while also adding or modifying its ownbehavior. In TypeScript, inheritance is achieved using the extends keyword.Polymorphism refers to the ability of an object to take on many forms. This allows objects of different classes to be treated as objects of a common class, as long as they share a common interface or inheritance hierarchy. In TypeScript, polymorphism is achieved through method overriding and method overloading.",
                        "resources": [
                            {
                                "name": "Inheritance and Polymorphism In TypeScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#inheritance-and-polymorphism"
                            }
                        ]
                    },
                    {
                        "name": "Method Overriding",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, method overriding is a mechanism where a subclass provides a new implementation for a method that is already defined in its parent class. This allows the subclass to inherit the behavior of the parent class, but change its behavior to fit its own needs. To override a method in TypeScript, the signature of the method in the subclass must match exactly with the signature of the method in the parent class. In this example, the Dog class overrides the makeSound method defined in the Animal class and provides its own implementation. When the makeSound method is called on an instance of the Dog class, it will use the implementation in the Dog class rather than the implementation in the Animal class.",
                        "resources": [
                            {
                                "name": "TypeScript - Overriding Methods",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/classes.html#overriding-methods"
                            }
                        ]
                    }
                ]
            },
            "Generics": {
                "description": "Generics in TypeScript are a way to write code that can work with multiple data types, instead of being limited to a single data type. Generics allow you to write functions, classes, and interfaces that take one or more type parameters, which act as placeholders for the actual data types that will be used when the function, class, or interface is used.\n\nFor example, the following is a generic function that takes a single argument of any data type and returns the same data type:\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet output = identity<string>('Hello'); // type of output will be 'string'\nIn this example, the identity function takes a single argument of any data type and returns the same data type. The actual data type is specified when the function is called by using <string> before the argument Hello",
                "resources": [
                    {
                        "name": "Hello World of Generics",
                        "link": "https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics"
                    },
                    {
                        "name": "TypeScript - Roadmap",
                        "link": "https://roadmap.sh/typescript#:~:text=Update%20Status-,Decorators,Decorators,-Help%20others%20learn"
                    }
                ],
                "order": 10,
                "options": [
                    {
                        "name": "Generic Types",
                        "recommendation-type": "opinion",
                        "description": "Generic types in TypeScript allow you to write objects, functions and classes that work with multiple data types, instead of being limited to a single data type. A generic type is defined using angle brackets <T> and can be used as a placeholder for a specific data type. The actual data type is specified when the function or class is used.For example, the following is a generic function that takes a single argument of any data type and returns the same data typfunction identity<T>(arg: T): T {return arg;}let output = identity<string>('Hello'); // type of output will be 'string'In this example, the identity function takes a single argument of any data type and returns the same data type. The actual data type is specified when the function is called by using <string> before the argument Hello.Generics can also be used with classes, interfaces, and object types, allowing them to work with multiple data types as well.class GenericNumber<T> { zeroValue: T;add: (x: T, y: T) => T;}let myGenericNumber = new GenericNumber<number>();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) {return x + y;};",
                        "resources": [
                            {
                                "name": "Hello World of Generics",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics"
                            }
                        ]
                    },
                    {
                        "name": "Generic Constraints",
                        "recommendation-type": "opinion",
                        "description": "Generic constraints in TypeScript allow you to specify the requirements for the type parameters used in a generic type. These constraints ensure that the type parameter used in a generic type meets certain requirements.Constraints are specified using the extends keyword, followed by the type that the type parameter must extend or implement.interface Lengthwise {length: number;}function loggingIdentity<T extends Lengthwise>(arg: T): T {// Now we know it has a .length property, so no more errorconsole.log(arg.length);return arg;}loggingIdentity(3); // Error, number doesn't have a .length propertyloggingIdentity({ length: 10, value: 3 }); // OK In this example, the Lengthwise interface defines a length property. The loggingIdentity function uses a generic type parameter T that isconstrained by the Lengthwise interface, meaning that the type parameter must extend or implement the Lengthwise interface. This constrainensures that the length property is available on the argument passed to the loggingIdentity function.",
                        "resources": [
                            {
                                "name": "Generic Constraints - TypeScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints"
                            }
                        ]
                    }
                ]
            },
            "Decorators": {
                "description": "Decorators are a feature of TypeScript that allow you to modify the behavior of a class, property, method, or parameter. They are a way to add additional functionality to existing code, and they can be used for a wide range of tasks, including logging, performance optimization, and validation.\n\nHere’s an example of how you might use a decorator in TypeScript:\n\n```typescript\nfunction log(\n  target: Object,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey} with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nclass Calculator {\n  @log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nconst calculator = new Calculator();\ncalculator.add(1, 2);\n// Output: Calling add with arguments: 1,2\n// Output: 3\n```\n\nIn this example, we use the @log decorator to modify the behavior of the add method in the Calculator class. The log decorator logs the arguments passed to the method before calling the original method. This allows us to see what arguments are being passed to the method, without having to modify the method’s code.",
                "resources": [
                    {
                        "name": "Decorators",
                        "link": "https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content"
                    }
                ],
                "order": 11,
                "options": []
            },
            "Utility Types": {
                "description": "TypeScript provides several utility types that can be used to manipulate and transform existing types. Here are some of the most common ones:\n\n- Partial: makes all properties of a type optional.\n- Readonly: makes all properties of a type read-only.\n- Pick: allows you to pick specific properties from a type.\n- Omit: allows you to omit specific properties from a type.\n- Exclude: creates a type that is the set difference of A and B.\n- ..and more.",
                "resources": [
                    {
                        "name": "TypeScript - Utility Types",
                        "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html"
                    }
                ],
                "order": 12,
                "options": [
                    {
                        "name": "Partial",
                        "recommendation-type": "opinion",
                        "description": "The Partial type in TypeScript allows you to make all properties of a type optional. This is useful when you need to create an object with only a subset of the properties of an existing type.",
                        "resources": [
                            {
                                "name": "Partial",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype"
                            }
                        ]
                    },
                    {
                        "name": "Pick",
                        "recommendation-type": "opinion",
                        "description": "Pick constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.",
                        "resources": [
                            {
                                "name": "Pick<Type, Keys>",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys"
                            }
                        ]
                    },
                    {
                        "name": "Omit",
                        "recommendation-type": "opinion",
                        "description": "Omit constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).",
                        "resources": [
                            {
                                "name": "Omit<Type, Keys>",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys"
                            }
                        ]
                    },
                    {
                        "name": "Readonly",
                        "recommendation-type": "opinion",
                        "description": "Readonly constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.",
                        "resources": [
                            {
                                "name": "Readonly",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype"
                            }
                        ]
                    },
                    {
                        "name": "Record",
                        "recommendation-type": "opinion",
                        "description": "Record constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.",
                        "resources": [
                            {
                                "name": "Record<Keys, Type>",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeystype"
                            }
                        ]
                    },
                    {
                        "name": "Exclude",
                        "recommendation-type": "opinion",
                        "description": "Exclude constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.",
                        "resources": [
                            {
                                "name": "Exclude<UnionType, ExcludedMembers>",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#excludetype-excludedmembers"
                            }
                        ]
                    },
                    {
                        "name": "Extract",
                        "recommendation-type": "opinion",
                        "description": "Extract constructs a type by extracting from Type all union members that are assignable to Union.",
                        "resources": [
                            {
                                "name": "Extract<Type, Union>",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union"
                            }
                        ]
                    },
                    {
                        "name": "NonNullable",
                        "recommendation-type": "opinion",
                        "description": "Non-Nullable constructs a type by excluding null and undefined from Type.",
                        "resources": [
                            {
                                "name": "NonNullable",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullable"
                            }
                        ]
                    },
                    {
                        "name": "Parameters",
                        "recommendation-type": "opinion",
                        "description": "Parameters constructs a tuple type from the types used in the parameters of a function type Type.",
                        "resources": [
                            {
                                "name": "Parameters",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#parameters"
                            }
                        ]
                    },
                    {
                        "name": "ReturnType",
                        "recommendation-type": "opinion",
                        "description": "Return type constructs a type consisting of the return type of function Type.",
                        "resources": [
                            {
                                "name": "ReturnType",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#returntype"
                            }
                        ]
                    },
                    {
                        "name": "InstanceType",
                        "recommendation-type": "opinion",
                        "description": "This type constructs a type consisting of the instance type of a constructor function in Type.",
                        "resources": [
                            {
                                "name": "InstanceType",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetype"
                            }
                        ]
                    },
                    {
                        "name": "Awaited",
                        "recommendation-type": "opinion",
                        "description": "This type is meant to model operations like await in async functions, or the .then() method on Promises - specifically, the way that they recursively unwrap Promises.",
                        "resources": [
                            {
                                "name": "Awaited",
                                "link": "https://www.typescriptlang.org/docs/handbook/utility-types.html#awaited"
                            }
                        ]
                    }
                ]
            },
            "Advanced Types": {
                "description": "Advanced types in TypeScript are a set of advanced type constructs that allow for more complex and expressive type systems. Some of the most commonly used advanced types in TypeScript include:\n\n- Intersection Types\n- Union Types\n- Type Aliases\n- Conditional Types\n- Index Types\n- Mapped Types\n- Type Guards\n\nThese advanced types allow for more complex and expressive type systems, and enable you to write code that is safer, more maintainable, and easier to understand. By leveraging these advanced types, you can write code that is more robust, less prone to errors, and easier to maintain.",
                "resources": [
                    {
                        "name": "Advanced Topics",
                        "link": ""
                    },
                    {
                        "name": "Tutorial of Typescript - Advanced Types",
                        "link": ""
                    }
                ],
                "order": 13,
                "options": [
                    {
                        "name": "Mapped Types",
                        "recommendation-type": "opinion",
                        "description": "Mapped types in TypeScript are a way to create a new type based on an existing type, where each property of the existing type is transformed in some way. Mapped types are declared using a combination of the keyof operator and a type that maps each property of the existing type to a new property type. For example, the following is a mapped type that takes an object type and creates a new type with all properties of the original type but with their type changed to readonly:",
                        "resources": [
                            {
                                "name": "Mapped Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"
                            }
                        ]
                    },
                    {
                        "name": "Conditional Types",
                        "recommendation-type": "opinion",
                        "description": "Conditional types in TypeScript are a way to select a type based on a condition. They allow you to write a type that dynamically chooses a type based on the types of its inputs. Conditional types are declared using a combination of the infer keyword and a type that tests a condition and selects a type based on the result of the test. For example, the following is a conditional type that takes two types and returns the type of the first argument if it extends the second argument, and the type of the second argument otherwise:",
                        "resources": [
                            {
                                "name": "Conditional Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
                            },
                            {
                                "name": "Conditional Types - Advanced TypeScript",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#advanced-conditional-types"
                            }
                        ]
                    },
                    {
                        "name": "Literal Types",
                        "recommendation-type": "opinion",
                        "description": "Literal types in TypeScript are a way to specify a value exactly, rather than just a type. Literal types can be used to enforce that a value must be of a specific type and a specific value. Literal types are created by using a literal value, such as a string, number, or boolean, as a type. For example, the following is a literal type that represents a value of 42:",
                        "resources": [
                            {
                                "name": "Literal Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/literal-types.html"
                            }
                        ]
                    },
                    {
                        "name": "Template Literal Types",
                        "recommendation-type": "opinion",
                        "description": "Template literal types in TypeScript are a way to manipulate string values as types. They allow you to create a type based on the result of manipulation or concatenation. Template literal types are created using the backtick (`) character and string manipulation expressions within the type. For example, the following is a template literal type that concatenates two strings:type Name = `Mr. ${string}`;let name: Name = `Mr. Smith`;  // oklet name: Name = `Mrs. Smith`;  // errorIn this example, the Name template literal type is created by concatenating the string Mr with the type string. This type can then be used to enforce that a value must be a string that starts with Mr.",
                        "resources": [
                            {
                                "name": "Template Literal Types",
                                "link": "https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html"
                            }
                        ]
                    },
                    {
                        "name": "Recursive Types",
                        "recommendation-type": "opinion",
                        "description": "Recursive types in TypeScript are a way to define a type that references itself. Recursive types are used to define complex data structures, such as trees or linked lists, where a value can contain one or more values of the same type. For example, the following is a recursive type that represents a linked list:type LinkedList<T> = { value: T;next: LinkedList<T> | null;}; let list: LinkedList<number> = { value: 1, next: { value: 2, next: { value: 3, next: null } }, };In this example, the LinkedList type is defined as a type that extends T and contains a property next of the same type LinkedList<T>. This allows us to create a linked list where each node contains a value of type T and a reference to the next node in the list.",
                        "resources": []
                    }
                ]
            },
            "TypeScript Modules": {
                "description": "In TypeScript, modules are used to organize and reuse code. There are two types of modules in TypeScript:\n\n- Internal\n- External\n\nInternal modules are used to organize code within a file and are also referred to as namespaces. They are defined using the “namespace” keyword.\n\nExternal modules are used to organize code across multiple files. They are defined using the “export” keyword in one file and the “import” keyword in another file. External modules in TypeScript follow the CommonJS or ES modules standards.",
                "resources": [
                    {
                        "name": "Modules",
                        "link": ""
                    },
                    {
                        "name": "TypeScript - Modules",
                        "link": ""
                    }
                ],
                "order": 14,
                "options": [
                    {
                        "name": "External Modules",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, external modules allow you to organize and share code across multiple files. External modules in TypeScript follow the CommonJS or ES modules standards.Here’s an example of how you can use external modules in TypeScript:// myModule.tsexport function doSomething() {  console.log('Doing something...');}// main.tsimport { doSomething } from './myModule';doSomething(); // Output: Doing something...In this example, we use the “export” keyword in the “myModule.ts” file to export the “doSomething” function, making it available for other files to use.",
                        "resources": [
                            {
                                "name": "External Module",
                                "link": "https://www.javatpoint.com/typescript-module"
                            },
                            {
                                "name": "TypeScript - External Module",
                                "link": "https://learncodeweb.com/typescript/modules-in-typescript-explain-with-an-example/"
                            }
                        ]
                    },
                    {
                        "name": "Ambient Modules",
                        "recommendation-type": "opinion",
                        "description": "Ambient modules in TypeScript are used to declare external modules or third-party libraries in a TypeScript program. Ambient modules provide type information for modules that have no TypeScript declarations, but are available in the global scope.Here’s an example of how you can use ambient modules in TypeScript:// myModule.d.tsdeclare module 'my-module' {export function doSomething(): void;}// main.tsimport * as myModule from 'my-module';myModule.doSomething();In this example, we declare an ambient module “my-module” in the myModule.d.ts file. This declaration provides type information for the “my-module” module, including the “doSomething” function that is exported from the module.",
                        "resources": [
                            {
                                "name": "Ambient Modules",
                                "link": "https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules"
                            }
                        ]
                    },
                    {
                        "name": "Namespaces",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, namespaces are used to organize and share code across multiple files. Namespaces allow you to group related functionality into a single unit and prevent naming conflicts.Here’s an example of how you can use namespaces in TypeScript:// myNamespace.tsnamespace MyNamespace {export function doSomething() {console.log('Doing something...');}}// main.ts/// <reference path= myNamespace.ts />MyNamespace.doSomething(); // Output: Doing something...In this example, we use the namespace keyword in the “myNamespace.ts” file to define a namespace “MyNamespace”. Within the namespace, we export a function “doSomething”.",
                        "resources": [
                            {
                                "name": "Overview of Namespaces",
                                "link": "https://www.typescriptlang.org/docs/handbook/namespaces.html"
                            },
                            {
                                "name": "Namespaces and Modules",
                                "link": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html"
                            },
                            {
                                "name": "TypeScript - Using Namespaces",
                                "link": "https://typescriptlang.org/docs/handbook/namespaces-and-modules.html#using-namespaces"
                            }
                        ]
                    },
                    {
                        "name": "Namespace Augmentation",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, namespace augmentation is a way to extend or modify existing namespaces. This is useful when you want to add new functionality to existing namespaces or to fix missing or incorrect declarations in third-party libraries.\nHere’s an example of how you can use global augmentation in TypeScript:\n// myModule.d.tsdeclare namespace NodeJS {interface Global { myGlobalFunction(): void;}// main.tsglobal.myGlobalFunction = function () { console.log('I am a global function!');};myGlobalFunction(); // Output: I am a global function!\nIn this example, we declare a new namespace “NodeJS” and add an interface “Global” to it. Within the “Global” interface, we declare a new function “myGlobalFunction”.",
                        "resources": [
                            {
                                "name": "Module Augmentation",
                                "link": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation"
                            }
                        ]
                    },
                    {
                        "name": "Global Augmentation",
                        "recommendation-type": "opinion",
                        "description": "In TypeScript, global augmentation is a way to add declarations to the global scope. This is useful when you want to add new functionality to existing libraries or to augment the built-in types in TypeScript.\n// myModule.d.tsdeclare namespace NodeJS {interface Global {myGlobalFunction(): void;}} // main.ts global.myGlobalFunction = function () {console.log('I am a global function!');}myGlobalFunction(); // Output: I am a global function!In this example, we declare a new namespace “NodeJS” and add an interface “Global” to it. Within the “Global” interface, we declare a new function “myGlobalFunction”.",
                        "resources": [
                            {
                                "name": "Global augmentation",
                                "link": "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation"
                            }
                        ]
                    }
                ]
            },
            "Ecosystem": {
                "description": "Have a look at the linked nodes for different tools and frameworks that you can use to build your projects. ",
                "resources": [],
                "order": 15,
                "options": [
                    {
                        "name": "Formatting",
                        "recommendation-type": "opinion",
                        "description": "Prettier is an opinionated code formatter with support for JavaScript, HTML, CSS, YAML, Markdown, GraphQL Schemas. By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles.",
                        "resources": [
                            {
                                "name": "Prettier Website",
                                "link": "https://prettier.io/"
                            },
                            {
                                "name": "Why Prettier",
                                "link": "https://prettier.io/docs/en/why-prettier.html"
                            }
                        ]
                    },
                    {
                        "name": "Linting",
                        "recommendation-type": "opinion",
                        "description": "With ESLint, you can impose the coding standard using a certain set of standalone rules.",
                        "resources": [
                            {
                                "name": "ESLint Official Website",
                                "link": "https://eslint.org/"
                            },
                            {
                                "name": "Introduction to ESLint",
                                "link": "https://dev.to/shivambmgupta/eslint-what-why-when-how-5f1d"
                            },
                            {
                                "name": "ESLint Quickstart - find errors automatically",
                                "link": "https://www.youtube.com/watch?v=qhuFviJn-es"
                            }
                        ]
                    },
                    {
                        "name": "Useful Packages",
                        "recommendation-type": "opinion",
                        "description": "TypeScript has a large ecosystem of packages that can be used to extend the language or to add functionality to your project. Here is a list of some of the most useful packages.",
                        "resources": [
                            {
                                "name": "zod",
                                "link": ""
                            },
                            {
                                "name": "ts-morph",
                                "link": ""
                            },
                            {
                                "name": "ts-node",
                                "link": ""
                            },
                            {
                                "name": "ts-jest",
                                "link": ""
                            },
                            {
                                "name": "typesync",
                                "link": ""
                            },
                            {
                                "name": "tsd - TypeScript Definition Manager",
                                "link": ""
                            },
                            {
                                "name": "type-fest - A collection of essential TypeScript types",
                                "link": ""
                            }
                        ]
                    },
                    {
                        "name": "Build Tools",
                        "recommendation-type": "opinion",
                        "description": "Task runners automatically execute commands and carry out processes behind the scenes. This helps automate your workflow by performing mundane, repetitive tasks that you would otherwise waste an egregious amount of time repeating yourself.Common usages of task runners include numerous development tasks such as: spinning up development servers, compiling code (ex. SCSS to CSS), running linters, serving files up from a local port on your computer, and many more!",
                        "resources": [
                            {
                                "name": "webpack",
                                "link": "https://webpack.js.org/"
                            },
                            {
                                "name": "Vite - Next Generation Frontend Tooling",
                                "link": "https://vitejs.dev/"
                            },
                            {
                                "name": "Parcel - a zero configuration build tool for the web",
                                "link": "https://parceljs.org/"
                            },
                            {
                                "name": "esbuild - an extremely fast JavaScript bundler and minifier",
                                "link": "https://esbuild.github.io/"
                            },
                            {
                                "name": "swc - a super-fast compiler written in Rust",
                                "link": "https://swc.rs/"
                            },
                            {
                                "name": "tsup - a zero-config TypeScript build tool",
                                "link": "https://tsup.egoist.sh/"
                            },
                            {
                                "name": "Rollup - a module bundler for JavaScript",
                                "link": "https://rollupjs.org/guide/en/"
                            },
                            {
                                "name": "tsdx - a zero-config CLI for TypeScript package development",
                                "link": "https://tsdx.io/"
                            }
                        ]
                    }
                ]
            }
        }
    }
}