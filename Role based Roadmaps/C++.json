{
  "roles": {
    "C++": {
      "Introduction to the Language": {
        "description": "C++ is a general-purpose, high-performance programming language developed by Bjarne Stroustrup at Bell Labs starting in 1979. It is an extension of the C programming language, adding features such as classes, objects, and exceptions. Here's a brief overview of the basics of C++ programming:\n\n**Including Libraries:**\nIn C++, we use the #include directive to include libraries or header files into our program. For example, to include the standard input/output library, we write:\n```cpp\n#include <iostream>\n```\n\n**Main Function:**\nThe entry point of a C++ program is the main function. Every C++ program must have a main function:\n```cpp\nint main() {\n    // Your code goes here\n    return 0;\n}\n```\n\n**Input/Output:**\nTo perform input and output operations in C++, we can use the built-in objects std::cin for input and std::cout for output, available in the iostream library.\n\n**Variables and Data Types:**\nC++ has several basic data types for representing integer, floating-point, and character values.\n\n**Control Structures:**\nC++ provides control structures for conditional execution and iteration, such as if, else, while, for, and switch statements.\n\n**Functions:**\nFunctions are reusable blocks of code that can be called with arguments to perform a specific task. Functions are defined with a return type, a name, a parameter list, and a body.\n\nThis basic introduction to C++ should provide you with a good foundation for further learning. Explore more topics such as classes, objects, inheritance, polymorphism, templates, and the Standard Template Library (STL) to deepen your understanding of C++ and start writing more advanced programs.",
        "resources": [
          {
            "name": "Learn C++",
            "link": "https://www.learncpp.com/"
          },
          {
            "name": "C++ Full Course by freeCodeCamp",
            "link": "https://youtu.be/vLnPwxZdW4Y"
          }
        ],
        "order": 1,
        "options": [
          {
            "name": "What is C++?",
            "recommendation-type": "Start with these",
            "description": "C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language. It was first introduced in 1985 and provides object-oriented features like classes and inheritance. C++ is widely used in various applications like game development, system programming, embedded systems, and high-performance computing.\n\nC++ is a statically-typed language, meaning that the type of a variable is determined during compilation, and has an extensive library called the C++ Standard Library, which provides a rich set of functions, algorithms, and data structures for various tasks.\n\nC++ builds upon the features of C, and thus, most C programs can be compiled and run with a C++ compiler.\n\n**Code Example**\nHere’s a simple example of a C++ program that demonstrates some essential features of the language:\n\n```cpp\n#include <iostream>\n\n// A simple function to add two numbers\nint add(int a, int b) {\n    return a + b;\n}\n\nclass Calculator {\npublic:\n    // A member function to multiply two numbers\n    int multiply(int a, int b) {\n        return a * b;\n    }\n};\n\nint main() {\n    int x = 5;\n    int y = 3;\n\n    // Using the standalone function 'add'\n    int sum = add(x, y);\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    // Using a class and member function\n    Calculator calc;\n    int product = calc.multiply(x, y);\n    std::cout << \"Product: \" << product << std::endl;\n\n    return 0;\n}\n```\nIn the above program, we define a simple function add and a class Calculator with a member function multiply. The main function demonstrates how to use these to perform basic arithmetic.",
            "resources": [
              {
                "name": "C++ Tutorial for Beginners - Full Course",
                "link": "https://youtu.be/vLnPwxZdW4Y"
              },
              {
                "name": "w3schools C++ tutorial",
                "link": "https://www.w3schools.com/cpp/"
              },
              {
                "name": "Learn C++",
                "link": "https://www.learncpp.com/"
              }
            ]
          },
          {
            "name": "Why C++",
            "recommendation-type": "Start with these",
            "description": "C++ is a popular and widely used programming language for various reasons. Here are some of the reasons why you might choose to utilize C++:\n\n**Performance:**\nC++ is designed to provide high performance and efficiency. It offers fine-grained control over system resources, making it easier to optimize your software.\n\n**Portability:**\nC++ is supported on different computer architectures and operating systems, allowing you to write portable code that runs on various platforms without making major modifications.\n\n**Object-Oriented Programming:**\nC++ supports object-oriented programming (OOP) - a paradigm that allows you to design programs using classes and objects, leading to better code organization and reusability.\n\n```cpp\n#include <iostream>\n\nclass MyClass {\npublic:\n    void myFunction() {\n        // Code here\n    }\n};\n\nint main() {\n    MyClass obj;\n    obj.myFunction();\n}\n```\n\n**Support for low-level and high-level programming:**\nC++ allows you to write both low-level code, like memory manipulation, as well as high-level abstractions, like creating classes and using the Standard Template Library (STL).\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    // Low-level programming\n    int number = 42;\n    int* ptr_number = &number;\n\n    // High-level programming\n    std::vector<int> myVector = {1, 2, 3};\n    for(const auto &i: myVector) {\n        std::cout << i << std::endl;\n    }\n}\n```\n\n**Extensive Libraries:**\nC++ offers a vast range of libraries and tools, such as the Standard Template Library (STL), Boost, and Qt, among others, that can aid in the development of your projects and make it more efficient.\n\n**Combination with C language:**\nC++ can be combined with C, offering the capabilities of both languages and allowing you to reuse your existing C code. By incorporating C++ features, you can enhance your code and improve its functionality.\n\n**Active Community:**\nC++ has been around for a long time and has a large, active community of users who contribute to the growth of the language, express new ideas, and engage in discussions that help develop the language further. This makes finding solutions to any problems you experience much easier.\n\nIn summary, C++ offers a great balance of performance, portability, and feature set, making it a versatile and powerful programming language suitable for many applications. With its extensive libraries, active community, and continuous development, C++ is an excellent choice for any software development project.",
            "resources": []
          },
          {
            "name": "C vs C++",
            "recommendation-type": "Start with these",
            "description": "C and C++ are two popular programming languages with some similarities, but they also have key differences. C++ is an extension of the C programming language, with added features such as object-oriented programming, classes, and exception handling. Although both languages are used for similar tasks, they have their own syntax and semantics, which makes them distinct from each other.\n\n**Syntax and Semantics:**\n\n**C**\n- Procedural programming language\n- Focuses on functions and structured programming\n- Does not support objects or classes\n- Manual memory management using functions like malloc and free.\n\n```c\n#include <stdio.h>\n\nvoid printHello() {\n    printf(\"Hello, World!\\n\");\n}\n\nint main() {\n    printHello();\n    return 0;\n}\n```\n\n**C++**\n- Both procedural and object-oriented\n- Supports both functions and classes\n- Incorporates different programming paradigms\n- Memory management can be manual (like C) or rely on constructors/destructors and smart pointers.\n\n```cpp\n#include <iostream>\n\nclass HelloWorld {\npublic:\n    void printHello() {\n        std::cout << \"Hello, World!\" << std::endl;\n    }\n};\n\nint main() {\n    HelloWorld obj;\n    obj.printHello();\n    return 0;\n}\n```\n\n**Code Reusability and Modularity:**\n\n**C**\n- Code reusability is achieved through functions and modular programming.\n- High cohesion and low coupling are achieved via structured design.\n- Function libraries can be created and included through headers.\n\n**C++**\n- Offers better code reusability with classes, inheritance, and polymorphism.\n- Code modularity is enhanced through namespaces and well-designed object-oriented hierarchy.\n\n**Error Handling:**\n\n**C**\n- Error handling in C is done primarily through return codes.\n- Lacks support for exceptions or any built-in error handling mechanism.\n\n**C++**\n- Offers exception handling, which can be used to handle errors that may occur during program execution.\n- Enables catching and handling exceptions with try, catch, and throw keywords, providing more control over error handling.\n\n**Conclusion:**\nBoth C and C++ are powerful languages with unique features and capabilities. While C is simpler and focuses on procedural programming, C++ offers the versatility of using different programming paradigms and improved code organization. Understanding the differences between these two languages can help you decide which one is more suitable for your specific needs and programming style.",
            "resources": []
          }
        ]
      },
      "Setting Up your Environment": {
        "description": "Setting up C++ involves a few steps, including installing a compiler, configuring an Integrated Development Environment (IDE), and creating a new C++ project.\n\n**Installing a Compiler:**\nA compiler is required to convert C++ code into machine language. Some popular C++ compilers include GCC, MinGW, and Microsoft Visual C++. Follow the instructions provided by the respective websites to install a compiler.\n\n**Configuring an IDE:**\nAn IDE is a software application that provides facilities for programming, such as code editing, debugging, and building. Popular C++ IDEs include Visual Studio, Eclipse, and Code::Blocks. After installing an IDE, configure it to use the installed compiler by referring to the documentation.\n\n**Creating a New C++ Project:**\nOnce you have your IDE and compiler set up, create a new C++ project by following these general steps:\n1. Open the IDE and create a new project.\n2. Select the project type (C++ Application or Console Application).\n3. Specify the project name and location.\n4. Let the IDE generate the main.cpp and build files (such as Makefile or CMakeLists.txt) for you.\n\n**Example: Hello World in C++:**\nCreate a new file called main.cpp within your project and include this code:\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}\n```\nFollow the IDE’s instructions to build and run your program. You should see “Hello, World!” displayed in the console.\n\n**Summary:**\nSetting up C++ involves installing a compiler, configuring an IDE, and creating a new C++ project. By following these steps, you’ll be ready to start developing C++ applications!",
        "resources": [
          {
            "name": "Installing C++",
            "recommendation-type": "Start with these",
            "description": "Before you can start programming in C++, you will need to have a compiler installed on your system. A compiler is a program that converts the C++ code you write into an executable file that your computer can run. There are several popular C++ compilers to choose from, depending on your operating system and preference.\n\n**Windows:**\nFor Windows, you can install the Microsoft Visual Studio IDE, which includes the Microsoft Visual C++ compiler. Alternatively, you can install the MinGW-w64 compiler, a Windows port of the GNU Compiler Collection (GCC).\n\n**macOS:**\nOn macOS, you can install the Apple LLVM clang compiler, part of the Xcode Command Line Tools. Open a terminal and enter:\n```bash\nxcode-select --install\n```\n\n**Linux:**\nOn Linux, install the GNU Compiler Collection (GCC) through your distribution’s package manager. For example, on Ubuntu, Debian, and derivatives:\n```bash\nsudo apt-get install g++ build-essential\n```\nChecking the Installation:\nTo confirm that the compiler is installed and available on your system, open a terminal/command prompt and enter:\n```bash\ng++ --version\n```\nYou should see output displaying the version of your installed C++ compiler. Now you’re ready to start writing and compiling your C++ code!",
            "resources": []
          },
          {
            "name": "Code Editors",
            "recommendation-type": "Start with these",
            "description": "Code editors are programs specifically designed for editing, managing, and writing source code. They offer a wide range of features that make the development process easier and faster. Here’s a brief introduction to some of the most popular code editors for C++:\n\n**Visual Studio Code (VSCode):**\nA popular, free, open-source, and lightweight code editor developed by Microsoft. It has built-in support for C++, along with an extensive library of extensions and plugins.\n\n**Sublime Text:**\nA cross-platform text editor known for its speed and minimalist design. It supports C++ with the help of plugins and has a variety of themes and packages available for customization.\n\n**CLion:**\nAn Integrated Development Environment (IDE) developed by JetBrains specifically for C and C++ developers. It provides advanced features like code completion, refactoring support, debugging, and more.\n\nThese are just a few examples, and there are many other code editors available, including Atom, Notepad++, and Geany. Finding the right code editor is often a matter of personal preference and workflow.\n\nTo work with C++ in your chosen code editor, you often need to install some additional tools and add-ons, such as compilers, linters, and debugger support. Make sure to follow the instructions provided in the editor’s documentation to set up C++ correctly.",
            "resources": []
          },
          {
            "name": "Using C++ on Linux in VSCode",
            "recommendation-type": "Start with these",
            "description": "To use C++ on Linux in Visual Studio Code (VSCode), you need to follow a few steps to set up your development environment. Ensure that you have a C++ compiler installed on your Linux system. The steps may vary depending on your distribution, so consult your package manager for installation instructions. Additionally, you'll need to install Visual Studio Code and the C/C++ extension.\n\nHere's a basic guide:\n1. Install a C++ compiler using your package manager. For example, on Ubuntu:\n```bash\nsudo apt-get install g++\n```\n2. Install Visual Studio Code. Refer to the official website or use your package manager.\n3. Open Visual Studio Code and install the C/C++ extension from the Visual Studio Code marketplace.\n4. Create a new C++ file or open an existing one.\n5. Write your C++ code.\n6. Use the integrated terminal in VSCode to compile and run your program.\n\nEnsure that you configure your VSCode settings appropriately, specifying the compiler path and other necessary configurations. VSCode will prompt you to install additional tools if needed.\n\nBy following these steps, you can seamlessly use C++ on Linux in Visual Studio Code for your development projects!",
            "resources": []
          },
          {
            "name": "First Program in C++",
            "recommendation-type": "Start with these",
            "description": "In this section, we’ll discuss the basic structure of a C++ program, walk you through your first program (the “Hello, World!” example), and provide additional explanations of its syntax.\n\n**Hello, World!:**\nThe first program that most people learn to write in any programming language is often a simple one that displays the message “Hello, World!” on the screen. Here’s the classic “Hello, World!” program in C++:\n```cpp\n#include <iostream>\n\nint main() {\n  std::cout << \"Hello, World!\" << std::endl;\n  return 0;\n}\n```\nLet’s break down the different components of this program:\n\n**Header Files & Preprocessor Directives:**\nThe first line of the program `#include <iostream>` is a preprocessor directive that tells the compiler to include the header file iostream. Header files provide function and class declarations that we can use in our C++ programs.\n\n**main() Function:**\nIn C++, the main() function serves as the entry point of your program. The operating system runs your program by calling this main() function. It should be defined only once in your program and must return an integer.\n\n**Output to the Console:**\nTo output text to the console, we use the std::cout object and the insertion operator <<. In the “Hello, World!” example, we used the following line to print “Hello, World!” to the console:\n```cpp\nstd::cout << \"Hello, World!\" << std::endl;\n```\n\n**Return Statement:**\nLastly, the `return 0;` statement informs the operating system that the program executed successfully. Returning any other integer value indicates that an error occurred:\n```cpp\nreturn 0;\n```\nNow that you understand the basic components of a C++ program, you can write your first program, compile it, and run it to see the “Hello, World!” message displayed on the screen.",
            "resources": []
          }
        ],
        "order": 2,
        "options": []
      },
      "Basic Operations": {
        "description": "Basic operations in C++ refer to the fundamental arithmetic, relational, and logical operations that can be performed using C++ programming language, which are essential for any kind of program or calculation in a real-world scenario.\n\n**Arithmetic Operations:**\nThese operations are used for performing calculations in C++. Examples include:\n- Addition (+)\n- Subtraction (-)\n- Multiplication (*)\n- Division (/)\n- Modulus (%)\n\n**Relational Operators:**\nThese operations compare two values and return a boolean value (true/false) depending on the comparison. Examples include:\n- Equal to (==)\n- Not equal to (!=)\n- Greater than (>)\n- Less than (<)\n- Greater than or equal to (>=)\n- Less than or equal to (<=)\n\n**Logical Operators:**\nLogical operators are used for combining multiple conditions or boolean values. Examples include:\n- AND (&&)\n- OR (||)\n- NOT (!)\n\nThese basic operations form the building blocks of more complex algorithms and logic in C++ programming.",
        "resources": [
          {
            "name": "Arithmetic Operators in C++",
            "recommendation-type": "Start with these",
            "description": "Arithmetic operators are used to perform mathematical operations with basic variables such as integers and floating-point numbers. Here is a brief summary of the different arithmetic operators in C++:\n\n1. **Addition Operator (+):** Adds two numbers together.\n2. **Subtraction Operator (-):** Subtracts one number from another.\n3. **Multiplication Operator (*):** Multiplies two numbers together.\n4. **Division Operator (/):** Divides one number by another. Note that if both operands are integers, it will perform integer division and the result will be an integer.\n5. **Modulus Operator (%):** Calculates the remainder of an integer division.\n6. **Increment Operator (++):** Increments the value of a variable by 1.\n7. **Decrement Operator (--):** Decrements the value of a variable by 1.\n\nThese are the basic arithmetic operators in C++ that allow you to perform mathematical operations on your variables. Use them in combination with other control structures, such as loops and conditionals, to build more complex programs.",
            "resources": []
          },
          {
            "name": "Logical Operators in C++",
            "recommendation-type": "Start with these",
            "description": "Logical operators are used to perform logical operations on given expressions, mostly to test the relationship between different variables or values. They return a boolean value i.e., either true (1) or false (0) based on the result of the evaluation. C++ provides the following logical operators:\n\n1. **AND Operator (&&):** Returns true if both operands/conditions are true.\n2. **OR Operator (||):** Returns true if either of the operands/conditions are true.\n3. **NOT Operator (!):** Reverses the result of the condition/expression it is applied on.\n\nUsing these operators, you can create more complex logical expressions to control the flow of your program based on different conditions.",
            "resources": []
          },
          {
            "name": "Loops in C++",
            "recommendation-type": "Start with these",
            "description": "Loops are an essential concept in programming that allow you to execute a block of code repeatedly until a specific condition is met. In C++, there are three main types of loops: for, while, and do-while. Each type has its own specific use case and can be chosen depending on the desired behavior.\n\n1. **For Loop:** Used when you know the number of times you want to traverse through a block of code.\n2. **While Loop:** Runs as long as a specified condition is true.\n3. **Do-While Loop:** Similar to a while loop, but the loop body is executed at least once, even when the condition is false.\n\nIn summary, loops are an integral part of C++ programming that allow you to execute a block of code multiple times.",
            "resources": [
              {
                "name": "C++ For Loop",
                "link": "https://www.w3schools.com/cpp/cpp_for_loop.asp"
              }
            ]
          },
          {
            "name": "Bitwise Operations in C++",
            "recommendation-type": "opinion",
            "description": "Bitwise operations are operations that directly manipulate the bits of a number. They are useful for various purposes, such as optimizing algorithms, performing certain calculations, and manipulating memory in lower-level programming languages like C and C++. Common bitwise operations in C++ include:\n\n1. **Bitwise AND (&):** Compares bits and returns a new number where each bit is set if both corresponding bits are set.\n2. **Bitwise OR (|):** Compares bits and returns a new number where each bit is set if at least one corresponding bit is set.\n3. **Bitwise XOR (^):** Compares bits and returns a new number where each bit is set if the corresponding bits are different.\n4. **Bitwise NOT (~):** Inverts the bits of a number.\n5. **Bitwise Left Shift (<<):** Shifts bits to the left by a specified amount.\n6. **Bitwise Right Shift (>>):** Shifts bits to the right by a specified amount.\n\nUnderstanding and using bitwise operations require careful consideration of data types and specific scenarios.",
            "resources": [
              {
                "name": "Intro to Binary and Bitwise Operators in C++",
                "link": "https://youtu.be/KXwRt7og0gI"
              },
              {
                "name": "Bitwise AND (&), OR (|), XOR (^) and NOT (~) in C++",
                "link": "https://youtu.be/HoQhw6_1NAA"
              }
            ]
          }
        ],
        "order": 3,
        "options": []
      },
      "Functions": {
        "description": "A function is a group of statements that perform a specific task, organized as a separate unit in a program. Functions help in breaking the code into smaller, manageable, and reusable blocks.\n\nThere are mainly two types of functions in C++:\n\n**Standard library functions:** Pre-defined functions available in the C++ standard library, such as printf(), scanf(), sqrt(), and many more. These functions are part of the standard library, so you need to include the appropriate header file to use them.\n\n**User-defined functions:** Functions created by the programmer to perform a specific task. To create a user-defined function, you need to define the function and call it in your code.\n\n**Defining a Function:** The general format for defining a function in C++ is:\n```cpp\nreturn_type function_name(parameter list) {\n    // function body\n}\n```\n\n**Function Prototypes:** In some cases, you might want to use a function before actually defining it. To do this, you need to declare a function prototype at the beginning of your code.\n\nA function prototype is a declaration of the function without its body, and it informs the compiler about the function’s name, return type, and parameters.",
        "resources": [
          {
            "name": "introduction to functions in c++",
            "link": "https://www.learncpp.com/cpp-tutorial/introduction-to-functions/"
          }
        ],
        "order": 4,
        "options": [
          {
            "name": "Operators in C++",
            "recommendation-type": "opinion",
            "description": "Operators in C++ are symbols that perform various operations on data, including arithmetic, comparison, and logical operations. They play a crucial role in manipulating and evaluating expressions and variables, contributing to the efficiency and conciseness of code.\n\nHere is a list of commonly used operator types in C++:\n\n**Arithmetic Operators:**\n- `+`: addition\n- `-`: subtraction\n- `*`: multiplication\n- `/`: division\n- `%`: modulo (remainder)\n\n**Comparison (Relational) Operators:**\n- `==`: equal to\n- `!=`: not equal to\n- `<`: less than\n- `>`: greater than\n- `<=`: less than or equal to\n- `>=`: greater than or equal to\n\n**Logical Operators:**\n- `&&`: logical AND\n- `||`: logical OR\n- `!`: logical NOT\n\n**Assignment Operators:**\n- `=`: simple assignment\n- `+=`: addition assignment\n- `-=`: subtraction assignment\n- `*=`: multiplication assignment\n- `/=`: division assignment\n- `%=`: modulo assignment\n\nThese operators facilitate various operations, enhancing the expressiveness and functionality of C++ code.",
            "resources": []
          },
          {
            "name": "Lambda Functions in C++",
            "recommendation-type": "opinion",
            "description": "A lambda function, or simply 'lambda', is an anonymous (unnamed) function in C++ defined in place within your source code, featuring a concise syntax. Introduced in C++11, lambda functions have become a widely used feature, particularly in combination with the Standard Library algorithms.\n\n**Syntax:**\n```cpp\n[capture-list](parameters) -> return_type {\n    // function body\n};\n```\n- **capture-list:** A list of variables from the surrounding scope that the lambda function can access.\n- **parameters:** The list of input parameters (optional).\n- **return_type:** The type of the value that the lambda function will return (optional; compiler can deduce in many cases).\n- **function body:** The code defining the operation of the lambda function.\n\n**Usage Examples:**\n- Lambda function with no capture, parameters, or return type.\n```cpp\nauto printHello = []() {\n    std::cout << \"Hello, World!\" << std::endl;\n};\nprintHello(); // Output: Hello, World!\n```\n- Lambda function with parameters.\n```cpp\nauto add = [](int a, int b) {\n    return a + b;\n};\nint result = add(3, 4); // result = 7\n```\n- Lambda function with capture-by-value.\n```cpp\nint multiplier = 3;\nauto times = [multiplier](int a) {\n    return a * multiplier;\n};\nint result = times(5); // result = 15\n```\n- Lambda function with capture-by-reference.\n```cpp\nint expiresInDays = 45;\nauto updateDays = [&expiresInDays](int newDays) {\n    expiresInDays = newDays;\n};\nupdateDays(30); // expiresInDays = 30\n```\nNote: When using capture by reference, changes to the captured variable inside the lambda function affect its value in the surrounding scope.",
            "resources": [
              {
                "name": "Lambda Expressions",
                "link": "https://en.cppreference.com/w/cpp/language/lambda"
              }
            ]
          }
        ]
      },
      "Data Types": {
        "description": "In C++, data types are used to categorize different types of data that a program can process. They are essential for determining the type of value a variable can hold and how much memory space it will occupy. Some basic data types in C++ include integers, floating-point numbers, characters, and booleans.\n\n**Fundamental Data Types:**\n- **Integer (int):** Whole numbers that can store both positive and negative values.\n- **Floating-Point (float, double):** Represent real numbers, with float providing single-precision and double providing double-precision.\n- **Character (char):** Represents a single character, stored using the ASCII value.\n- **Boolean (bool):** Represents logical values: true or false.\n\n**Derived Data Types:**\n- **Arrays:** Used to store multiple values of the same data type in consecutive memory locations.\n- **Pointers:** Used to store the memory address of a variable.\n- **References:** An alternative way to share memory locations between variables.\n\n**User-Defined Data Types:**\n- **Structures (struct):** Used to store different data types under a single variable.\n- **Classes (class):** Similar to structures, but with access specifiers governing member data and function accessibility.\n- **Unions (union):** Used to store different data types in the same memory location.\n\nUnderstanding data types is crucial for effective programming in C++, allowing you to choose the right type for your variables and operations.",
        "resources": [],
        "order": 5,
        "options": [
          {
            "name": "Run-Time Type Identification (RTTI) in C++",
            "recommendation-type": "opinion",
            "description": "Run-Time Type Identification (RTTI) is a feature in C++ that allows you to obtain the type information of an object during program execution. This can be useful when using dynamic typing, where the type of an object can change at runtime.\n\nThere are two main mechanisms for RTTI in C++:\n\n1. **typeid operator:**\n   - typeid is an operator that returns a reference to an object of type std::type_info, which contains information about the type of the object. The header file <typeinfo> should be included to use typeid.\n   - Example:\n     ```cpp\n     #include <iostream>\n     #include <typeinfo>\n\n     class Base { virtual void dummy() {} };\n     class Derived : public Base { /* ... */ };\n\n     int main() {\n         Base* base_ptr = new Derived;\n\n         // Using typeid to get the type of the object\n         std::cout << \"Type: \" << typeid(*base_ptr).name() << '\\n';\n\n         delete base_ptr;\n         return 0;\n     }\n     ```\n\n2. **dynamic_cast operator:**\n   - dynamic_cast is a type-casting operator that performs a runtime type check and safely downcasts a base pointer or reference to a derived pointer or reference. It returns null or throws a bad_cast exception (if casting references) when the casting fails.\n   - Example:\n     ```cpp\n     #include <iostream>\n\n     class Base { virtual void dummy() {} };\n     class Derived1 : public Base { /* ... */ };\n     class Derived2 : public Base { /* ... */ };\n\n     int main() {\n         Base* base_ptr = new Derived1;\n\n         // Using dynamic_cast to safely downcast the pointer\n         Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);\n         if (derived1_ptr) {\n             std::cout << \"Downcast to Derived1 successful\\n\";\n         }\n         else {\n             std::cout << \"Downcast to Derived1 failed\\n\";\n         }\n\n         Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);\n         if (derived2_ptr) {\n             std::cout << \"Downcast to Derived2 successful\\n\";\n         }\n         else {\n             std::cout << \"Downcast to Derived2 failed\\n\";\n         }\n\n         delete base_ptr;\n         return 0;\n     }\n     ```\n\nPlease note that the use of RTTI can have some performance overhead, as it requires additional compiler-generated information to be stored and processed during runtime.",
            "resources": []
          },
          {
            "name": "Dynamic Typing in C++",
            "recommendation-type": "opinion",
            "description": "C++ is known as a statically-typed language, which means the data types of its variables are determined at compile time. However, C++ also provides concepts to have a certain level of dynamic typing, which means determining the data types of variables at runtime.\n\nHere is a brief overview of two ways to achieve dynamic typing in C++:\n\n1. **void* Pointers:**\n   - A void* pointer is a generic pointer that can point to objects of any data type. They can be used to store a reference to any type of object without knowing the specific type of the object.\n   - Example:\n     ```cpp\n     #include <iostream>\n\n     int main() {\n         int x = 42;\n         float y = 3.14f;\n         std::string z = \"Hello, world!\";\n\n         void* void_ptr;\n\n         void_ptr = &x;\n         std::cout << \"int value: \" << *(static_cast<int*>(void_ptr)) << std::endl;\n\n         void_ptr = &y;\n         std::cout << \"float value: \" << *(static_cast<float*>(void_ptr)) << std::endl;\n\n         void_ptr = &z;\n         std::cout << \"string value: \" << *(static_cast<std::string*>(void_ptr)) << std::endl;\n\n         return 0;\n     }\n     ```\n\n2. **std::any (C++17):**\n   - C++17 introduced the std::any class which represents a generalized type-safe container for single values of any type.\n   - Example:\n     ```cpp\n     #include <iostream>\n     #include <any>\n\n     int main() {\n         std::any any_value;\n\n         any_value = 42;\n         std::cout << \"int value: \" << std::any_cast<int>(any_value) << std::endl;\n\n         any_value = 3.14;\n         std::cout << \"double value: \" << std::any_cast<double>(any_value) << std::endl;\n\n         any_value = std::string(\"Hello, world!\");\n         std::cout << \"string value: \" << std::any_cast<std::string>(any_value) << std::endl;\n\n         return 0;\n     }\n     ```\n\nKeep in mind that both void* pointers and std::any have performance implications due to the additional type checking and casting that take place during runtime. They should be used carefully and only when absolutely necessary.",
            "resources": []
          },
          {
            "name": "Static Typing in C++",
            "recommendation-type": "opinion",
            "description": "In C++, static typing means that the data type of a variable is determined at compile time, before the program is executed. This ensures that a variable can be used only with data of a specific type, and the compiler performs type checking during compile time to ensure compatibility with the declared type.\n\nC++ is a statically typed language, relying on static typing to determine data types and perform type checking during the compilation phase. This approach enhances type safety and helps prevent certain types of errors from occurring during the execution of the program.\n\nHere’s a simple code example illustrating static typing in C++:\n\n```cpp\n#include <iostream>\n\nint main() {\n    int num = 42;        // 'num' is statically typed as an integer\n    double pi = 3.14159; // 'pi' is statically typed as a double\n\n    num = pi; // This assignment would cause a compile-time error as the types don't match\n\n    std::cout << \"The value of num is: \" << num << std::endl;\n    std::cout << \"The value of pi is: \" << pi << std::endl;\n\n    return 0;\n}\n```\n\nIn this code, the variable num is statically typed as an int, and pi is statically typed as a double. Attempting to assign the value of pi to num would result in a compile-time error, demonstrating how the static typing system ensures variables are only used with compatible data types.",
            "resources": []
          }
        ]
      },
      "Pointers and References": {
        "description": "A pointer is a variable that stores the memory address of another variable (or function), allowing indirect access or modification of the value. The general format to declare a pointer is `dataType *pointerName;`.\n\n**Initializing a pointer:**\n```cpp\nint num = 10;\nint *ptr = &num;  // Pointer 'ptr' now points to the memory address of 'num'\n```\n**Accessing value using a pointer:**\n```cpp\nint value = *ptr; // Value now contains the value of the variable that 'ptr' points to (i.e., 10)\n```\n**Function pointer example:**\n```cpp\nint add(int a, int b)\n{\n  return a + b;\n}\n\nint main()\n{   int (*funcptr) (int, int) = add; // Pointer 'funcptr' now points to the functions 'add'\n  funcptr(4, 5); // Returns 9\n}\n```\n\n**References:**\nA reference is an alias for an existing variable, serving as a different name for the same memory location. Unlike pointers, references cannot be null and must be initialized when declared. Once initialized, a reference cannot be changed to refer to another variable.\n\n**General format to declare a reference:**\n```cpp\ndataType &referenceName = existingVariable;\n```\n**Example:**\n```cpp\nint num = 10;\nint &ref = num; // Reference 'ref' is now an alias of 'num'\n```\nModifying the value of 'ref' will also modify the value of 'num' because they share the same memory location.\n\n**Note:** References are commonly used when passing variables by reference in function arguments or creating an alias for a variable without using pointer syntax.",
        "resources": [],
        "order": 6,
        "options": [
          {
            "name": "References in C++",
            "recommendation-type": "Start with these",
            "description": "A reference in C++ can be viewed as a constant pointer (not to be confused with a pointer to a constant value) that always points to (references) the same object. References are declared using the `&` (ampersand) symbol.\n\n**Declaration and Initialization:**\nTo declare a reference, use the `&` symbol followed by the variable type and the reference’s name. Note that you must initialize a reference when you declare it.\n```cpp\nint var = 10;        // Declare an integer variable\nint& ref = var;      // Declare a reference that 'points to' var\n```\n**Usage:**\nYou can use the reference just like the original variable. Changing the value of the reference also changes the value of the original variable since they share the same memory location.\n```cpp\nvar = 20;            // Sets the value of var to 20\nstd::cout << ref << std::endl; // Outputs 20\n\nref = 30;            // Sets the value of ref to 30\nstd::cout << var << std::endl; // Outputs 30\n```\n**Function Parameters:**\nReferences can be used as function parameters to create an alias for an argument. This is commonly done when modifying the original variable or when passing an object of considerable size to avoid the cost of copying.\n```cpp\nvoid swap(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n   int x = 5, y = 10;\n   std::cout << \"Before Swap: x = \" << x << \" y = \" << y << std::endl; // Outputs 5 10\n\n   swap(x, y);\n   std::cout << \"After Swap: x = \" << x << \" y = \" << y << std::endl;  // Outputs 10 5\n}",
            "resources": []
          },
          {
            "name": "Smart Pointers",
            "options": [
              {
                "name": "Weak Pointer in C++",
                "recommendation-type": "Start with these",
                "description": "A weak_ptr is a type of smart pointer in C++ that adds a level of indirection and safety to a raw pointer. It is mainly used to break reference cycles in cases where two objects have shared pointers to each other, or when you need a non-owning reference to an object that is managed by a shared_ptr.\n\nA weak_ptr doesn’t increase the reference count of the object it points to, which is a crucial distinction between weak_ptr and shared_ptr. This ensures that the object will be deleted once the last shared_ptr that owns it goes out of scope, even if there are weak_ptrs still referencing it.\n\nTo use a weak_ptr, you must convert it to a shared_ptr using the lock() function, which tries to create a new shared_ptr that shares ownership of the object. If successful, the object’s reference count is increased and you can use the returned shared_ptr to safely access the object.\n\nHere’s an example of using weak_ptr:\n\n```cpp\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    void DoSomething() {\n        std::cout << \"Doing something...\\n\";\n    }\n};\n\nint main() {\n    std::weak_ptr<MyClass> weak;\n\n    {\n        std::shared_ptr<MyClass> shared = std::make_shared<MyClass>();\n        weak = shared;\n\n        if(auto sharedFromWeak = weak.lock()) {\n            sharedFromWeak->DoSomething(); // Safely use the object\n            std::cout << \"Shared uses count: \" << sharedFromWeak.use_count() << '\\n'; // 2\n        }\n    }\n\n    // shared goes out of scope and the MyClass object is destroyed\n\n    if(auto sharedFromWeak = weak.lock()) {\n        // This block will not be executed because the object is destroyed\n    }\n    else {\n        std::cout << \"Object has been destroyed\\n\";\n    }\n\n    return 0;\n}\n```\n\nIn this example, we create a shared_ptr named shared that manages a MyClass object. By assigning it to a weak_ptr named weak, we store a non-owning reference to the object. Inside the inner scope, we create a new shared_ptr named sharedFromWeak using weak.lock() to safely use the object. After the inner scope, the MyClass object is destroyed since shared goes out of scope, and any further attempt to create a shared_ptr from weak will fail as the object is already destroyed.\n\n[CPP Reference](https://en.cppreference.com/w/cpp/memory/weak_ptr)",
                "resources": []
              },
              {
                "name": "Shared Pointer in C++",
                "recommendation-type": "Start with these",
                "description": "A shared_ptr is a type of smart pointer in C++ that allows multiple pointers to share ownership of a dynamically allocated object. The object will be automatically deallocated only when the last shared_ptr that points to it is destroyed. When using a shared_ptr, the reference counter is automatically incremented every time a new pointer is created, and decremented when each pointer goes out of scope. Once the reference counter reaches zero, the system will clean up the memory.\n\nCode Example\nHere’s an example of how to use shared_ptr:\n\n```cpp\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    MyClass() { std::cout << \"Constructor is called.\" << std::endl; }\n    ~MyClass() { std::cout << \"Destructor is called.\" << std::endl; }\n};\n\nint main() {\n    // create a shared pointer to manage the MyClass object\n    std::shared_ptr<MyClass> ptr1(new MyClass());\n    \n    {\n        // create another shared pointer and initialize it with the previously created pointer\n        std::shared_ptr<MyClass> ptr2 = ptr1;\n\n        std::cout << \"Inside the inner scope.\" << std::endl;\n        // both pointers share the same object, and the reference counter has been increased to 2\n    }\n\n    std::cout << \"Outside the inner scope.\" << std::endl;\n    // leaving the inner scope will destroy ptr2, and the reference counter is decremented to 1\n    \n    // the main function returns, ptr1 goes out of scope, and the reference counter becomes 0\n    // this causes the MyClass object to be deleted and the destructor is called\n}\n```\n\nOutput:\n\n```\nConstructor is called.\nInside the inner scope.\nOutside the inner scope.\nDestructor is called.\n```",
                "resources": []
              },
              {
                "name": "Unique Pointer (unique_ptr) in C++",
                "recommendation-type": "Start with these",
                "description": "std::unique_ptr is a smart pointer provided by the C++ Standard Library. It is a template class used for managing single objects or arrays with the concept of exclusive ownership. Only one unique_ptr is allowed to own an object at a time, and ownership can be transferred or moved. This helps prevent issues like dangling pointers and reduces memory leaks.\n\n**Creating a unique_ptr**\n```cpp\n#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1(new int(5)); // Initialize with a pointer to a new integer\n    std::unique_ptr<int> p2 = std::make_unique<int>(10); // Preferred method (C++14 onwards)\n\n    std::cout << *p1 << \", \" << *p2 << std::endl;\n    return 0;\n}\n```\n**Transferring Ownership**\n```cpp\n#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1(new int(5));\n\n    std::unique_ptr<int> p2 = std::move(p1); // Ownership is transferred from p1 to p2\n\n    if (p1) {\n        std::cout << \"p1 owns the object\" << std::endl;\n    } else if (p2) {\n        std::cout << \"p2 owns the object\" << std::endl;\n    }\n\n    return 0;\n}\n```\n**Using unique_ptr with Custom Deleters**\n```cpp\n#include <iostream>\n#include <memory>\n\nstruct MyDeleter {\n    void operator()(int* ptr) {\n        std::cout << \"Custom Deleter: Deleting pointer\" << std::endl;\n        delete ptr;\n    }\n};\n\nint main() {\n    std::unique_ptr<int, MyDeleter> p1(new int(5), MyDeleter());\n    return 0; // Custom Deleter will be called when p1 goes out of scope\n}\n```\nRemember that since unique_ptr has exclusive ownership, you cannot use it when you need shared access to an object. For such cases, you can use std::shared_ptr.",
                "resources": []
              }
            ]
          },
          {
            "name": "Raw Pointers",
            "options": [
              {
                "name": "Raw Pointers and new/delete Operators in C++",
                "recommendation-type": "opinion",
                "description": "Raw pointers in C++ are low-level constructs that directly hold a memory address. They can be used for manually allocating memory, creating dynamic arrays, and passing values efficiently, among other things.\n\n**new Operator**\nThe new operator is used to allocate memory on the heap. The memory allocated using new remains available until you explicitly deallocate it using the corresponding delete operator.\n\nHere’s an example of using the new operator:\n\n```cpp\nint* ptr = new int; // Dynamically allocates an int on the heap\n*ptr = 42; // Assigns the value 42 to the allocated int\ndelete Operator\n```\n\nThe delete operator is used to deallocate memory that has been allocated using new. After memory is deallocated, it’s available to be reallocated for other purposes. Failing to properly deallocate memory can lead to memory leaks.\n\nHere’s an example of using the delete operator:\n\n```cpp\nint* ptr = new int; // Dynamically allocates an int on the heap\n*ptr = 42; // Assigns the value 42 to the allocated int\ndelete ptr; // Deallocates the memory assigned to ptr\n```\n\n**new[] and delete[] Operators**\nThe new[] and delete[] operators are used for allocating and deallocating memory for an array of objects. The syntax for new[] and delete[] is very similar to that of new and delete.\n\nHere’s an example of using the new[] and delete[] operators:\n\n```cpp\nint n = 10;\nint* arr = new int[n]; // Dynamically allocates an array of 10 integers on the heap\n\n// Set some values in the array\nfor (int i = 0; i < n; i++) {\n  arr[i] = i;\n}\n\ndelete[] arr; // Deallocates the memory assigned to the array\n```\n\nIn summary, raw pointers, and new and delete operators allow manual memory management in C++, providing control over allocation and deallocation. Make sure to always deallocate memory allocated with new or new[], to avoid memory leaks in your programs.",
                "resources": []
              },
              {
                "name": "Memory Leakage in C++",
                "recommendation-type": "opinion",
                "description": "Memory leakage occurs when a program allocates memory in the heap but does not release the memory back to the operating system when it is no longer needed. Over time, this leads to exhaustion of available memory, resulting in low system performance or crashes.\n\nIn C++, when you use raw pointers, you need to manage the memory allocation and deallocation manually. In many cases, you will use the new keyword to allocate memory for an object in the heap and use delete keyword to deallocate that memory when it’s no longer needed. Forgetting to do this can cause memory leaks.\n\nHere’s an example:\n\n```cpp\nvoid create_memory_leak() {\n    int* ptr = new int[100]; // Allocating memory in the heap for an array of integers\n    // Some code...\n    // Code to deallocate the memory is missing: delete[] ptr;\n} // ptr goes out of scope, memory block allocated is not deallocated, causing a memory leak.\n```\n\nTo avoid memory leaks, you should always ensure that memory is deallocated before a pointer goes out of scope or is reassigned. Some ways to achieve this include using the C++ smart pointers (std::unique_ptr, std::shared_ptr), RAII (Resource Acquisition Is Initialization) techniques, and containers from the C++ standard library that manage memory allocation internally (e.g., std::vector, std::string).\n\nFor example, this code will not have a memory leak:\n\n```cpp\n#include <memory>\n\nvoid no_memory_leak() {\n    std::shared_ptr<int[]> ptr = std::make_shared<int[]>(100); // Allocating memory in the heap for an array of integers using shared_ptr\n    // Some code...\n} // shared_ptr goes out of scope and it will automatically deallocate t\n```\n",
                "resources": []
              }
            ]
          },
          {
            "name": "Memory Model in C++",
            "recommendation-type": "Start with these",
            "description": "The memory model in C++ defines how the program stores and accesses data in computer memory. It consists of different segments, such as the Stack, Heap, Data, and Code segments. Each of these segments is used to store different types of data and has specific characteristics.\n\n**Stack Memory:**\nStack memory is used for automatic storage duration variables, such as local variables and function call data. It's managed by the compiler, and allocation and deallocation are done automatically. The stack memory follows the LIFO (Last In First Out) data structure.\n\n```cpp\nvoid functionExample() {\n    int x = 10; // x is stored in the stack memory\n}\n```\n\n**Heap Memory:**\nHeap memory is used for dynamic storage duration variables, such as objects created using the new keyword. The programmer has control over the allocation and deallocation of heap memory using new and delete operators. Heap memory is a larger pool of memory than the stack but has a slower access time.\n\n```cpp\nvoid functionExample() {\n    int* p = new int; // dynamically allocated int in heap memory\n    *p = 10;\n    // more code\n    delete p; // deallocate memory\n}\n```\n\n**Data Segment:**\nThe Data segment is composed of two parts: the initialized data segment and the uninitialized data segment. It stores global, static, and constant variables with initial values and uninitialized global and static variables.\n\n```cpp\n// Initialized data segment\nint globalVar = 10; // global variables\nstatic int staticVar = 10; // static local variables\nconst int constVar = 10; // constant variables with value\n\n// Uninitialized data segment\nint globalVar; // uninitialized global variables\n```\n\n**Code Segment:**\nThe Code segment stores the executable code (machine code) of the program. It's usually located in a read-only area of memory to prevent accidental modification.\n\n```cpp\nvoid functionExample() {\n    // The machine code for this function is stored in the code segment.\n}\n```\n\nIn summary, understanding the memory model in C++ helps optimize the usage of memory resources and improves overall program performance.",
            "resources": []
          },
          {
            "name": "Object Lifetime in C++",
            "recommendation-type": "opinion",
            "description": "Object lifetime refers to the time during which an object exists, from the moment it is created until it is destroyed. In C++, an object’s lifetime can be classified into four categories:\n\n**Static Storage Duration:** Objects with static storage duration exist for the entire run of the program. These objects are allocated at the beginning of the program’s run and deallocated when the program terminates. Global variables, static data members, and static local variables fall into this category.\n\n```cpp\nint global_var;            // Static storage duration\nclass MyClass {\n  static int static_var;   // Static storage duration\n};\nvoid myFunction() {\n  static int local_var;    // Static storage duration\n}\n```\n\n**Thread Storage Duration:** Objects with thread storage duration exist for the lifetime of the thread they belong to. They are created when a thread starts and destroyed when the thread exits. Thread storage duration can be specified using the thread_local keyword.\n\n```cpp\nthread_local int my_var;   // Thread storage duration\n```\n\n**Automatic Storage Duration:** Objects with automatic storage duration are created at the point of definition and destroyed when the scope in which they are declared is exited. These objects are also known as “local” or “stack” objects. Function parameters and local non-static variables fall into this category.\n\n```cpp\nvoid myFunction() {\n  int local_var;           // Automatic storage duration\n}\n```\n\n**Dynamic Storage Duration:** Objects with dynamic storage duration are created at runtime, using memory allocation functions such as new or malloc. The lifetime of these objects must be managed manually, as they are not automatically deallocated when the scope is exited. Instead, it is the programmer’s responsibility to destroy the objects using the delete or free functions when they are no longer needed, to avoid memory leaks.\n\n```cpp\nint* ptr = new int;        // Dynamic storage duration\ndelete ptr;\n```\n\nUnderstanding object lifetimes is essential for managing memory efficiently in C++ programs and avoiding common issues like memory leaks and undefined behavior.\n\nKeep in mind that a proper understanding of constructors and destructors for classes is also essential when working with objects of varying lifetimes, as they allow you to control the behavior of object creation and destruction.",
            "resources": []
          }
        ]
      },
      "Structuring Codebase": {
        "description": "Structuring codebase is an essential part of software development that deals with organizing and modularizing your code to make it more maintainable, efficient, and easier to understand. A well-structured codebase enhances collaboration, simplifies adding new features, and makes debugging faster. In C++, there are various techniques to help you structure your codebase effectively.\n\n**Namespaces:** Namespaces are one of the tools in C++ to organize your code by providing a named scope for different identifiers you create, like functions, classes, and variables. They help avoid name clashes and make your code more modular.\n\n```cpp\nnamespace MyNamespace {\n    int aFunction() {\n        // function implementation\n    }\n}\n// to use the function\nMyNamespace::aFunction();\n```\n\n**Include Guards:** Include guards are a tool for preventing multiple inclusions of a header file in your project. They consist of preprocessor directives that conditionally include the header file only once, even if it’s included in multiple places.\n\n```cpp\n#ifndef MY_HEADER_FILE_H\n#define MY_HEADER_FILE_H\n\n// Your code here\n\n#endif // MY_HEADER_FILE_H\n```\n\n**Header and Source Files:** Separating your implementation and declarations into header (.h) and source (.cpp) files is a key aspect of structuring your codebase in C++. Header files usually contain class and function declarations, while source files contain their definitions.\n\n```cpp\n// MyClass.h\n\n#ifndef MY_CLASS_H\n#define MY_CLASS_H\n\nclass MyClass\n{\npublic:\n    MyClass();\n    int myMethod();\n};\n \n#endif // MY_CLASS_H\n```\n\n```cpp\n// MyClass.cpp\n\n#include \"MyClass.h\"\n\nMyClass::MyClass() {\n    // constructor implementation\n}\n\nint MyClass::myMethod() {\n    // method implementation\n}\n```\n\n**Code Formatting:** Consistent code formatting and indentation play a crucial role in structuring your codebase, making it easier to read and understand for both you and other developers. A style guide such as the Google C++ Style Guide can help you maintain consistent formatting throughout your project.",
        "resources": [],
        "order": 7,
        "options": [
          {
            "name": "Code Splitting",
            "recommendation-type": "opinion",
            "description": "Code splitting refers to the process of breaking down a large code base into smaller, more manageable files or modules. This helps improve the organization, maintainability, and readability of the code. In C++, code splitting is generally achieved through the use of separate compilation, header files, and source files.\n\n**Header Files (.h or .hpp):** Header files, usually with the .h or .hpp extension, are responsible for declaring classes, functions, and variables that are needed by multiple source files. They act as an interface between different parts of the code, making it easier to manage dependencies and reduce the chances of duplicated code.\n\nExample of a header file:\n\n```cpp\n// example.h\n#ifndef EXAMPLE_H\n#define EXAMPLE_H\n\nclass Example {\npublic:\n    void printMessage();\n};\n\n#endif\n```\n\n**Source Files (.cpp):** Source files, with the .cpp extension, are responsible for implementing the actual functionality defined in the corresponding header files. They include the header files as needed and provide the function and class method definitions.\n\nExample of a source file:\n\n```cpp\n// example.cpp\n#include \"example.h\"\n#include <iostream>\n\nvoid Example::printMessage() {\n    std::cout << \"Hello, code splitting!\" << std::endl;\n}\n```\n\n**Separate Compilation:** C++ allows for separate compilation, which means that each source file can be compiled independently into an object file. These object files can then be linked together to form the final executable. This provides faster build times when making changes to a single source file since only that file needs to be recompiled, and the other object files can be reused.\n\nExample of separate compilation and linking:\n\n```bash\n# Compile each source file into an object file\n g++ -c main.cpp -o main.o\n g++ -c example.cpp -o example.o\n\n# Link object files together to create the executable\n g++ main.o example.o -o my_program\n```\n\nBy following the code splitting technique, you can better organize your C++ codebase, making it more manageable and maintainable.",
            "resources": [],
            "options": [
              {
                "name": "Forward Declaration",
                "recommendation-type": "opinion",
                "description": "Forward declaration is a way of declaring a symbol (class, function, or variable) before defining it in the code. It helps the compiler understand the type, size, and existence of the symbol. This declaration is particularly useful when we have cyclic dependencies or to reduce compilation time by avoiding unnecessary header inclusions in the source file.\n\n**Class Forward Declaration:** To use a class type before it is defined, you can declare the class without defining its members, like this:\n\n```cpp\nclass ClassA; // forward declaration\n```\n\nYou can then use pointers or references to the class in your code before defining the class itself:\n\n```cpp\nvoid do_something (ClassA& obj);\n\nclass ClassB {\npublic:\n    void another_function(ClassA& obj);\n};\n```\n\nHowever, if you try to make an object of ClassA or call its member functions without defining the class, you will get a compilation error.\n\n**Function Forward Declaration:** Functions must be declared before using them, and a forward declaration can be used to declare a function without defining it:\n\n```cpp\nint add(int a, int b); // forward declaration\n\nint main() {\n    int result = add(2, 3);\n    return 0;\n}\n\nint add(int a, int b) {\n    return a + b;\n}\n```\n\n**Enum and Typedef Forward Declaration:** For enum and typedef, it is not possible to forward declare because they don’t have separate declaration and definition stages.\n\nKeep in mind that forward declarations should be used cautiously, as they can make the code more difficult to understand.",
                "resources": []
              }
            ]
          },
          {
            "name": "Scope in C++",
            "recommendation-type": "opinion",
            "description": "Scope refers to the visibility and accessibility of variables, functions, classes, and other identifiers in a C++ program. It determines the lifetime and extent of these identifiers. In C++, there are four types of scope:\n\n**Global scope:** Identifiers declared outside any function or class have a global scope. They can be accessed from any part of the program (unless hidden by a local identifier with the same name). The lifetime of a global identifier is the entire duration of the program.\n```cpp\n#include <iostream>\n\nint globalVar; // This is a global variable\n\nint main() {\n    std::cout << \"Global variable: \" << globalVar << std::endl;\n}\n```\n\n**Local scope:** Identifiers declared within a function or a block have a local scope. They can be accessed only within the function or the block they were declared in. Their lifetime is limited to the duration of the function/block execution.\n```cpp\n#include <iostream>\n\nvoid localExample() {\n    int localVar; // This is a local variable\n    localVar = 5;\n    std::cout << \"Local variable: \" << localVar << std::endl;\n}\n\nint main() {\n    localExample();\n    // std::cout << localVar << std::endl; //error: ‘localVar’ was not declared in this scope\n}\n```\n\n**Namespace scope:** A namespace is a named scope that groups related identifiers together. Identifiers declared within a namespace have the namespace scope. They can be accessed using the namespace name and the scope resolution operator ::.\n```cpp\n#include <iostream>\n\nnamespace MyNamespace {\n    int namespaceVar = 42;\n}\n\nint main() {\n    std::cout << \"Namespace variable: \" << MyNamespace::namespaceVar << std::endl;\n}\n```\n\n**Class scope:** Identifiers declared within a class have a class scope. They can be accessed using the class name and the scope resolution operator :: or, for non-static members, an object of the class and the dot . or arrow -> operator.\n```cpp\n#include <iostream>\n\nclass MyClass {\npublic:\n    static int staticMember;\n    int nonStaticMember;\n\n    MyClass(int value) : nonStaticMember(value) {}\n};\n\nint MyClass::staticMember = 7;\n\nint main() {\n    MyClass obj(10);\n    std::cout << \"Static member: \" << MyClass::staticMember << std::endl;\n    std::cout << \"Non-static member: \" << obj.nonStaticMember << std::endl;\n}\n```\nUnderstanding various types of scope in C++ is essential for effective code structuring and management of resources in a codebase.",
            "resources": [],
            "options": [
              {
                "name": "Namespaces in C++",
                "recommendation-type": "opinion",
                "description": "In C++, a namespace is a named scope or container that is used to organize and enclose a collection of code elements, such as variables, functions, classes, and other namespaces. They are mainly used to divide and manage the code base, giving developers control over name collisions and the specialization of code.\n\n**Syntax:**\nHere’s the syntax for declaring a namespace:\n```cpp\nnamespace identifier {\n    // code elements\n}\n```\n**Using Namespaces:**\nTo access elements within a namespace, you can use the scope resolution operator ::.\n\n**Declaring and accessing a namespace:**\n```cpp\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    std::cout << \"Dog's name: \" << animals::dog << std::endl;\n    std::cout << \"Cat's name: \" << animals::cat << std::endl;\n    return 0;\n}\n```\n\n**Nesting namespaces:**\n```cpp\n#include <iostream>\n\nnamespace outer {\n    int x = 10;\n\n    namespace inner {\n        int y = 20;\n    }\n}\n\nint main() {\n    std::cout << \"Outer x: \" << outer::x << std::endl;\n    std::cout << \"Inner y: \" << outer::inner::y << std::endl;\n    return 0;\n}\n```\n\n**Using Keyword:**\nYou can use the using keyword to import namespaced elements into the current scope. However, this might lead to name conflicts if multiple namespaces have elements with the same name.\n\n**Using a single element from a namespace:**\n```cpp\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    using animals::dog;\n    std::cout << \"Dog's name: \" << dog << std::endl;\n    return 0;\n}\n```\n\n**Using the entire namespace:**\n```cpp\n#include <iostream>\n\nnamespace animals {\n    std::string dog = \"Bobby\";\n    std::string cat = \"Lilly\";\n}\n\nint main() {\n    using namespace animals;\n    std::cout << \"Dog's name: \" << dog << std::endl;\n    std::cout << \"Cat's name: \" << cat << std::endl;\n    return 0;\n}\n```\n\nIn conclusion, namespaces are a useful mechanism in C++ to organize code, avoid naming conflicts, and manage the visibility of code elements.",
                "resources": []
              },
              {
                "name": "Rule of Zero, Three, and Five in C++",
                "recommendation-type": "opinion",
                "description": "The Rule of Zero, Three, and Five is a set of guidelines for managing object resources in modern C++, related to structures and classes. These rules deal with the default behavior of constructors, destructors, and other special member functions that are necessary for proper resource management.\n\n**Rule of Zero:**\nThe Rule of Zero states that if a class or structure does not explicitly manage resources, it should not define any of the special member functions, i.e., destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator. The compiler will automatically generate these functions, and the behavior will be correct for managing resources like memory and file handles.\n\nExample:\n```cpp\nstruct MyResource {\n    std::string name;\n    int value;\n};\n```\nIn this example, MyResource is a simple structure that does not manage any resources, so it does not define any special member functions. The compiler will generate them automatically, and the behavior will be correct.\n\n**Rule of Three:**\nThe Rule of Three states that a class or structure that manages resources should define the following three special member functions:\n1. Destructor\n2. Copy constructor\n3. Copy assignment operator\nThese functions are necessary for proper resource management, such as releasing memory or correctly handling deep copies.\n\nExample:\n```cpp\nclass MyResource {\npublic:\n    // Constructor and destructor\n    MyResource() : data(new int[100]) {} \n    ~MyResource() { delete[] data; } \n\n    // Copy constructor\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Copy assignment operator\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n```\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines the destructor, copy constructor, and copy assignment operator.\n\n**Rule of Five:**\nThe Rule of Five extends the Rule of Three to include two additional special member functions:\n1. Move constructor\n2. Move assignment operator\nModern C++ introduces move semantics, which allows for more efficient handling of resources by transferring ownership without necessarily copying all the data.\n\nExample:\n```cpp\nclass MyResource {\npublic:\n    // Constructors and destructor\n    MyResource() : data(new int[100]) {}\n    ~MyResource() { delete[] data; }\n\n    // Copy constructor\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Copy assignment operator\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\n    // Move constructor\n    MyResource(MyResource&& other) noexcept : data(other.data) {\n        other.data = nullptr;\n    }\n\n    // Move assignment operator\n    MyResource& operator=(MyResource&& other) noexcept {\n        if (&other == this) { return *this; }\n        delete[] data;\n        data = other.data;\n        other.data = nullptr;\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n```\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines all five special member functions for proper resource management and move semantics.",
                "resources": []
              },
              {
                "name": "Object-Oriented Programming (OOP) in C++",
                "recommendation-type": "opinion",
                "description": "Object-oriented programming (OOP) is a programming paradigm that uses objects, which are instances of classes, to perform operations and interact with each other. In C++, you can achieve OOP through the use of classes and objects.\n\n**Classes:**\nA class is a blueprint for creating objects. It defines the structure (data members) and behavior (member functions) for a type of object. Here’s an example of a simple class:\n```cpp\nclass Dog {\npublic:\n    std::string name;\n    int age;\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n```\nThis Dog class has two data members: name and age, and one member function bark. You can create an object of this class and access its members like this:\n```cpp\nDog myDog;\nmyDog.name = \"Fido\";\nmyDog.age = 3;\nmyDog.bark(); // Output: Fido barks!\n```\n**Encapsulation:**\nEncapsulation is the concept of bundling data and functions that operate on that data within a single unit, such as a class. It helps to hide the internal implementation details of a class and expose only the necessary information and functionalities. In C++, you can use access specifiers like public, private, and protected to control the visibility and accessibility of class members.\n```cpp\nclass Dog {\nprivate:\n    std::string name;\n    int age;\n\npublic:\n    void setName(std::string n) {\n        name = n;\n    }\n\n    void setAge(int a) {\n        age = a;\n    }\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n```\nIn this example, we’ve made the name and age data members private and added public member functions setName and setAge to modify them. This way, the internal data of the Dog class is protected and only accessible through the provided functions.\n\n**Inheritance:**\nInheritance is the concept of deriving new classes from existing ones, which enables code reusability and organization. In C++, inheritance is achieved by using a colon : followed by the base class’ access specifier and the base class name.\n```cpp\nclass Animal {\npublic:\n    void breathe() {\n        std::cout << \"I can breathe\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n```\nIn this example, the Dog class inherits from the Animal class, so the Dog class can access the breathe function from the Animal class. When you create a Dog object, you can use both breathe and bark functions.\n```cpp\nDog myDog;\nmyDog.breathe(); // Output: I can breathe\nmyDog.bark(); // Output: Dog barks!\n```\n**Polymorphism:**\nPolymorphism allows you to use a single interface to represent different types. In C++, it’s mainly achieved using function overloading, virtual functions, and overriding.\n```cpp\nclass Animal {\npublic:\n    virtual void makeSound() {\n        std::cout << \"The Animal makes a sound\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Cat meows!\" << std::endl;\n    }\n};\n```\nIn this example, we have an Animal base class with a virtual makeSound function. We then derive two classes, Dog and Cat, which override the makeSound function. This enables polymorphic behavior, where an Animal pointer or reference can be used to access the correct makeSound function depending on the derived class type.\n```cpp\nAnimal *animals[2] = {new Dog, new Cat};\nanimals[0]->makeSound(); // Output: Dog barks!\nanimals[1]->makeSound(); // Output: Cat meows!\n```\nThat’s a brief overview of object-oriented programming concepts in C++.",
                "resources": [],
                "options": [
                  {
                    "name": "Static Polymorphism",
                    "recommendation-type": "opinion",
                    "description": "Static polymorphism, also known as compile-time polymorphism, is a type of polymorphism that resolves the types and method calls at compile time rather than at runtime. This is commonly achieved through the use of function overloading and templates in C++.\n\n**Function Overloading:**\nFunction overloading is a way to create multiple functions with the same name but different parameter lists. The compiler determines the correct function to call based on the types and number of arguments used when the function is called.\n\nExample:\n```cpp\n#include <iostream>\n\nvoid print(int i) {\n    std::cout << \"Printing int: \" << i << std::endl;\n}\n\nvoid print(double d) {\n    std::cout << \"Printing double: \" << d << std::endl;\n}\n\nvoid print(const char* s) {\n    std::cout << \"Printing string: \" << s << std::endl;\n}\n\nint main() {\n    print(5);          // Calls print(int i)\n    print(3.14);       // Calls print(double d)\n    print(\"Hello\");    // Calls print(const char* s)\n\n    return 0;\n}\n```\n\n**Templates:**\nTemplates are a powerful feature in C++ that allows you to create generic functions or classes. The actual code for specific types is generated at compile time, which avoids the overhead of runtime polymorphism. The use of templates is the main technique to achieve static polymorphism in C++.\n\nExample:\n```cpp\n#include <iostream>\n\n// Template function to print any type\n template<typename T>\n void print(const T& value) {\n     std::cout << \"Printing value: \" << value << std::endl;\n }\n\n int main() {\n     print(42);           // int\n     print(3.14159);      // double\n     print(\"Hello\");      // const char*\n\n     return 0;\n }\n```\n\nIn conclusion, static polymorphism achieves polymorphic behavior during compile time using function overloading and templates, instead of relying on runtime information like dynamic polymorphism does. This can result in more efficient code since method calls are resolved at compile time.",
                    "resources": [],
                    "options": [
                      {
                        "name": "Function Overloading",
                        "recommendation-type": "opinion",
                        "description": "Function overloading is a type of static polymorphism in C++ where multiple functions with the same name but different sets of parameters are defined in the same scope. This allows you to use the same function name for multiple tasks by providing different arguments while calling the function. The appropriate function to call is determined during compile-time based on the number and types of the arguments passed.\n\nTo overload a function, simply define another function with the same name but a different set of parameters. The compiler will automatically choose the correct function to call based on the provided arguments.\n\n**Examples:**\nHere’s an example illustrating function overloading:\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid print(int num) {\n    cout << \"Printing int: \" << num << endl;\n}\n\nvoid print(double num) {\n    cout << \"Printing double: \" << num << endl;\n}\n\nvoid print(char const *str) {\n    cout << \"Printing string: \" << str << endl;\n}\n\nint main() {\n    print(5);\n    print(3.14);\n    print(\"Hello, world!\");\n\n    return 0;\n}\n```\nIn this example, three overloaded functions named print are defined. They each take a different type of argument: int, double, and char const *. When calling print() with different arguments like 5, 3.14, or \"Hello, world!\", the appropriate function is chosen based on the type of the provided argument.\n\nThe output of this program would be:\n```\nPrinting int: 5\nPrinting double: 3.14\nPrinting string: Hello, world!\n```\n\nKeep in mind that the number of parameters and their types should be different for two functions to be overloaded.",
                        "resources": []
                      }
                    ]
                  },
                  {
                    "name": "Dynamic Polymorphism",
                    "recommendation-type": "opinion",
                    "description": "Dynamic polymorphism is a programming concept in object-oriented languages like C++ where a derived class can override or redefine methods of its base class. This means that a single method call can have different implementations based on the type of object it is called on.\n\nDynamic polymorphism is achieved through virtual functions, which are member functions of a base class marked with the virtual keyword. When you specify a virtual function in a base class, it can be overridden in any derived class to provide a different implementation.\n\n**Example:**\nHere’s an example in C++ demonstrating dynamic polymorphism.\n```cpp\n#include <iostream>\n\n// Base class\nclass Shape {\npublic:\n    virtual void draw() {\n        std::cout << \"Drawing a shape\" << std::endl; \n    }\n};\n\n// Derived class 1\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a circle\" << std::endl; \n    }\n};\n\n// Derived class 2\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a rectangle\" << std::endl;\n    }\n};\n\nint main() {\n    Shape* shape;\n    Circle circle;\n    Rectangle rectangle;\n\n    // Storing the address of circle\n    shape = &circle;\n\n    // Call circle draw function\n    shape->draw();\n\n    // Storing the address of rectangle\n    shape = &rectangle;\n\n    // Call rectangle draw function\n    shape->draw();\n\n    return 0;\n}\n```\nThis code defines a base class Shape with a virtual function draw. Two derived classes Circle and Rectangle both override the draw function to provide their own implementations. Then in the main function, a pointer of type Shape is used to call the respective draw functions of Circle and Rectangle objects. The output of this program will be:\n```\nDrawing a circle\nDrawing a rectangle\n```\nAs you can see, using dynamic polymorphism, we can determine at runtime which draw method should be called based on the type of object being used.",
                    "resources": [],
                    "options": [
                      {
                        "name": "Virtual Methods",
                        "recommendation-type": "opinion",
                        "description": "Virtual methods are a key aspect of dynamic polymorphism in C++. They allow subclass methods to override the methods of their base class, so the appropriate method is called depending on the actual type of an object at runtime.\n\nTo declare a method as virtual, simply use the virtual keyword in the method’s declaration in the base class. This tells the compiler that the method should be treated as a virtual method, allowing it to be overridden by derived classes.\n\n**Code Example:**\nHere’s an example demonstrating virtual methods:\n```cpp\n#include <iostream>\n\n// Base class\nclass Shape {\npublic:\n    virtual double area() const {\n        return 0;\n    }\n};\n\n// Derived class\nclass Circle : public Shape {\npublic:\n    Circle(double r) : radius(r) {}\n\n    // Override the base class method\n    double area() const override {\n        return 3.14 * radius * radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// Derived class\nclass Rectangle : public Shape {\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n\n    // Override the base class method\n    double area() const override {\n        return width * height;\n    }\n\nprivate:\n    double width;\n    double height;\n};\n\nint main() {\n    Circle c(5);\n    Rectangle r(4, 6);\n\n    Shape* shape = &c;\n    std::cout << \"Circle's area: \" << shape->area() << std::endl;\n\n    shape = &r;\n    std::cout << \"Rectangle's area: \" << shape->area() << std::endl;\n\n    return 0;\n}\n```\nIn this example, we define a base class Shape that has a virtual method area. This method is then overridden by the derived classes Circle and Rectangle. By using a virtual method and a base class pointer to the derived objects, we can invoke the appropriate area method based on the actual object type at runtime.",
                        "resources": []
                      },
                      {
                        "name": "Virtual Tables",
                        "recommendation-type": "opinion",
                        "description": "Virtual Tables (or Vtable) are a mechanism used by C++ compilers to support dynamic polymorphism. In dynamic polymorphism, the appropriate function is called at runtime, depending on the actual object type.\n\nWhen a class contains a virtual function, the compiler creates a virtual table for that class. This table contains function pointers to the virtual functions defined in the class. Each object of that class has a pointer to its virtual table (vptr, virtual pointer), which is automatically initialized by the compiler during object construction.\n\n**Example:**\nLet’s consider the following example:\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    virtual void function1() {\n        std::cout << \"Base::function1\" << std::endl;\n    }\n\n    virtual void function2() {\n        std::cout << \"Base::function2\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void function1() override {\n        std::cout << \"Derived::function1\" << std::endl;\n    }\n\n    void function3() {\n        std::cout << \"Derived::function3\" << std::endl;\n    }\n};\n\nint main() {\n    Base* obj = new Derived(); // create a Derived object and assign a pointer of type Base*\n    obj->function1(); // calls Derived::function1, due to dynamic polymorphism\n    obj->function2(); // calls Base::function2\n\n    delete obj;\n    return 0;\n}\n```\nIn this example, when a Derived object is created, the compiler generates a Vtable for Derived class, containing pointers to its virtual functions:\n- Derived::function1 (overridden from Base)\n- Base::function2 (inherits from Base)\nThe `_vptr_` pointer in the Derived object points to this Vtable. When the function1 is called on the Base pointer pointing to the Derived object, the function pointer in the Vtable is used to call the correct function (in this case, Derived::function1). Similarly, the call to function2 calls Base::function2, since it’s the function pointer stored in the Vtable for Derived class.\n\nNote that function3 is not part of the Vtable, as it is not a virtual function.",
                        "resources": []
                      }
                    ]
                  },
                  {
                    "name": "Multiple Inheritance",
                    "recommendation-type": "opinion",
                    "description": "Multiple inheritance is a feature in C++ where a class can inherit characteristics (data members and member functions) from more than one parent class. The concept is similar to single inheritance (where a class inherits from a single base class), but in multiple inheritance, a class can have multiple base classes.\n\nWhen a class inherits multiple base classes, it becomes a mixture of their properties and behaviors, and can override or extend them as needed.\n\n**Syntax:**\nHere is the syntax to declare a class with multiple inheritance:\n```cpp\nclass DerivedClass : access-specifier BaseClass1, access-specifier BaseClass2, ...\n{\n    // class body\n};\n```\nThe `DerivedClass` will inherit members from both `BaseClass1` and `BaseClass2`. The access-specifier (like public, protected, or private) determines the accessibility of the inherited members.\n\n**Example:**\nHere is an example of multiple inheritance in action:\n```cpp\n#include <iostream>\n\nclass Animal\n{\npublic:\n    void eat()\n    {\n        std::cout << \"I can eat!\" << std::endl;\n    }\n};\n\nclass Mammal\n{\npublic:\n    void breath()\n    {\n        std::cout << \"I can breathe!\" << std::endl;\n    }\n};\n\nclass Dog : public Animal, public Mammal\n{\npublic:\n    void bark()\n    {\n        std::cout << \"I can bark! Woof woof!\" << std::endl;\n    }\n};\n\nint main()\n{\n    Dog myDog;\n\n    // Calling members from both base classes\n    myDog.eat();\n    myDog.breath();\n    \n    // Calling a member from the derived class\n    myDog.bark();\n\n    return 0;\n}\n```\n**Note:**\nIn some cases, multiple inheritance can lead to complications such as ambiguity and the 'diamond problem'. Ensure that you use multiple inheritance judiciously and maintain well-structured and modular classes to prevent issues.\n\nFor more information on C++ multiple inheritance and related topics, refer to C++ documentation or a comprehensive C++ programming guide.",
                    "resources": []
                  },
                  {
                    "name": "Diamond Inheritance",
                    "recommendation-type": "opinion",
                    "description": "Diamond inheritance is a specific scenario in multiple inheritance where a class is derived from two or more classes, which in turn, are derived from a common base class. It creates an ambiguity that arises from duplicating the common base class, which leads to an ambiguous behavior while calling the duplicate members.\n\nTo resolve this ambiguity, you can use virtual inheritance. A virtual base class is a class that is shared by multiple classes using the virtual keyword in C++. This ensures that only one copy of the base class is inherited in the final derived class, and thus, resolves the diamond inheritance problem.\n\n**Example:**\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    void print() {\n        std::cout << \"Base class\" << std::endl;\n    }\n};\n\nclass Derived1 : virtual public Base {\npublic:\n    void derived1Print() {\n        std::cout << \"Derived1 class\" << std::endl;\n    }\n};\n\nclass Derived2 : virtual public Base {\npublic:\n    void derived2Print() {\n        std::cout << \"Derived2 class\" << std::endl;\n    }\n};\n\nclass Derived3 : public Derived1, public Derived2 {\npublic:\n    void derived3Print() {\n        std::cout << \"Derived3 class\" << std::endl;\n    }\n};\n\nint main() {\n    Derived3 d3;\n    d3.print(); // Now, there is no ambiguity in calling the base class function\n    d3.derived1Print();\n    d3.derived2Print();\n    d3.derived3Print();\n\n    return 0;\n}\n```\nIn the code above, `Derived1` and `Derived2` are derived from the `Base` class using virtual inheritance. So, when we create an object of `Derived3` and call the `print()` function from the `Base` class, there is no ambiguity, and the code executes without any issues.",
                    "resources": []
                  }
                ]
              }
            ]
          }
        ]
      },
      "Structures and Classes": {
        "description": "Structures and classes are user-defined data types in C++ that allow for the grouping of variables of different data types under a single name. They make it easier to manage and organize complex data by creating objects that have particular attributes and behaviors. The main difference between a structure and a class is their default access specifier: members of a structure are public by default, while members of a class are private.\n\n**Structures:**\nA structure is defined using the `struct` keyword, followed by the structure’s name and a set of curly braces {} enclosing the members (variables and/or functions) of the structure. The members can be of different data types. To create an object of the structure’s type, use the structure name followed by the object name.\n\nHere’s an example of defining a structure and creating an object:\n```cpp\nstruct Employee {\n    int id;\n    std::string name;\n    float salary;\n};\n\nEmployee e1; // create an object of the 'Employee' structure\n```\nYou can access the members of a structure using the dot operator .:\n```cpp\ne1.id = 1;\ne1.name = \"John Doe\";\ne1.salary = 40000;\n```\n\n**Classes:**\nA class is defined using the `class` keyword, followed by the class’s name and a set of curly braces {} enclosing the members (variables and/or functions) of the class. Like structures, class members can be of different data types. You can create objects of a class using the class name followed by the object name.\n\nHere’s an example of a class definition and object creation:\n```cpp\nclass Student {\n    int roll_no;\n    std::string name;\n    float marks;\n\npublic:\n    void set_data(int r, std::string n, float m) {\n        roll_no = r;\n        name = n;\n        marks = m;\n    }\n\n    void display() {\n        std::cout << \"Roll no: \" << roll_no\n                  << \"\\nName: \" << name\n                  << \"\\nMarks: \" << marks << std::endl;\n    }\n};\n\nStudent s1; // create an object of the 'Student' class\n```\nSince the data members of a class are private by default, we cannot access them directly using the dot operator from outside the class. Instead, we use public member functions to set or get their values:\n```cpp\ns1.set_data(1, \"Alice\", 95.0);\ns1.display();\n```\nThat’s a brief summary of structures and classes in C++. Remember that while they may seem similar, classes provide more control over data encapsulation and can be used to implement more advanced features like inheritance and polymorphism.",
        "resources": [],
        "order": 8,
        "options": [
          {
            "name": "Rule of Zero, Three, and Five in C++",
            "recommendation-type": "opinion",
            "description": "The Rule of Zero, Three, and Five is a set of guidelines for managing object resources in modern C++, related to structures and classes. These rules deal with the default behavior of constructors, destructors, and other special member functions that are necessary for proper resource management.\n\n**Rule of Zero:**\nThe Rule of Zero states that if a class or structure does not explicitly manage resources, it should not define any of the special member functions, i.e., destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator. The compiler will automatically generate these functions, and the behavior will be correct for managing resources like memory and file handles.\n\nExample:\n```cpp\nstruct MyResource {\n    std::string name;\n    int value;\n};\n```\nIn this example, MyResource is a simple structure that does not manage any resources, so it does not define any special member functions. The compiler will generate them automatically, and the behavior will be correct.\n\n**Rule of Three:**\nThe Rule of Three states that a class or structure that manages resources should define the following three special member functions:\n1. Destructor\n2. Copy constructor\n3. Copy assignment operator\nThese functions are necessary for proper resource management, such as releasing memory or correctly handling deep copies.\n\nExample:\n```cpp\nclass MyResource {\npublic:\n    // Constructor and destructor\n    MyResource() : data(new int[100]) {} \n    ~MyResource() { delete[] data; } \n\n    // Copy constructor\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Copy assignment operator\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n```\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines the destructor, copy constructor, and copy assignment operator.\n\n**Rule of Five:**\nThe Rule of Five extends the Rule of Three to include two additional special member functions:\n1. Move constructor\n2. Move assignment operator\nModern C++ introduces move semantics, which allows for more efficient handling of resources by transferring ownership without necessarily copying all the data.\n\nExample:\n```cpp\nclass MyResource {\npublic:\n    // Constructors and destructor\n    MyResource() : data(new int[100]) {}\n    ~MyResource() { delete[] data; }\n\n    // Copy constructor\n    MyResource(const MyResource& other) : data(new int[100]) {\n        std::copy(other.data, other.data + 100, data);\n    }\n\n    // Copy assignment operator\n    MyResource& operator=(const MyResource& other) {\n        if (&other == this) { return *this; }\n        std::copy(other.data, other.data + 100, data);\n        return *this;\n    }\n\n    // Move constructor\n    MyResource(MyResource&& other) noexcept : data(other.data) {\n        other.data = nullptr;\n    }\n\n    // Move assignment operator\n    MyResource& operator=(MyResource&& other) noexcept {\n        if (&other == this) { return *this; }\n        delete[] data;\n        data = other.data;\n        other.data = nullptr;\n        return *this;\n    }\n\nprivate:\n    int* data;\n};\n```\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines all five special member functions for proper resource management and move semantics.",
            "resources": []
          },
          {
            "name": "Object-Oriented Programming (OOP) in C++",
            "recommendation-type": "opinion",
            "description": "Object-oriented programming (OOP) is a programming paradigm that uses objects, which are instances of classes, to perform operations and interact with each other. In C++, you can achieve OOP through the use of classes and objects.\n\n**Classes:**\nA class is a blueprint for creating objects. It defines the structure (data members) and behavior (member functions) for a type of object. Here’s an example of a simple class:\n```cpp\nclass Dog {\npublic:\n    std::string name;\n    int age;\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n```\nThis Dog class has two data members: name and age, and one member function bark. You can create an object of this class and access its members like this:\n```cpp\nDog myDog;\nmyDog.name = \"Fido\";\nmyDog.age = 3;\nmyDog.bark(); // Output: Fido barks!\n```\n**Encapsulation:**\nEncapsulation is the concept of bundling data and functions that operate on that data within a single unit, such as a class. It helps to hide the internal implementation details of a class and expose only the necessary information and functionalities. In C++, you can use access specifiers like public, private, and protected to control the visibility and accessibility of class members.\n```cpp\nclass Dog {\nprivate:\n    std::string name;\n    int age;\n\npublic:\n    void setName(std::string n) {\n        name = n;\n    }\n\n    void setAge(int a) {\n        age = a;\n    }\n\n    void bark() {\n        std::cout << name << \" barks!\" << std::endl;\n    }\n};\n```\nIn this example, we’ve made the name and age data members private and added public member functions setName and setAge to modify them. This way, the internal data of the Dog class is protected and only accessible through the provided functions.\n\n**Inheritance:**\nInheritance is the concept of deriving new classes from existing ones, which enables code reusability and organization. In C++, inheritance is achieved by using a colon : followed by the base class’ access specifier and the base class name.\n```cpp\nclass Animal {\npublic:\n    void breathe() {\n        std::cout << \"I can breathe\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n```\nIn this example, the Dog class inherits from the Animal class, so the Dog class can access the breathe function from the Animal class. When you create a Dog object, you can use both breathe and bark functions.\n```cpp\nDog myDog;\nmyDog.breathe(); // Output: I can breathe\nmyDog.bark(); // Output: Dog barks!\n```\n**Polymorphism:**\nPolymorphism allows you to use a single interface to represent different types. In C++, it’s mainly achieved using function overloading, virtual functions, and overriding.\n```cpp\nclass Animal {\npublic:\n    virtual void makeSound() {\n        std::cout << \"The Animal makes a sound\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Dog barks!\" << std::endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    void makeSound() override {\n        std::cout << \"Cat meows!\" << std::endl;\n    }\n};\n```\nIn this example, we have an Animal base class with a virtual makeSound function. We then derive two classes, Dog and Cat, which override the makeSound function. This enables polymorphic behavior, where an Animal pointer or reference can be used to access the correct makeSound function depending on the derived class type.\n```cpp\nAnimal *animals[2] = {new Dog, new Cat};\nanimals[0]->makeSound(); // Output: Dog barks!\nanimals[1]->makeSound(); // Output: Cat meows!\n```\nThat’s a brief overview of object-oriented programming concepts in C++.",
            "resources": [],
            "options": [
              {
                "name": "Static Polymorphism",
                "recommendation-type": "opinion",
                "description": "Static polymorphism, also known as compile-time polymorphism, is a type of polymorphism that resolves the types and method calls at compile time rather than at runtime. This is commonly achieved through the use of function overloading and templates in C++.\n\n**Function Overloading:**\nFunction overloading is a way to create multiple functions with the same name but different parameter lists. The compiler determines the correct function to call based on the types and number of arguments used when the function is called.\n\nExample:\n```cpp\n#include <iostream>\n\nvoid print(int i) {\n    std::cout << \"Printing int: \" << i << std::endl;\n}\n\nvoid print(double d) {\n    std::cout << \"Printing double: \" << d << std::endl;\n}\n\nvoid print(const char* s) {\n    std::cout << \"Printing string: \" << s << std::endl;\n}\n\nint main() {\n    print(5);          // Calls print(int i)\n    print(3.14);       // Calls print(double d)\n    print(\"Hello\");    // Calls print(const char* s)\n\n    return 0;\n}\n```\n\n**Templates:**\nTemplates are a powerful feature in C++ that allows you to create generic functions or classes. The actual code for specific types is generated at compile time, which avoids the overhead of runtime polymorphism. The use of templates is the main technique to achieve static polymorphism in C++.\n\nExample:\n```cpp\n#include <iostream>\n\n// Template function to print any type\n template<typename T>\n void print(const T& value) {\n     std::cout << \"Printing value: \" << value << std::endl;\n }\n\n int main() {\n     print(42);           // int\n     print(3.14159);      // double\n     print(\"Hello\");      // const char*\n\n     return 0;\n }\n```\n\nIn conclusion, static polymorphism achieves polymorphic behavior during compile time using function overloading and templates, instead of relying on runtime information like dynamic polymorphism does. This can result in more efficient code since method calls are resolved at compile time.",
                "resources": [],
                "options": [
                  {
                    "name": "Function Overloading",
                    "recommendation-type": "opinion",
                    "description": "Function overloading is a type of static polymorphism in C++ where multiple functions with the same name but different sets of parameters are defined in the same scope. This allows you to use the same function name for multiple tasks by providing different arguments while calling the function. The appropriate function to call is determined during compile-time based on the number and types of the arguments passed.\n\nTo overload a function, simply define another function with the same name but a different set of parameters. The compiler will automatically choose the correct function to call based on the provided arguments.\n\n**Examples:**\nHere’s an example illustrating function overloading:\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid print(int num) {\n    cout << \"Printing int: \" << num << endl;\n}\n\nvoid print(double num) {\n    cout << \"Printing double: \" << num << endl;\n}\n\nvoid print(char const *str) {\n    cout << \"Printing string: \" << str << endl;\n}\n\nint main() {\n    print(5);\n    print(3.14);\n    print(\"Hello, world!\");\n\n    return 0;\n}\n```\nIn this example, three overloaded functions named print are defined. They each take a different type of argument: int, double, and char const *. When calling print() with different arguments like 5, 3.14, or \"Hello, world!\", the appropriate function is chosen based on the type of the provided argument.\n\nThe output of this program would be:\n```\nPrinting int: 5\nPrinting double: 3.14\nPrinting string: Hello, world!\n```\n\nKeep in mind that the number of parameters and their types should be different for two functions to be overloaded.",
                    "resources": []
                  }
                ]
              },
              {
                "name": "Dynamic Polymorphism",
                "recommendation-type": "opinion",
                "description": "Dynamic polymorphism is a programming concept in object-oriented languages like C++ where a derived class can override or redefine methods of its base class. This means that a single method call can have different implementations based on the type of object it is called on.\n\nDynamic polymorphism is achieved through virtual functions, which are member functions of a base class marked with the virtual keyword. When you specify a virtual function in a base class, it can be overridden in any derived class to provide a different implementation.\n\n**Example:**\nHere’s an example in C++ demonstrating dynamic polymorphism.\n```cpp\n#include <iostream>\n\n// Base class\nclass Shape {\npublic:\n    virtual void draw() {\n        std::cout << \"Drawing a shape\" << std::endl; \n    }\n};\n\n// Derived class 1\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a circle\" << std::endl; \n    }\n};\n\n// Derived class 2\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        std::cout << \"Drawing a rectangle\" << std::endl;\n    }\n};\n\nint main() {\n    Shape* shape;\n    Circle circle;\n    Rectangle rectangle;\n\n    // Storing the address of circle\n    shape = &circle;\n\n    // Call circle draw function\n    shape->draw();\n\n    // Storing the address of rectangle\n    shape = &rectangle;\n\n    // Call rectangle draw function\n    shape->draw();\n\n    return 0;\n}\n```\nThis code defines a base class Shape with a virtual function draw. Two derived classes Circle and Rectangle both override the draw function to provide their own implementations. Then in the main function, a pointer of type Shape is used to call the respective draw functions of Circle and Rectangle objects. The output of this program will be:\n```\nDrawing a circle\nDrawing a rectangle\n```\nAs you can see, using dynamic polymorphism, we can determine at runtime which draw method should be called based on the type of object being used.",
                "resources": [],
                "options": [
                  {
                    "name": "Virtual Methods",
                    "recommendation-type": "opinion",
                    "description": "Virtual methods are a key aspect of dynamic polymorphism in C++. They allow subclass methods to override the methods of their base class, so the appropriate method is called depending on the actual type of an object at runtime.\n\nTo declare a method as virtual, simply use the virtual keyword in the method’s declaration in the base class. This tells the compiler that the method should be treated as a virtual method, allowing it to be overridden by derived classes.\n\n**Code Example:**\nHere’s an example demonstrating virtual methods:\n```cpp\n#include <iostream>\n\n// Base class\nclass Shape {\npublic:\n    virtual double area() const {\n        return 0;\n    }\n};\n\n// Derived class\nclass Circle : public Shape {\npublic:\n    Circle(double r) : radius(r) {}\n\n    // Override the base class method\n    double area() const override {\n        return 3.14 * radius * radius;\n    }\n\nprivate:\n    double radius;\n};\n\n// Derived class\nclass Rectangle : public Shape {\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n\n    // Override the base class method\n    double area() const override {\n        return width * height;\n    }\n\nprivate:\n    double width;\n    double height;\n};\n\nint main() {\n    Circle c(5);\n    Rectangle r(4, 6);\n\n    Shape* shape = &c;\n    std::cout << \"Circle's area: \" << shape->area() << std::endl;\n\n    shape = &r;\n    std::cout << \"Rectangle's area: \" << shape->area() << std::endl;\n\n    return 0;\n}\n```\nIn this example, we define a base class Shape that has a virtual method area. This method is then overridden by the derived classes Circle and Rectangle. By using a virtual method and a base class pointer to the derived objects, we can invoke the appropriate area method based on the actual object type at runtime.",
                    "resources": []
                  },
                  {
                    "name": "Virtual Tables",
                    "recommendation-type": "opinion",
                    "description": "Virtual Tables (or Vtable) are a mechanism used by C++ compilers to support dynamic polymorphism. In dynamic polymorphism, the appropriate function is called at runtime, depending on the actual object type.\n\nWhen a class contains a virtual function, the compiler creates a virtual table for that class. This table contains function pointers to the virtual functions defined in the class. Each object of that class has a pointer to its virtual table (vptr, virtual pointer), which is automatically initialized by the compiler during object construction.\n\n**Example:**\nLet’s consider the following example:\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    virtual void function1() {\n        std::cout << \"Base::function1\" << std::endl;\n    }\n\n    virtual void function2() {\n        std::cout << \"Base::function2\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void function1() override {\n        std::cout << \"Derived::function1\" << std::endl;\n    }\n\n    void function3() {\n        std::cout << \"Derived::function3\" << std::endl;\n    }\n};\n\nint main() {\n    Base* obj = new Derived(); // create a Derived object and assign a pointer of type Base*\n    obj->function1(); // calls Derived::function1, due to dynamic polymorphism\n    obj->function2(); // calls Base::function2\n\n    delete obj;\n    return 0;\n}\n```\nIn this example, when a Derived object is created, the compiler generates a Vtable for Derived class, containing pointers to its virtual functions:\n- Derived::function1 (overridden from Base)\n- Base::function2 (inherits from Base)\nThe `_vptr_` pointer in the Derived object points to this Vtable. When the function1 is called on the Base pointer pointing to the Derived object, the function pointer in the Vtable is used to call the correct function (in this case, Derived::function1). Similarly, the call to function2 calls Base::function2, since it’s the function pointer stored in the Vtable for Derived class.\n\nNote that function3 is not part of the Vtable, as it is not a virtual function.",
                    "resources": []
                  }
                ]
              },
              {
                "name": "Multiple Inheritance",
                "recommendation-type": "opinion",
                "description": "Multiple inheritance is a feature in C++ where a class can inherit characteristics (data members and member functions) from more than one parent class. The concept is similar to single inheritance (where a class inherits from a single base class), but in multiple inheritance, a class can have multiple base classes.\n\nWhen a class inherits multiple base classes, it becomes a mixture of their properties and behaviors, and can override or extend them as needed.\n\n**Syntax:**\nHere is the syntax to declare a class with multiple inheritance:\n```cpp\nclass DerivedClass : access-specifier BaseClass1, access-specifier BaseClass2, ...\n{\n    // class body\n};\n```\nThe `DerivedClass` will inherit members from both `BaseClass1` and `BaseClass2`. The access-specifier (like public, protected, or private) determines the accessibility of the inherited members.\n\n**Example:**\nHere is an example of multiple inheritance in action:\n```cpp\n#include <iostream>\n\nclass Animal\n{\npublic:\n    void eat()\n    {\n        std::cout << \"I can eat!\" << std::endl;\n    }\n};\n\nclass Mammal\n{\npublic:\n    void breath()\n    {\n        std::cout << \"I can breathe!\" << std::endl;\n    }\n};\n\nclass Dog : public Animal, public Mammal\n{\npublic:\n    void bark()\n    {\n        std::cout << \"I can bark! Woof woof!\" << std::endl;\n    }\n};\n\nint main()\n{\n    Dog myDog;\n\n    // Calling members from both base classes\n    myDog.eat();\n    myDog.breath();\n    \n    // Calling a member from the derived class\n    myDog.bark();\n\n    return 0;\n}\n```\n**Note:**\nIn some cases, multiple inheritance can lead to complications such as ambiguity and the 'diamond problem'. Ensure that you use multiple inheritance judiciously and maintain well-structured and modular classes to prevent issues.\n\nFor more information on C++ multiple inheritance and related topics, refer to C++ documentation or a comprehensive C++ programming guide.",
                "resources": []
              },
              {
                "name": "Diamond Inheritance",
                "recommendation-type": "opinion",
                "description": "Diamond inheritance is a specific scenario in multiple inheritance where a class is derived from two or more classes, which in turn, are derived from a common base class. It creates an ambiguity that arises from duplicating the common base class, which leads to an ambiguous behavior while calling the duplicate members.\n\nTo resolve this ambiguity, you can use virtual inheritance. A virtual base class is a class that is shared by multiple classes using the virtual keyword in C++. This ensures that only one copy of the base class is inherited in the final derived class, and thus, resolves the diamond inheritance problem.\n\n**Example:**\n```cpp\n#include <iostream>\n\nclass Base {\npublic:\n    void print() {\n        std::cout << \"Base class\" << std::endl;\n    }\n};\n\nclass Derived1 : virtual public Base {\npublic:\n    void derived1Print() {\n        std::cout << \"Derived1 class\" << std::endl;\n    }\n};\n\nclass Derived2 : virtual public Base {\npublic:\n    void derived2Print() {\n        std::cout << \"Derived2 class\" << std::endl;\n    }\n};\n\nclass Derived3 : public Derived1, public Derived2 {\npublic:\n    void derived3Print() {\n        std::cout << \"Derived3 class\" << std::endl;\n    }\n};\n\nint main() {\n    Derived3 d3;\n    d3.print(); // Now, there is no ambiguity in calling the base class function\n    d3.derived1Print();\n    d3.derived2Print();\n    d3.derived3Print();\n\n    return 0;\n}\n```\nIn the code above, `Derived1` and `Derived2` are derived from the `Base` class using virtual inheritance. So, when we create an object of `Derived3` and call the `print()` function from the `Base` class, there is no ambiguity, and the code executes without any issues.",
                "resources": []
              }
            ]
          }
        ]
      },
      "Exception Handling": {
        "description": "Exception handling in C++ is a mechanism to handle errors, anomalies, or unexpected events that can occur during the runtime execution of a program. This allows the program to continue running or exit gracefully when encountering errors instead of crashing abruptly.\n\nC++ provides a set of keywords and constructs for implementing exception handling:\n\n- `try`: Defines a block of code that should be monitored for exceptions.\n- `catch`: Specifies the type of exception to be caught and the block of code that shall be executed when that exception occurs.\n- `throw`: Throws an exception that will be caught and handled by the appropriate catch block.\n- `noexcept`: Specifies a function that doesn’t throw exceptions or terminates the program if an exception is thrown within its scope.\n\n**Example:**\n```cpp\n#include <iostream>\n\nint divide(int a, int b) {\n    if (b == 0) {\n        throw \"Division by zero!\";\n    }\n    return a / b;\n}\n\nint main() {\n    int num1, num2;\n\n    std::cout << \"Enter two numbers for division: \";\n    std::cin >> num1 >> num2;\n\n    try {\n        int result = divide(num1, num2);\n        std::cout << \"The result is: \" << result << std::endl;\n    } catch (const char* msg) {\n        std::cerr << \"Error: \" << msg << std::endl;\n    }\n\n    return 0;\n}\n```\nIn this example, we define a function `divide` that throws an exception if `b` is zero. In the `main` function, we use a `try` block to call `divide` and output the result. If an exception is thrown, it is caught inside the `catch` block, which outputs an error message. This way, we can handle the error gracefully rather than letting the program crash when attempting to divide by zero.\n\n**Standard Exceptions:**\nC++ provides a standard set of exception classes under the `<stdexcept>` library which can be used as the exception type for more specific error handling. Some of these classes include:\n\n- `std::exception`: Base class for all standard exceptions.\n- `std::logic_error`: Represents errors which can be detected statically by the program.\n- `std::runtime_error`: Represents errors occurring during the execution of a program.\n\n**Example:**\n```cpp\n#include <iostream>\n#include <stdexcept>\n\nint divide(int a, int b) {\n    if (b == 0) {\n        throw std::runtime_error(\"Division by zero!\");\n    }\n    return a / b;\n}\n\nint main() {\n    int num1, num2;\n\n    std::cout << \"Enter two numbers for division: \";\n    std::cin >> num1 >> num2;\n\n    try {\n        int result = divide(num1, num2);\n        std::cout << \"The result is: \" << result << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\nIn this example, we modified the `divide` function to throw a `std::runtime_error` instead of a simple string. The `catch` block now catches exceptions derived from `std::exception` and uses the member function `what()` to display the error message.",
        "resources": [],
        "order": 9,
        "options": [
          {
            "name": "Exception Handling in C++",
            "recommendation-type": "opinion",
            "description": "Exception handling is a method used to tackle runtime errors so that normal flow of the program can be maintained. In C++, this is accomplished using three keywords: try, catch, and throw.\n\n**try { … }**\nIn the try block, you write the code that can possibly generate an exception. If an exception is encountered, the control is passed to the relevant catch block to handle the issue.\n\n**Example:**\n```cpp\ntry {\n  // code that might throw an exception\n}\ncatch (...) { ... }\n```\nThe catch block follows the try block and is responsible for handling the exceptions thrown by the try block. There can be multiple catch blocks to handle different types of exceptions.\n\n**Example:**\n```cpp\ncatch (int e) {\n  // handle exception of type int\n}\ncatch (char e) {\n  // handle exception of type char\n}\ncatch (...) {\n  // handle any other exception\n}\n```\n\n**throw … ;**\nIn case an error occurs within the try block, you can use the throw keyword to generate an exception of the specific type. This will then be caught and handled by the corresponding catch block.\n\n**Example:**\n```cpp\ntry {\n  int num1 = 10, num2 = 0;\n  if (num2 == 0) {\n    throw \"Division by zero not allowed!\";\n  } else {\n    int result = num1 / num2;\n    cout << \"Result: \" << result << endl;\n  }\n}\ncatch (const char* e) {\n  cout << \"Error: \" << e << endl;\n}\n```\nIn summary, exception handling in C++ is a technique to handle runtime errors while maintaining the normal flow of the program. The try, catch, and throw keywords are used together to create the structure to deal with exceptions as they occur.",
            "resources": [],
            "options": [
              {
                "name": "Access Violations",
                "recommendation-type": "opinion",
                "description": "An access violation is a specific type of error that occurs when a program attempts to access an illegal memory location. In C++, access violations are most commonly caused by:\n\n- Dereferencing a null or invalid pointer.\n- Accessing an array out of bounds.\n- Reading or writing to memory freed by the user or the operating system.\nIt is crucial to identify access violations because they can lead to unpredictable behavior, application crashes, or corruption of data.\n\nSome examples of access violations are:\n\n**Dereferencing null or invalid pointer**\n```cpp\nint *p = nullptr;\nint x = *p;  // Access violation: trying to access null pointer's content\n```\n\n**Accessing an array out of bounds**\n```cpp\nint arr[5] = {1, 2, 3, 4, 5};\nint y = arr[5];  // Access violation: index out of bounds (valid indices are 0-4)\n```\n\n**Reading or writing to freed memory**\n```cpp\nint* p2 = new int[10];\ndelete[] p2;\np2[3] = 42;  // Access violation: writing to memory that has been freed\n```\n\n**Debugging Access Violations**\nTools like debuggers, static analyzers, and profilers can help identify access violations in your code. For example:\n\n- **Microsoft Visual Studio:** Use the built-in debugger to identify the line of code responsible for the access violation error.\n- **Valgrind:** A popular Linux tool that detects memory leaks and access violations in your C++ programs.\n- **AddressSanitizer:** A runtime memory error detector for C++ that can detect out-of-bounds accesses, memory leaks, and use-after-free errors.",
                "resources": []
              }
            ]
          },
          {
            "name": "Exit Codes",
            "recommendation-type": "opinion",
            "description": "Exit codes, also known as “return codes” or “status codes”, are numeric values that a program returns to the calling environment (usually the operating system) when it finishes execution. These codes are used to indicate the success or failure of a program’s execution.\n\n0 is the standard exit code for a successful execution, while non-zero exit codes typically indicate errors or other exceptional situations. The actual meanings of non-zero exit codes can vary between different applications or systems.\n\nIn C++, you can return an exit code from the main function by using the return statement, or you can use the exit() function, which is part of the C++ Standard Library.\n\n**Example: Using return in main**\n```cpp\n#include <iostream>\n\nint main() {\n    // Some code here...\n\n    if (/*some error condition*/) {\n        std::cout << An error occurred. << std::endl;\n        return 1;\n    }\n\n    // More code here...\n\n    if (/*another error condition*/) {\n        std::cout << Another error occurred. << std::endl;\n        return 2;\n    }\n\n    return 0; // Successful execution\n}\n```\n\n**Example: Using the exit() function**\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nvoid some_function() {\n    // Some code here...\n\n    if (/*some error condition*/) {\n        std::cout << An error occurred. << std::endl;\n        std::exit(1);\n    }\n\n    // More code here...\n}\n\nint main() {\n    some_function();\n\n    // Some other code here...\n\n    return 0; // Successful execution\n}\n```\n\nIn both examples above, the program returns exit codes depending on different error conditions encountered during execution. The codes 1 and 2 are used to distinguish between the two error conditions.",
            "resources": []
          }
        ]
      },
      "Language Concepts": {
        "description": "C++ is a powerful, high-level, object-oriented programming language that offers several key language concepts. These concepts provide the foundation upon which you can build efficient, reliable, and maintainable programs. Here’s a brief summary of some important language concepts in C++.\n\n**Variables and Data Types**\nC++ provides various fundamental data types such as int, float, double, char, and bool to declare and manipulate variables in a program.\n\n```cpp\nint age = 25;\nfloat height = 1.7f;\ndouble salary = 50000.0;\nchar grade = 'A';\nbool isEmployed = true;\n```\n\n**Control Structures**\nControl structures enable you to control the flow of execution of a program. Key control structures in C++ include:\n\n- Conditional statement: if, else, and else if\n- Loop constructs: for, while, and do-while\n- Switch-case construct\n\n```cpp\n// If-else statement\nif (age > 18) {\n    cout << \"You are eligible to vote.\";\n} else {\n    cout << \"You are not eligible to vote.\";\n}\n\n// For loop\nfor (int i = 0; i < 5; i++) {\n    cout << \"Hello World!\";\n}\n```\n\n**Functions**\nFunctions in C++ allow you to break down a large program into small, manageable, and reusable pieces of code.\n\n```cpp\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int sum = add(10, 20);\n    cout << \"The sum is: \" << sum;\n    return 0;\n}\n```\n\n**Arrays and Vectors**\nArrays and Vectors are commonly used data structures to store and manipulate a collection of elements of the same datatype.\n\n```cpp\n// Array\nint marks[] = {90, 80, 95, 85};\n\n// Vector\nvector<int> scores = {10, 20, 30, 40};\n```\n\n**Pointers**\nPointers are variables that store memory addresses of other variables. They enable more efficient handling of memory, and are useful for working with dynamic data structures.\n\n```cpp\nint num = 10;\nint* p = &num; // p stores the address of num\n```\n\n**Structures and Classes**\nStructures and Classes are user-defined data types that allow grouping of variables and functions under a single name.\n\n```cpp\n// Structure\nstruct Student {\n    string name;\n    int age;\n};\n\n// Class\nclass Employee {\npublic:\n    string name;\n    int age;\n    void displayInfo() {\n        cout << \"Name: \" << name << \"\\nAge: \" << age;\n    }\n};\n```\n\n**Inheritance and Polymorphism**\nInheritance is a mechanism that allows a class to inherit properties and methods from a base class. Polymorphism enables you to use a base class type to represent derived class objects.\n\n```cpp\nclass Base {\npublic:\n    void display() {\n        cout << \"This is the base class.\";\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void display() {\n        cout << \"This is the derived class.\";\n    }\n};\n```\n\n**Exception Handling**\nC++ provides a mechanism to handle exceptions (runtime errors) gracefully using try, catch, and throw constructs.\n\n```cpp\ntry {\n    // Code that might throw an exception\n    int result = a / b;\n} catch (const exception &e) {\n    cout << \"Caught an exception: \" << e.what();\n}\n```\n\nThese are some of the key language concepts in C++, which will help you to understand the language better and develop efficient and maintainable applications.",
        "resources": [],
        "order": 10,
        "options": [
          {
            "name": "auto (Automatic Type Deduction)",
            "recommendation-type": "opinion",
            "description": "auto is a keyword in C++ language introduced in C++11, which is used for automatic type deduction. It automatically deduces the type of a variable from the type of its initializer expression at compile time.\n\nThe auto keyword is useful when you are dealing with complex types or when the type of a variable is hard to predict. It can help in writing cleaner and less error-prone code.\n\nHere’s a simple example of using auto for type deduction:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    // Traditional way of declaring a variable:\n    int myInt = 5;\n\n    // Using auto for type deduction:\n    auto myAutoInt = 5; // Automatically deduces the type as 'int'\n\n    // Example with more complex types:\n    std::vector<int> myVector = {1, 2, 3, 4, 5};\n\n    // Without auto, iterating the vector would look like this:\n    for (std::vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n\n    // With auto, the iterator declaration becomes simpler:\n    for (auto it = myVector.begin(); it != myVector.end(); ++it) {\n        std::cout << *it << std::endl;\n    }\n}\n```\n\nKeep in mind that auto deduces the type based on the initializer expression, so if you don’t provide an initial value, you will get a compile-time error:\n\n```cpp\nauto myVar; // Error: Cannot deduce the type without initializer\n```\n\nIn C++14, you can also use auto with function return types to let the compiler automatically deduce the return type based on the returned expression:\n\n```cpp\nauto add(int x, int y) {\n    return x + y; // The compiler deduces the return type as 'int'\n}\n```",
            "resources": []
          },
          {
            "name": "Type Casting in C++",
            "recommendation-type": "opinion",
            "description": "Type casting is the process of converting a value from one data type to another. In C++, there are four different methods of type casting:\n\n1. C-style casting: It is the syntax inherited from C, and it is done by simply putting the target data type in parentheses before the value to cast. Example:\n\n```cpp\nint a = 10;\nfloat b = (float)a;  // C-style cast from int to float\n```\n\n2. static_cast: This is the most commonly used method for type casting in C++. It is performed at compile time, and you should use it when you have an explicit conversion between data types. Example:\n\n```cpp\nint a = 10;\nfloat b = static_cast<float>(a);  // static_cast from int to float\n```\n\n3. dynamic_cast: This method is specifically used for safely converting pointers and references between base and derived classes in a class hierarchy. Example:\n\n```cpp\nclass Base {};\nclass Derived : public Base {};\n\nBase* base_ptr = new Derived();\nDerived* derived_ptr = dynamic_cast<Derived*>(base_ptr);  // dynamic_cast from Base* to Derived*\n```\n\n4. reinterpret_cast: This cast changes the type of a pointer, reference, or an integer value. It is also called a bitwise cast because it changes how the compiler interprets the underlying bits. Use reinterpret_cast only when you have a deep understanding of what you’re doing, as it does not guarantee that the resulting value will be meaningful. Example:\n\n```cpp\nint* a = new int(42);\nlong b = reinterpret_cast<long>(a);  // reinterpret_cast from int* to long\n```\n\n5. const_cast: This casting method is used to remove the const qualifier from a variable. It is generally not recommended but can be useful in certain situations where you have no control over the constness of a variable. Example:\n\n```cpp\nconst int a = 10;\nint* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*\n*ptr = 20;  // Not recommended, use with caution\n```\n\nRemember to use the right type of casting based on the specific situation and follow good programming practices to ensure safe and efficient code.",
            "resources": [
              {
                "name": "Casting in C++",
                "link": "https://youtu.be/pWZS1MtxI-A"
              }
            ],
            "options": [
              {
                "name": "Static Cast",
                "recommendation-type": "opinion",
                "description": "static_cast is one of the casting operators in C++ that allows you to convert between different data types, such as integer and float, or between pointer types. This type of cast performs a compile-time check and gives an error if there is no valid conversion possible between given types. static_cast is generally safer than C-style casts since it does not perform an unsafe reinterpretation of data and allows for better type checking.\n\n**Syntax**\nThe syntax for static_cast is as follows:\n\n```cpp\nstatic_cast<new_type>(expression)\n```\n\n**Examples**\n\n1. Converting between basic data types:\n```cpp\nint i = 42;\nfloat f = static_cast<float>(i); // Converts integer i to float f\n```\n\n2. Casting pointers of different object types in an inheritance hierarchy:\n```cpp\nclass Base { /* ... */ };\nclass Derived : public Base { /* ... */ };\n\nBase *bPtr = new Derived;\nDerived *dPtr = static_cast<Derived *>(bPtr); // Converts Base pointer bPtr to Derived pointer dPtr\n```\n\n3. Converting an integer to an enumeration:\n```cpp\nenum Color { RED, GREEN, BLUE };\nint value = 1;\nColor color = static_cast<Color>(value); // Converts integer value to corresponding Color enumeration\n```\n\nKeep in mind that static_cast should be used with caution when casting pointers between different object types. If the original type of the pointer does not match the target type, the result of the cast can be incorrect or cause unexpected behavior.",
                "resources": []
              },
              {
                "name": "const_cast",
                "recommendation-type": "opinion",
                "description": "const_cast is a type of casting in C++ that allows you to remove or add constness to a variable. In other words, it enables you to modify a const or volatile object, or change a pointer or reference to a const or volatile type. This is useful in certain scenarios when you need to pass a const variable as an argument or when a function parameter requires a non-const type, but you want to make sure the variable remains constant throughout the code.\n\nKeep in mind that using const_cast to modify a truly const variable can lead to undefined behavior, so it is best to use this feature only when absolutely necessary.\n\n**Example**\nHere’s a code example showing how to use const_cast:\n\n```cpp\n#include <iostream>\n\nvoid modifyVariable(int* ptr) {\n    *ptr = 42;\n}\n\nint main() {\n    const int original_value = 10;\n    int* non_const_value_ptr = const_cast<int*>(&original_value);\n    std::cout << \"Original value: \" << original_value << std::endl;\n\n    modifyVariable(non_const_value_ptr);\n    std::cout << \"Modified value: \" << *non_const_value_ptr << std::endl;\n\n    return 0;\n}\n```\n\nIn this example, we first create a const variable, original_value. Then we use const_cast to remove the constness of the variable and assign it to a non-const pointer, non_const_value_ptr. The modifyVariable function takes an int* as an argument and modifies the value pointed to by the pointer, which would not have been possible if we passed the original const int directly. Finally, we print the original_value and the *non_const_value_ptr, which shows that the value has been modified using const_cast.\n\nPlease note that this example comes with some risks, as it touches undefined behavior.",
                "resources": []
              },
              {
                "name": "dynamic_cast",
                "recommendation-type": "opinion",
                "description": "dynamic_cast is a type of casting operator in C++ that is used specifically for polymorphism. It safely converts pointers and references of a base class to its derived class and checks the validity of the conversion during runtime. If the conversion is not valid (i.e., the object is not of the target type), it returns a null pointer instead of producing undefined behavior. Therefore, dynamic_cast can prevent potential crashes and errors when using polymorphism.\n\nHere is a basic example of how dynamic_cast can be used:\n\n```cpp\n#include <iostream>\n\nclass BaseClass {\n   public:\n    virtual void display() {\n        std::cout << \"BaseClass\" << std::endl;\n    }\n};\n\nclass DerivedClass : public BaseClass {\n   public:\n    void display() {\n        std::cout << \"DerivedClass\" << std::endl;\n    }\n};\n\nint main() {\n    BaseClass *basePtr = new DerivedClass();  // Upcasting\n    DerivedClass *derivedPtr;\n\n    derivedPtr = dynamic_cast<DerivedClass >(basePtr);  // Downcasting\n    if (derivedPtr) {\n        derivedPtr->display();  // Output: DerivedClass\n    } else {\n        std::cout << \"Invalid type conversion.\";\n    }\n\n    delete basePtr;\n    return 0;\n}\n```\n\nIn this example, a pointer to a DerivedClass object is assigned to a BaseClass pointer (basePtr). Then, we attempt to downcast it back to a DerivedClass pointer using dynamic_cast. If the casting is successful, we can access the DerivedClass functionality through the new pointer (derivedPtr).",
                "resources": []
              },
              {
                "name": "reinterpret_cast",
                "recommendation-type": "opinion",
                "description": "reinterpret_cast is a type of casting in C++ that allows you to change the type of a pointer or an integer without altering the representation of the data. It is generally used when the conversion required is too low-level or not supported by other casting methods, such as static_cast.\n\nUsing reinterpret_cast should be handled with care, as it can lead to undefined behavior and severe problems if used incorrectly.\n\nHere’s an example of usage:\n\n```cpp\n#include <iostream>\n\nint main() {\n    int num = 42;\n    int *num_ptr = &num;\n\n    // Disguise the integer pointer as a char pointer\n    char *char_ptr = reinterpret_cast<char *>(num_ptr);\n\n    for (size_t i = 0; i < sizeof(int); ++i) {\n        // Print the individual bytes of the integer as characters\n        std::cout << \"Byte \" << i << \": \" << char_ptr[i] << std::endl;\n    }\n\n    return 0;\n}\n```\n\nIn this example, we’re using reinterpret_cast to change the type of a pointer from int * to char *, effectively treating the integer as an array of characters and printing each byte.\n\nRemember that when using reinterpret_cast, you should be cautious about dereferencing the converted pointers. The behavior can be unpredictable, and it can lead to issues, such as accessing memory regions that are not intended to be accessed. reinterpret_cast should be used sparingly and only when a low-level conversion is necessary.",
                "resources": []
              }
            ]
          },
          {
            "name": "Undefined Behavior (UB)",
            "recommendation-type": "opinion",
            "description": "Undefined behavior in C++ refers to a situation where a program’s behavior cannot be predicted due to any violation of the language rules. It is a result of various factors like uninitialized variables, using pointers to deallocated memory, out-of-bounds memory access, etc. The C++ standard does not define the behavior in such cases, which means the compiler or the runtime system is free to handle these situations in any way it wants.\n\nSome common examples of Undefined Behavior are:\n\n1. Uninitialized Variables: Accessing the value of an uninitialized variable can lead to undefined behavior. The value of an uninitialized variable is arbitrary and depends on what was in the memory location before the variable was declared.\n\n```cpp\nint x;\nint y = x + 5; // Undefined behavior since x is uninitialized\n```\n\n2. Out-of-bounds Memory Access: Accessing memory outside the boundaries of an array or buffer may result in undefined behavior.\n\n```cpp\nint arr[5];\nint val = arr[5]; // Undefined behavior since the valid indices are 0 to 4\n```\n\n3. Null Pointer Dereference: Dereferencing a null pointer may lead to undefined behavior.\n\n```cpp\nint *ptr = nullptr;\nint val = *ptr; // Undefined behavior since ptr is a null pointer\n```\n\n4. Division by Zero: Performing a division operation by zero is undefined behavior in C++.\n\n```cpp\nint x = 5;\nint y = 0;\nint z = x / y; // Undefined behavior since division by zero is not allowed\n```\n\nIt is crucial to detect and fix the root cause of undefined behavior in your programs since it can lead to unpredictable results, data corruption, and security vulnerabilities. To mitigate undefined behavior, you can utilize tools like static code analyzers, dynamic analysis tools, and compiler options that help detect potential issues.",
            "resources": []
          },
          {
            "name": "Argument Dependent Lookup (ADL)",
            "recommendation-type": "opinion",
            "description": "Argument Dependent Lookup (ADL) or Koenig Lookup is a mechanism in C++ that allows the compiler to search for the appropriate function to call based on the types of arguments provided. It is particularly helpful when using overloaded functions or operators in a namespace.\n\nADL allows the compiler to find functions in the same namespace as the arguments, even if the function is not declared at the point of use or within the namespace provided. This is especially useful when working with templates or generic programming.\n\nExample:\n\n```cpp\nnamespace MyNamespace {\n    class MyClass {\n    public:\n        int value;\n    };\n\n    std::ostream& operator<<(std::ostream& os, const MyClass& obj) {\n        os << \"MyClass: \" << obj.value;\n        return os;\n    }\n}\n\nint main() {\n    MyNamespace::MyClass obj;\n    obj.value = 42;\n    using std::cout; // Required to use 'cout' without fully qualifying it.\n    cout << obj << std::endl; // ADL is used to find the correct overloaded 'operator<<'.\n}\n```\n\nIn this example, when you call `cout << obj;` in `main()`, ADL is used to find the correct `operator<<()` in the `MyNamespace` namespace because the argument `obj` is of type `MyNamespace::MyClass`.",
            "resources": []
          },
          {
            "name": "Name Mangling",
            "recommendation-type": "opinion",
            "description": "Name mangling, also known as name decoration, is a technique used by compilers to encode additional information about the scope, type, linkage, or other identifying information of an identifier (function names, variable names, etc.) within its name. The primary purpose of name mangling is to support function overloading, which allows multiple functions with the same name but different parameter lists to coexist in a single program.\n\nIn C++, the compiler generates a mangled name for each function and variable based on their scopes and types. The mangled name is usually formed by concatenating the original name, parameter types, and other information, often using a prefix or suffix.\n\nFor example, suppose you have the following function:\n\n```cpp\nint add(int a, int b)\n{\n    return a + b;\n}\n```\nThe compiler might generate a mangled name such as _Z3addii, which encodes the function name add and its two int parameters.\n\nThe exact rules for name mangling are implementation and platform dependent. Different compilers may mangle names differently, which can lead to incompatibilities when attempting to link together object files or libraries compiled with different compilers.\n\nSome tools, such as c++filt (included in GCC and Clang), can be used to demangle a mangled name back to the original identifier, which can be useful when debugging or working with symbol tables.\n\n```bash\n$ echo \"_Z3addii\" | c++filt\nadd(int, int)\n```\n\nIn general, it is not necessary for you to understand the details of name mangling when writing code in C++, as the compiler handles it automatically. However, it can affect program behavior in some cases, such as when using external libraries or linking object files from different compilers.",
            "resources": []
          },
          {
            "name": "C++ Macros",
            "recommendation-type": "opinion",
            "description": "Macros are preprocessing directives in C++ used by the preprocessor to perform text substitution. They are defined using the #define directive, followed by the macro name and the value to be substituted.\n\nMacros can be used to define constants, create function-like macros, or perform conditional compilation.\n\n**Constant Macros**\n\nConstant macros are used to define symbolic constants for use in code. They do not use any memory and are replaced by the preprocessor before the compilation process.\n\nExample:\n\n```cpp\n#define PI 3.14159\n```\n\nThis macro defines a symbolic constant PI. You can use it in your code as if it were a regular variable.\n\n```cpp\ndouble circumference = 2 * PI * radius;\n```\n\n**Function-like Macros**\n\nFunction-like macros are similar to regular functions. They take a list of arguments and perform text substitution.\n\nExample:\n\n```cpp\n#define SQUARE(x) ((x) * (x))\n```\n\nThis macro defines a function-like macro SQUARE that calculates the square of a number.\n\n```cpp\nint square_of_five = SQUARE(5); // expands to ((5) * (5))\n```\n\n**Conditional Compilation**\n\nMacros can be used for conditional compilation using the #ifdef, #ifndef, #if, #else, #elif, and #endif directives.\n\nExample:\n\n```cpp\n#define DEBUG_MODE\n\n#ifdef DEBUG_MODE\n  // Code to be compiled only in debug mode\n#else\n  // Code to be compiled only if DEBUG_MODE is not defined\n#endif\n```\n\nThis example demonstrates how you can use macros to control the parts of code that are being compiled, depending on the presence or absence of a macro definition.",
            "resources": []
          }
        ]
      },
      "Standard Template Library + STL": {
        "description": "The C++ Standard Template Library (STL) is a collection of header files that provide several data structures, algorithms, and functions to simplify your C++ coding experience. The primary purpose of the STL is to save time and increase efficiency by providing a ready-to-use set of useful tools. The most commonly used features of the STL can be divided into three main categories: containers, algorithms, and iterators.\n\n**Containers**\n\nContainers are the data structures used for data storage and manipulation in C++. They are classified into four types: sequence containers, associative containers, unordered associative containers, and container adaptors.\n\n*Sequence Containers:* These are linear data structures that store elements in a sequential manner. Examples include:\n```cpp\nstd::vector<int> my_vector;\nstd::list<int> my_list;\nstd::deque<int> my_deque;\n```\n*Associative Containers:* These containers store data in a sorted manner with unique keys. Examples include:\n```cpp\nstd::set<int> my_set;\nstd::map<std::string, int> my_map;\n```\n*Unordered Associative Containers:* These containers store data in an unordered manner using hash tables. Examples include:\n```cpp\nstd::unordered_set<int> my_unordered_set;\nstd::unordered_map<std::string, int> my_unordered_map;\n```\n*Container Adaptors:* These are containers based on other existing containers. Examples include:\n```cpp\nstd::stack<int> my_stack;\nstd::queue<int> my_queue;\nstd::priority_queue<int> my_priority_queue;\n```\n\n**Algorithms**\n\nThe STL provides several generic algorithms that can be used to perform various operations on the data stored in containers. They are divided into five categories: non-modifying sequence algorithms, modifying sequence algorithms, sorting algorithms, sorted range algorithms, and numeric algorithms. Some examples include std::find, std::replace, std::sort, and std::binary_search.\n\n*For example, to sort a vector:* \n```cpp\nstd::vector<int> my_vec = {4, 2, 5, 1, 3};\nstd::sort(my_vec.begin(), my_vec.end());\n```\n\n**Iterators**\n\nIterators are a fundamental concept in the STL, as they provide a unified way to access elements in containers. Iterators can be thought of as an advanced form of pointers. Each container has its own iterator type, which can be used to traverse elements and modify values. The most common iterator operations are begin() and end() for getting iterators pointing to the first and one past the last element of a container, respectively.\n\n*For example, to iterate through a vector and print its elements:* \n```cpp\nstd::vector<int> my_vec = {1, 2, 3, 4, 5};\nfor(auto it = my_vec.begin(); it != my_vec.end(); ++it) {\n    std::cout << *it << \" \";\n}\n```\n\nThis is just a brief overview of the C++ Standard Template Library. There are many other features and functions available in the STL, and familiarizing yourself with them is crucial for efficient C++ programming.",
        "resources": [],
        "order": 11,
        "options": [
          {
            "name": "iostream",
            "recommendation-type": "opinion",
            "description": "iostream is a header in the C++ Standard Library that provides functionality for basic input and output (I/O) operations. The I/O streams facilitate communication between your program and various sources, such as the console, files, or other programs.\n\niostream includes the following classes:\n\n- istream: for input operations from an input source.\n- ostream: for output operations to an output target.\n- iostream: a combination of istream and ostream for both input and output operations.\n\nThese classes inherit from base classes ios and ios_base.\n\nAdditionally, iostream defines several objects that are instances of these classes and represent the standard input and output streams:\n\n- cin: an istream object to read from the standard input, typically corresponding to the keyboard.\n- cout: an ostream object to write to the standard output, typically the console.\n- cerr: an ostream object to write to the standard error output, typically used for displaying error messages.\n- clog: an ostream object, similar to cerr, but its output can be buffered.\n\nHere are some code examples on using iostream for input and output operations:\n```cpp\n#include <iostream>\n\nint main() {\n    int a;\n    std::cout << \"Enter a number: \";\n    std::cin >> a;\n    std::cout << \"You entered: \" << a << std::endl;\n    return 0;\n}\n```\n```cpp\n#include <iostream>\n\nint main() {\n    std::cerr << \"An error occurred.\" << std::endl;\n    std::clog << \"Logging information.\" << std::endl;\n    return 0;\n}\n```\nRemember to include the iostream header when using these features:\n```cpp\n#include <iostream>\n```\n",
            "resources": [],
            "options": [
              {
                "name": "Iterators",
                "recommendation-type": "opinion",
                "description": "Iterators are objects in the C++ Standard Library (STL) that help us traverse containers like arrays, lists, and vectors. Essentially, they act as a bridge between container classes and algorithms. Iterators behave similar to pointers but provide a more generalized and abstract way of accessing elements in a container.\n\nThere are different types of iterators which you would encounter depending on their use cases:\n\n- Input Iterator: Used to read elements in a container only once, in a forward direction. They cannot modify elements.\nExample:\n```cpp\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::istream_iterator<int> input(std::cin);\nstd::copy(input, std::istream_iterator<int>(), std::back_inserter(nums));\n```\n- Output Iterator: Used to write elements in a container only once, in a forward direction. They cannot re-write elements.\nExample:\n```cpp\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::ostream_iterator<int> output(std::cout, \", \");\nstd::copy(nums.begin(), nums.end(), output);\n```\n- Forward Iterator: Similar to input iterators but can be used for multiple passes over the elements in a container. They cannot move backward.\nExample:\n```cpp\nstd::forward_list<int> nums = {1, 2, 3, 4};\nstd::forward_list<int>::iterator itr = nums.begin();\nwhile (itr != nums.end()) {\n    std::cout << *itr << \" \";\n    ++itr;\n}\n```\n- Reverse Iterator: Similar to input iterators but can be used for multiple passes over the elements in a container. They cannot move forward.\nExample:\n```cpp\nstd::list<int> nums = {1, 2, 3, 4};\nstd::list<int>::reverse_iterator itr = nums.rbegin();\nwhile (itr != nums.rend()) {\n    std::cout << *itr << \" \";\n    ++itr;\n}\n```\n- Bidirectional Iterator: These iterators offer the ability to move both forward and backward in a container. List and set containers have bi-directional iterators.\nExample:\n```cpp\nstd::list<int> nums = {1, 2, 3, 4};\nstd::list<int>::iterator itr;\nfor (itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\nfor (--itr; itr != nums.begin(); --itr) {\n    std::cout << *itr << \" \";\n}\n```\n- Random Access Iterator: These iterators provide the most flexible ways to access elements in a container. They can move forwards, backwards, jump directly to other elements, and access elements at a given index.\nExample:\n```cpp\nstd::vector<int> nums = {1, 2, 3, 4};\nstd::vector<int>::iterator itr;\nfor (itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\nfor (itr -= 1; itr != nums.begin() - 1; --itr) {\n    std::cout << *itr << \" \";\n}\n```\nFor most cases, you would want to start with the auto keyword and the appropriate container methods (like begin() and end()) to work with iterators.\n\nExample:\n```cpp\nstd::vector<int> nums = {1, 2, 3, 4};\nfor (auto itr = nums.begin(); itr != nums.end(); ++itr) {\n    std::cout << *itr << \" \";\n}\n```\nWhen working with algorithms, remember that the C++ Standard Library provides various algorithms that already utilize iterators for tasks like searching, sorting, and manipulating elements.",
                "resources": []
              }
            ]
          },
          {
            "name": "C++ Date Time",
            "recommendation-type": "opinion",
            "description": "In C++, you can work with dates and times using the chrono library, which is part of the Standard Library (STL). The chrono library provides various data types and functions to represent and manipulate time durations, time points, and clocks.\n\n**Duration**\nA duration represents a span of time, which can be expressed in various units such as seconds, minutes, hours, etc. To create a duration, use the std::chrono::duration template class. Common predefined duration types are:\n```cpp\n#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::seconds sec(5);\n    std::chrono::minutes min(2);\n    std::chrono::hours hr(1);\n    return 0;\n}\n```\n**Time Point**\nA time_point represents a specific point in time. It is usually created using a combination of duration and a clock. In C++, there are three clock types provided by the chrono library:\n```cpp\n#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::system_clock::time_point tp = std::chrono::system_clock::now();\n    return 0;\n}\n```\n**Clock**\nA clock provides access to the current time. It consists of the following elements:\n```cpp\n#include <iostream>\n#include <chrono>\n\nint main() {\n    // Get the current time_point using system_clock\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n\n    // Get the time_point 1 hour from now\n    std::chrono::system_clock::time_point one_hour_from_now = now + std::chrono::hours(1);\n    return 0;\n}\n```\n**Converting Time Points to Calendar Time**\nTo convert a time point to calendar representation, you can use the std::chrono::system_clock::to_time_t function.\n```cpp\n#include <iostream>\n#include <chrono>\n#include <ctime>\n\nint main() {\n    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    std::cout << \"Current time: \" << std::ctime(&now_c) << std::endl;\n    return 0;\n}\n```\nThis summarizes the basic functionality of working with date and time in C++ using the chrono library. You can find more advanced features, such as casting durations and time arithmetic, in the C++ reference.",
            "resources": [
              {
                "name": "C++ reference.",
                "link": "https://en.cppreference.com/w/cpp/chrono"
              }
            ],
            "options": [
              {
                "name": "STL Algorithms",
                "recommendation-type": "opinion",
                "description": "The Standard Template Library (STL) in C++ provides a collection of generic algorithms that are designed to work with various container classes. These algorithms are implemented as functions and can be applied to different data structures, such as arrays, vectors, lists, and others. The primary header file for algorithms is <algorithm>.\n\n**Key Concepts**\n\n**Sorting**\nSorting refers to arranging a sequence of elements in a specific order. The STL provides several sorting algorithms, such as std::sort, std::stable_sort, and std::partial_sort.\n```cpp\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {10, 9, 8, 7, 6, 5};\n    std::sort(nums.begin(), nums.end());\n\n    for (int num : nums) {\n        std::cout << num << ' ';\n    }\n    // Output: 5 6 7 8 9 10\n}\n```\n**Searching**\nSearching refers to finding if a particular element is present within a given range of elements. STL provides various searching algorithms, such as std::find, std::binary_search, and std::find_if.\n```cpp\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {5, 6, 7, 8, 9, 10};\n    auto it = std::find(nums.begin(), nums.end(), 9);\n\n    if (it != nums.end()) {\n        std::cout << \"Found 9 at position: \" << (it - nums.begin());\n    } else {\n        std::cout << \"9 not found\";\n    }\n    // Output: Found 9 at position: 4\n}\n```\n**Modifying Sequences**\nThe STL also provides algorithms for modifying sequences, such as std::remove, std::replace, and std::unique.\n```cpp\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {5, 6, 7, 6, 8, 6, 9, 6, 10};\n    nums.erase(std::remove(nums.begin(), nums.end(), 6), nums.end());\n\n    for (int num : nums) {\n        std::cout << num << ' ';\n    }\n    // Output: 5 7 8 9 10\n}\n```\n**Summary**\nSTL algorithms in C++ provide a set of useful functions for key operations such as sorting, searching, and modifying sequences. The algorithms can be used with a variety of container classes, making them highly versatile and an essential part of C++ programming.",
                "resources": []
              }
            ]
          },
          {
            "name": "C++ Containers",
            "recommendation-type": "opinion",
            "description": "C++ Containers are a part of the Standard Template Library (STL) that provide data structures to store and organize data. There are several types of containers, each with its own characteristics and use cases. Here, we discuss some of the commonly used containers:\n\n1. **Vector**\nVectors are dynamic arrays that can resize themselves as needed. They store elements in a contiguous memory location, allowing fast random access using indices.\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n\n    vec.push_back(6); // Add an element to the end\n\n    std::cout << \"Vector contains:\";\n    for (int x : vec) {\n        std::cout << ' ' << x;\n    }\n    std::cout << std::endl;\n}\n```\n2. **List**\nA list is a doubly-linked list that allows elements to be inserted or removed from any position in constant time. It does not support random access. Lists are better than vectors for scenarios where you need to insert or remove elements in the middle frequently.\n```cpp\n#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> lst = {1, 2, 3, 4, 5};\n\n    lst.push_back(6); // Add an element to the end\n    \n    std::cout << \"List contains:\";\n    for (int x : lst) {\n        std::cout << ' ' << x;\n    }\n    std::cout << std::endl;\n}\n```\n3. **Map**\nA map is an associative container that stores key-value pairs. It supports the retrieval of values based on their keys. The keys are sorted in ascending order by default.\n```cpp\n#include <iostream>\n#include <map>\n\nint main() {\n    std::map<std::string, int> m;\n\n    m[\"one\"] = 1;\n    m[\"two\"] = 2;\n\n    std::cout << \"Map contains:\" << std::endl;\n    for (const auto &pair : m) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n}\n```\n4. **Unordered_map**\nSimilar to a map, an unordered map stores key-value pairs, but it is implemented using a hash table. This means unordered_map has faster average-case performance compared to map, since it does not maintain sorted order. However, worst-case performance can be worse than map.\n```cpp\n#include <iostream>\n#include <unordered_map>\n\nint main() {\n    std::unordered_map<std::string, int> um;\n\n    um[\"one\"] = 1;\n    um[\"two\"] = 2;\n\n    std::cout << \"Unordered map contains:\" << std::endl;\n    for (const auto &pair : um) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n}\n```\nThese are just a few examples of C++ containers. There are other container types, such as set, multiset, deque, stack, queue, and priority_queue. Each container has its own use cases and unique characteristics. Learning about these containers and when to use them can greatly improve your efficiency and effectiveness in using C++.",
            "resources": [],
            "options": [
              {
                "name": "Multithreading in C++",
                "recommendation-type": "opinion",
                "description": "Multithreading is the concurrent execution of multiple threads within a single process or program. It improves the performance and efficiency of an application by allowing multiple tasks to be executed in parallel.\n\nIn C++, multithreading support is available through the thread library introduced in the C++11 standard.\n\n**Basic Thread Creation**\nTo create a new thread, include the <thread> header file and create an instance of std::thread that takes a function as an argument. The function will be executed in a new thread.\n```cpp\n#include <iostream>\n#include <thread>\n\nvoid my_function() {\n    std::cout << \"This function is executing in a separate thread\" << std::endl;\n}\n\nint main() {\n    std::thread t(my_function);\n    t.join(); // waits for the thread to complete\n    return 0;\n}\n```\n**Thread with Arguments**\nYou can pass arguments to the thread function by providing them as additional arguments to the std::thread constructor.\n```cpp\n#include <iostream>\n#include <thread>\n\nvoid print_sum(int a, int b) {\n    std::cout << \"The sum is: \" << a + b << std::endl;\n}\n\nint main() {\n    std::thread t(print_sum, 3, 5);\n    t.join();\n    return 0;\n}\n```\n**Mutex and Locks**\nWhen multiple threads access shared resources, there is a possibility of a data race. To avoid this, use mutex and locks to synchronize shared resource access.\n```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\n\nstd::mutex mtx;\n\nvoid print_block(int n, char c) {\n    {\n        std::unique_lock<std::mutex> locker(mtx);\n        for (int i = 0; i < n; ++i) {\n            std::cout << c;\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    std::thread t1(print_block, 50, '*');\n    std::thread t2(print_block, 50, '$');\n\n    t1.join();\n    t2.join();\n\n    return 0;\n}\n```\nThis short introduction should help you get started with basic multithreading techniques in C++. There is a lot more to learn, such as thread pools, condition variables, and atomic operations for advanced synchronization and performance tuning.",
                "resources": []
              }
            ]
          }
        ]
      },
      "Templates": {
        "description": "Templates in C++ are a powerful feature that allows you to write generic code, meaning that you can write a single function or class that can work with different data types. This means you do not need to write separate functions or classes for each data type you want to work with.\n\n**Template Functions**\nTo create a template function, you use the template keyword followed by the type parameters or placeholders enclosed in angle brackets (< >). Then, you define your function as you normally would, using the type parameters to specify the generic types.\n\nHere’s an example of a simple template function that takes two arguments and returns the larger of the two:\n```cpp\n#include <iostream>\n\n template <typename T> T max(T a, T b) { return (a > b) ? a : b; }\n```\nTo use this function, you can either explicitly specify the type parameter:\n```cpp\nint result = max<int>(10, 20);\n```\nOr, you can let the compiler deduce the type for you:\n```cpp\nint result = max(10, 20);\n```\n\n**Template Classes**\nSimilarly, you can create template classes using the template keyword. Here’s an example of a simple template class that represents a pair of values:\n```cpp\n#include <iostream>\n\n template <typename T1, typename T2> class Pair { public: T1 first; T2 second; Pair(T1 first, T2 second) : first(first), second(second) {} };\n```\nTo use this class, you need to specify the type parameters when creating an object:\n```cpp\nPair<int, std::string> pair(1, \"Hello\");\n```\n\n**Template Specialization**\nSometimes, you may need special behavior for a specific data type. In this case, you can use template specialization. For example, you can specialize the Pair class for a specific type, like char:\n```cpp\n#include <cctype>\n\n template <> class Pair<char, char> { public: char first; char second; Pair(char first, char second) : first(first), second(second) { this->first = std::toupper(this->first); this->second = std::toupper(this->second); } };\n```\nNow, when you create a Pair object with char template arguments, the specialized behavior will be used:\n```cpp\nPair<char, char> charPair('a', 'b');\n```\nIn summary, templates in C++ allow you to write generic functions and classes that can work with different data types, reducing code duplication and making your code more flexible and reusable.",
        "resources": [],
        "order": 12,
        "module bundlers": {
          "options": [
            {
              "name": "Variadic Templates",
              "recommendation-type": "opinion",
              "description": "Variadic templates are a feature in C++11 that allows you to define a template with a variable number of arguments. This is especially useful when you need to write a function or class that can accept different numbers and types of arguments.\n\n**Syntax**\nThe syntax for variadic templates is very simple. To define a variadic template, use the ... (ellipsis) notation:\n```cpp\ntemplate <typename... Args>\n```\nThis notation represents a parameter pack, which can contain zero or more arguments. You can use this parameter pack as a variable list of template parameters in your template definition.\n\n**Examples**\n\n**Summing Multiple Arguments Using Variadic Templates**\n```cpp\n#include <iostream>\n\n// Base case for recursion\ntemplate <typename T>\nT sum(T t) {\n  return t;\n}\n\n// Variadic template\ntemplate <typename T, typename... Args>\nT sum(T t, Args... args) {\n  return t + sum(args...);\n}\n\nint main() {\n  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5\n  std::cout << \"The sum is: \" << result << std::endl;\n\n  return 0;\n}\n```\n\n**Tuple Class Using Variadic Templates**\n```cpp\ntemplate <typename... Types>\nclass Tuple;\n\n// Base case: empty tuple\ntemplate <>\nclass Tuple<> {};\n\n// Recursive case: Tuple with one or more elements\ntemplate <typename Head, typename... Tail>\nclass Tuple<Head, Tail...> : public Tuple<Tail...> {\n public:\n  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}\n\n  Head head() const { return head_; }\n\n private:\n  Head head_;\n};\n\nint main() {\n  Tuple<int, float, double> tuple(1, 2.0f, 3.0);\n  std::cout << \"First element: \" << tuple.head() << std::endl;\n  return 0;\n}\n```\nPlease note that the examples shown are for educational purposes and might not be the most efficient or production-ready implementations. With C++17 and onward, there are even more concise ways to handle variadic templates, like using fold expressions.",
              "resources": []
            },
            {
              "name": "Template Specialization",
              "recommendation-type": "opinion",
              "description": "Template specialization is a way to customize or modify the behavior of a template for a specific type or a set of types. This can be useful when you want to optimize the behavior or provide specific implementation for a certain type, without affecting the overall behavior of the template for other types.\n\nThere are two main ways you can specialize a template:\n\n**Full specialization:** This occurs when you provide a specific implementation for a specific type or set of types.\n\n**Partial specialization:** This occurs when you provide a more general implementation for a subset of types that match a certain pattern or condition.\n\n**Full Template Specialization**\n\nFull specialization is used when you want to create a separate implementation of a template for a specific type. To do this, you need to use keyword template<> followed by the function template with the desired specialized type.\n\n```cpp\n#include <iostream>\n\ntemplate <typename T>\nvoid printData(const T& data) {\n    std::cout << \"General template: \" << data << std::endl;\n}\n\ntemplate <>\nvoid printData(const char* const & data) {\n    std::cout << \"Specialized template for const char*: \" << data << std::endl;\n}\n\nint main() {\n    int a = 5;\n    const char* str = \"Hello, world!\";\n    printData(a); // General template: 5\n    printData(str); // Specialized template for const char*: Hello, world!\n}\n```\n\n**Partial Template Specialization**\n\nPartial specialization is used when you want to create a separate implementation of a template for a subset of types that match a certain pattern or condition.\n\n```cpp\n#include <iostream>\n\ntemplate <typename K, typename V>\nclass MyPair {\npublic:\n    MyPair(K k, V v) : key(k), value(v) {}\n\n    void print() const {\n        std::cout << \"General template: key = \" << key << \", value = \" << value << std::endl;\n    }\n\nprivate:\n    K key;\n    V value;\n};\n\ntemplate <typename T>\nclass MyPair<T, int> {\npublic:\n    MyPair(T k, int v) : key(k), value(v) {}\n\n    void print() const {\n        std::cout << \"Partial specialization for int values: key = \" << key\n                  << \", value = \" << value << std::endl;\n    }\n\nprivate:\n    T key;\n    int value;\n};\n\nint main() {\n    MyPair<double, std::string> p1(3.2, \"example\");\n    MyPair<char, int> p2('A', 65);\n    p1.print(); // General template: key = 3.2, value = example\n    p2.print(); // Partial specialization for int values: key = A, value = 65\n}\n```\nIn this example, the MyPair template class is partially specialized to provide a different behavior when the second template parameter is of type int.",
              "resources": [],
              "options": [
                {
                  "name": "Full Template Specialization",
                  "recommendation-type": "opinion",
                  "description": "Full template specialization allows you to provide a specific implementation, or behavior, for a template when used with a certain set of type parameters. It is useful when you want to handle special cases or optimize your code for specific types.\n\n**Syntax**\n\nTo create a full specialization of a template, you need to define the specific type for which the specialization should happen. The syntax looks as follows:\n\n```cpp\ntemplate <> //Indicates that this is a specialization\nclassName<specificType> //The specialized class for the specific type\n```\n\n**Example**\n\nConsider the following example to demonstrate full template specialization:\n\n```cpp\n// Generic template\ntemplate <typename T>\nclass MyContainer {\npublic:\n    void print() {\n        std::cout << \"Generic container.\" << std::endl;\n    }\n};\n\n// Full template specialization for int\ntemplate <>\nclass MyContainer<int> {\npublic:\n    void print() {\n        std::cout << \"Container for integers.\" << std::endl;\n    }\n};\n\nint main() {\n    MyContainer<double> d;\n    MyContainer<int> i;\n\n    d.print(); // Output: Generic container.\n    i.print(); // Output: Container for integers.\n\n    return 0;\n}\n```\n\nIn this example, we defined a generic MyContainer template class along with a full specialization for int type. When we use the container with the int type, the specialized implementation’s print method is called. For other types, the generic template implementation will be used.",
                  "resources": []
                },
                {
                  "name": "Partial Template Specialization",
                  "recommendation-type": "opinion",
                  "description": "Partial template specialization is a concept in C++ templates, which allows you to specialize a template for a subset of its possible type arguments. It is particularly useful when you want to provide a customized implementation for a particular group of types without having to define separate specializations for all types in that group.\n\nPartial template specialization is achieved by providing a specialization of a template with a new set of template parameters. This new template will be chosen when the compiler deduces the types that match the partial specialization.\n\nHere is a code example that demonstrates partial template specialization:\n\n```cpp\n// Primary template\ntemplate <typename T>\nstruct MyTemplate {\n    static const char* name() {\n        return \"General case\";\n    }\n};\n\n// Partial specialization for pointers\ntemplate <typename T>\nstruct MyTemplate<T*> {\n    static const char* name() {\n        return \"Partial specialization for pointers\";\n    }\n};\n\n// Full specialization for int\ntemplate <>\nstruct MyTemplate<int> {\n    static const char* name() {\n        return \"Full specialization for int\";\n    }\n};\n\nint main() {\n    MyTemplate<double> t1; // General case\n    MyTemplate<double*> t2; // Partial specialization for pointers\n    MyTemplate<int> t3; // Full specialization for int\n\n    std::cout << t1.name() << std::endl;\n    std::cout << t2.name() << std::endl;\n    std::cout << t3.name() << std::endl;\n\n    return 0;\n}\n```\n\nIn the example above, we have defined a primary template MyTemplate with a single type parameter T. We then provide a partial template specialization for pointer types by specifying MyTemplate<T*>. This means that the partial specialization will be chosen when the type argument is a pointer type.\n\nLastly, we provide a full specialization for the int type by specifying MyTemplate<int>. This will be chosen when the type argument is int.\n\nWhen running this example, the output will be:\n\nGeneral case\nPartial specialization for pointers\nFull specialization for int\n\nThis demonstrates that the partial specialization works as expected, and is chosen for pointer types, while the full specialization is chosen for the int type.",
                  "resources": []
                }
              ]
            },
            {
              "name": "Type Traits",
              "recommendation-type": "opinion",
              "description": "Type Traits are a set of template classes in C++ that help in getting the information about the type’s properties, behavior, or characteristics. They can be found in the <type_traits> header file. By using Type Traits, you can adapt your code depending on the properties of a given type, or even enforce specific properties for your type parameters in template code.\n\nSome common type traits are:\n\n- std::is_pointer: Checks if a given type is a pointer type.\n- std::is_arithmetic: Checks if the given type is an arithmetic type.\n- std::is_function: Checks if the given type is a function type.\n- std::decay: Applies decltype rules to the input type ( strips references, cv-qualifiers, etc. ).\n\nUsage:\n```cpp\n#include <iostream>\n#include <type_traits>\n\nint main() {\n    int a;\n    int* a_ptr = &a;\n\n    std::cout << \"Is 'a' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;\n    std::cout << \"Is 'a_ptr' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;\n\n    return 0;\n}\n```\n\nComposing Type Traits:\n```cpp\n#include <iostream>\n#include <type_traits>\n\n\ntemplate <typename T>\ntypename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int max = find_max(10, 20);\n    std::cout << \"Max: \" << max << std::endl;\n\n    return 0;\n}\n```\n\nIn this example, the find_max template function is only defined when T is an arithmetic type (e.g., int, float, double). This prevents unintended usage of the find_max function with non-arithmetic types.\n\nOverall, type traits are a powerful tool to create more generic, extensible, and efficient C++ code, providing a way to query and adapt your code based on type characteristics.",
              "resources": []
            },
            {
              "name": "SFINAE (Substitution Failure Is Not An Error)",
              "recommendation-type": "opinion",
              "description": "SFINAE is a principle in C++ template metaprogramming that allows the compiler to select the appropriate function or class when a specific template specialization fails during substitution. The term “substitution failure” refers to the process where the compiler tries to substitute template arguments into a function template or class template. If the substitution causes an error, the compiler won’t consider that specific specialization as a candidate and will continue searching for a valid one.\n\nThe key idea behind SFINAE is that if a substitution error occurs, it is silently ignored, and the compiler continues to explore other template specializations or overloads. This allows you to write more flexible and generic code, as it enables you to have multiple specializations for different scenarios.\n\nCode Example:\n```cpp\n#include <iostream>\n#include <type_traits>\n\n// ... (code example provided in the original text)\n```\nIn this example, we define two foo_impl functions are specialized based on the boolean value of std::is_arithmetic<T>. The first one is enabled when T is an arithmetic type, while the second one is enabled when T is not an arithmetic type. The foo function then calls the appropriate foo_impl specialization based on the result of the type trait.\n\nWhen calling foo(a) with an integer, the first specialization is selected, and when calling foo(s) with a string, the second specialization is selected. If there is no valid specialization, the code would fail to compile.",
              "resources": []
            }
          ]
        }
      },
      "Idioms": {
        "description": "C++ idioms are well-established patterns or techniques that are commonly used in C++ programming to achieve a specific outcome. They help make code efficient, maintainable, and less error-prone. Here are some of the common C++ idioms:\n\n1. Resource Acquisition is Initialization (RAII)\nThis idiom ensures that resources are always properly acquired and released by tying their lifetime to the lifetime of an object. When the object gets created, it acquires the resources and when it gets destroyed, it releases them.\n\n```cpp\n// Example code provided in the original text\n```\n\n2. Rule of Three\nIf a class defines any one of the following, it should define all three: copy constructor, copy assignment operator, and destructor.\n\n```cpp\n// Example code provided in the original text\n```\n\n3. Rule of Five\nWith C++11, the rule of three was extended to five, covering move constructor and move assignment operator.\n\n```cpp\n// Example code provided in the original text\n```\n\n4. PImpl (Pointer to Implementation) Idiom\nThis idiom is used to separate the implementation details of a class from its interface, resulting in faster compile times and the ability to change implementation without affecting clients.\n\n```cpp\n// Example code provided in the original text\n```\n\n5. Non-Virtual Interface (NVI)\nThis enforces a fixed public interface and allows subclasses to only override specific private or protected virtual methods.\n\n```cpp\n// Example code provided in the original text\n```\n\nThese are just a few examples of the many idioms in C++ programming. They can provide guidance when designing and implementing your code, but it’s essential to understand the underlying concepts to adapt them to different situations.",
        "resources": [],
        "order": 13,
        "options": [
          {
            "name": "RAII (Resource Acquisition Is Initialization)",
            "recommendation-type": "opinion",
            "description": "RAII is a popular idiom in C++ that focuses on using the object’s life cycle to manage resources. It encourages binding the resource lifetime to the scope of a corresponding object so that it’s automatically acquired when an object is created and released when the object is destroyed. This helps in simplifying the code, avoiding leaks and managing resources efficiently.\n\nCode Examples\nHere’s an example of using RAII to manage resources, specifically a dynamically allocated array:\n\n```cpp\n// Example code provided in the original text\n```\n\nUsages:\n\n```cpp\n// Example code provided in the original text\n```\n\nAnother common use case is managing a mutex lock:\n\n```cpp\n// Example code provided in the original text\n```\n\nUsages:\n\n```cpp\n// Example code provided in the original text\n```\n\nIn both examples, the constructor acquires the resource (memory for the array and the lock for the mutex), and the destructor takes care of releasing them. This way, the resource management is tied to the object’s lifetime, and the resource is correctly released even in case of an exception being thrown.",
            "resources": [],
            "options": [
              {
                "name": "Pimpl Idiom",
                "recommendation-type": "opinion",
                "description": "Pimpl (Pointer-to-Implementation) idiom, also known as a private class data, compiler firewall, or handle classes, is a technique used in C++ to hide the implementation details of a class by using a forward declaration to a private structure or class, keeping the public interface of the class clean, and reducing compile-time dependencies.\n\n**Implementation**\n\nHere is a simple example illustrating the Pimpl idiom:\n\n```cpp\n// my_class.h\n\nclass MyClass_Impl; // forward declaration\n\nclass MyClass\n{\npublic:\n    MyClass();\n    ~MyClass();\n    void some_method();\n\nprivate:\n    MyClass_Impl *pimpl; // pointer to the implementation\n};\n\n// my_class.cpp\n\n#include \"my_class.h\"\n#include <iostream>\n\nclass MyClass_Impl // the actual implementation\n{\npublic:\n    void some_method()\n    {\n        std::cout << \"Implementation method called!\" << std::endl;\n    }\n};\n\nMyClass::MyClass() : pimpl(new MyClass_Impl()) {} // constructor\n\nMyClass::~MyClass() { delete pimpl; } // destructor\n\nvoid MyClass::some_method()\n{\n    pimpl->some_method(); // delegation to the implementation\n}\n```\n\nNow, all the public methods of MyClass will delegate the calls to the corresponding methods of MyClass_Impl. By doing this, you can hide the details of class implementation, reduce the compile-time dependencies, and ease the maintenance of your code.",
                "resources": []
              },
              {
                "name": "CRTP (Curiously Recurring Template Pattern)",
                "recommendation-type": "opinion",
                "description": "The Curiously Recurring Template Pattern (CRTP) is a C++ idiom that involves a class template being derived from its own specialization. This pattern allows for the creation of static polymorphism, which differs from regular runtime polymorphism that relies on virtual functions and inheritance.\n\nCRTP is usually employed when you want to customize certain behavior in the base class without adding the overhead of a virtual function call. In short, CRTP can be used for achieving compile-time polymorphism without the runtime performance cost.\n\nHere’s an example demonstrating CRTP:\n\n```cpp\ntemplate <typename Derived>\nclass Base {\npublic:\n    void interface() {\n        static_cast<Derived*>(this)->implementation();\n    }\n\n    void implementation() {\n        std::cout << \"Default implementation in Base\" << std::endl;\n    }\n};\n\nclass Derived1 : public Base<Derived1> {\npublic:\n    void implementation() {\n        std::cout << \"Custom implementation in Derived1\" << std::endl;\n    }\n};\n\nclass Derived2 : public Base<Derived2> {\n    // No custom implementation, so Base::implementation will be used.\n};\n\nint main() {\n    Derived1 d1;\n    d1.interface();  // Output: \"Custom implementation in Derived1\"\n\n    Derived2 d2;\n    d2.interface();  // Output: \"Default implementation in Base\"\n\n    return 0;\n}\n```\n\nIn this example, the Base class is a template that takes a single type parameter. Derived1 and Derived2 are derived from their respective specialization of Base. CRTP is employed to allow custom implementations of the implementation() function in derived classes while providing a default behavior in the Base class. The interface() function in the Base class is a template for the derived class’s behavior and calls the corresponding implementation() function based on the static type.\n\nThis pattern enables you to override certain behavior in derived classes with additional functionality, all while avoiding the overhead of virtual function calls and, in turn, achieving a higher degree of efficiency at runtime.",
                "resources": []
              }
            ]
          },
          {
            "name": "Non-Copyable",
            "recommendation-type": "opinion",
            "description": "The non-copyable idiom is a C++ design pattern that prevents objects from being copied or assigned. It’s usually applied to classes that manage resources, like file handles or network sockets, where copying the object could cause issues like resource leaks or double deletions.\n\nTo make a class non-copyable, you need to delete the copy constructor and the copy assignment operator. This can be done explicitly in the class declaration, making it clear to other programmers that copying is not allowed.\n\nHere’s an example of how to apply the non-copyable idiom to a class:\n\n```cpp\n#include <iostream>\n\nclass NonCopyable {\npublic:\n  NonCopyable() = default;\n  ~NonCopyable() = default;\n\n  // Delete the copy constructor\n  NonCopyable(const NonCopyable&) = delete;\n\n  // Delete the copy assignment operator\n  NonCopyable& operator=(const NonCopyable&) = delete;\n};\n```\n\nTo use the idiom, simply inherit from the NonCopyable class:\n\n```cpp\nclass MyClass : private NonCopyable {\n  // MyClass is now non-copyable\n};\n```\n\nThis ensures that any attempt to copy or assign objects of MyClass will result in a compilation error, thus preventing unwanted behavior.",
            "resources": []
          },
          {
            "name": "Erase-remove idiom",
            "recommendation-type": "opinion",
            "description": "The erase-remove idiom is a common C++ technique to efficiently remove elements from a container, particularly from standard sequence containers like std::vector, std::list, and std::deque. It leverages the standard library algorithms std::remove (or std::remove_if) and the member function erase().\n\nThe idiom consists of two steps:\n1. std::remove (or std::remove_if) moves the elements to be removed towards the end of the container and returns an iterator pointing to the first element to remove.\n2. container.erase() removes the elements from the container using the iterator obtained in the previous step.\n\nHere’s an example:\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> numbers = {1, 3, 2, 4, 3, 5, 3};\n    numbers.erase(std::remove(numbers.begin(), numbers.end(), 3), numbers.end());\n\n    for (int number : numbers) {\n        std::cout << number << \" \";\n    }\n\n    return 0;\n}\n```\n\nOutput:\n\n```\n1 2 4 5\n```",
            "resources": []
          },
          {
            "name": "Copy and Swap",
            "recommendation-type": "opinion",
            "description": "Copy-swap is a C++ idiom that leverages the copy constructor and swap function to create an assignment operator. It follows a simple, yet powerful paradigm: create a temporary copy of the right-hand side object, and swap its contents with the left-hand side object.\n\nHere’s a brief summary:\n\n1. **Copy**: Create a local copy of the right-hand side object. This step leverages the copy constructor, providing exception safety and code reuse.\n2. **Swap**: Swap the contents of the left-hand side object with the temporary copy. This step typically involves swapping internal pointers or resources, without needing to copy the full contents again.\n3. **Destruction**: Destroy the temporary copy. This happens upon the exit of the assignment operator.\n\nHere’s a code example for a simple String class:\n\n```cpp\n#include <algorithm>\n\nclass String {\n    // ... rest of the class ...\n\n    String(const String& other);\n    \n    void swap(String& other) {\n        using std::swap; // for arguments-dependent lookup (ADL)\n        swap(size_, other.size_);\n        swap(buffer_, other.buffer_);\n    }\n\n    String& operator=(String other) {\n        swap(other);\n        return *this;\n    }\n};\n```\n\nUsing the copy-swap idiom:\n\n- The right-hand side object is copied when passed by value to the assignment operator.\n- The left-hand side object’s contents are swapped with the temporary copy.\n- The temporary copy is destroyed, releasing any resources that were previously held by the left-hand side object.\n\nThis approach simplifies the implementation and provides strong exception safety, while reusing the copy constructor and destructor code.",
            "resources": []
          },
          {
            "name": "Copy-Write Idiom",
            "recommendation-type": "opinion",
            "description": "The Copy-Write idiom, sometimes called the Copy-on-Write (CoW) or “lazy copying” idiom, is a technique used in programming to minimize the overhead of copying large objects. It helps in reducing the number of actual copy operations by using shared references to objects and only copying the data when it’s required for modification.\n\nLet’s understand this with a simple example:\n\n```cpp\n#include <iostream>\n#include <memory>\n\nclass MyString {\npublic:\n    MyString(const std::string &str) : data(std::make_shared<std::string>(str)) {}\n\n    // Use the same shared data for copying.\n    MyString(const MyString &other) : data(other.data) { \n        std::cout << \"Copied using the Copy-Write idiom.\" << std::endl;\n    }\n\n    // Make a copy only if we want to modify the data.\n    void write(const std::string &str) {\n        // Check if there's more than one reference.\n        if(!data.unique()) {\n            data = std::make_shared<std::string>(*data);\n            std::cout << \"Copy is actually made for writing.\" << std::endl;\n        }\n        *data = str;\n    }\n\nprivate:\n    std::shared_ptr<std::string> data;\n};\n\nint main() {\n    MyString str1(\"Hello\");\n    MyString str2 = str1; // No copy operation, just shared references.\n\n    str1.write(\"Hello, World!\"); // This is where the actual duplication happens.\n    return 0;\n}\n```\n\nIn this example, we have a class MyString that simulates the Copy-Write idiom. When a MyString object is created, it constructs a shared_ptr pointing to a string. When a MyString object is copied, it does not perform any actual copy operation, but simply increases the reference count of the shared object. Finally, when the write function is called, it checks if there’s more than one reference to the data and if so, it actually creates a new copy and updates the reference. This way, unnecessary copies can be avoided until they are actually needed for modification.",
            "resources": []
          }
        ]
      },
      "Standards": {
        "description": "C++ standards are a set of rules and guidelines that define the language’s features, syntax, and semantics. The International Organization for Standardization (ISO) is responsible for maintaining and updating the C++ standards. The main purpose of the standards is to ensure consistency, efficiency, and maintainability across multiple platforms and compilers.\n\nHere’s a brief summary of the different C++ standards released to date:\n\nC++98/C++03: The first standardized version of C++, which introduced many features like templates, exceptions, and the Standard Template Library (STL). C++03 is a minor update to C++98 with some bug fixes and performance improvements.\n\nC++11: A major upgrade to the language, which introduced features such as:\n\nLambda expressions:\nauto sum = [](int a, int b) -> int { return a + b; };\nRange-based for loops:\nstd::vector<int> numbers = {1, 2, 3, 4};\nfor (int num : numbers) {\n    std::cout << num << std::endl;\n}\nSmart pointers like std::shared_ptr and std::unique_ptr.\n\nC++14: A minor update to C++11, which added features such as:\n\nGeneric lambda expressions:\nauto generic_sum = [](auto a, auto b) { return a + b; };\nBinary literals:\nint binary_number = 0b1010;\n\nC++17: Another major update that introduced features such as:\n\nif and switch with initializers:\nif (auto it = my_map.find(key); it != my_map.end()) {\n    // use 'it' here\n}\nStructured bindings:\nstd::map<std::string, int> my_map = {{A, 1}, {B, 2}};\nfor (const auto& [key, value] : my_map) {\n    // use 'key' and 'value' here\n}\n\nC++20: The latest major update to the language, with features such as:\n\nConcepts:\ntemplate<typename T>\nconcept Addable = requires(T a, T b) {\n    { a + b } -> std::same_as<T>;\n};\nRanges:\nstd::vector<int> numbers = {1, 2, 3, 4};\nauto doubled = numbers | std::views::transform([](int n) { return n * 2; });\nCoroutines and more.\n\nRemember that to use these language features, you might need to configure your compiler to use the specific C++ standard version. For example, with GCC or Clang, you can use the -std=c++11, -std=c++14, -std=c++17, or -std=c++20 flags.",
        "resources": [],
        "order": 14,
        "options": [
          {
            "description": "C++11\nThe C++11 standard, also known as C++0x, was officially released in September 2011. It introduced several new language features and improvements, including:\n\nAuto: Allows compiler to infer the variable type based on its initializing expression.\n\nauto integer = 42; // integer is of int type\nauto floating = 3.14; // floating is of double type\nRange-Based for Loop: Provides foreach-like semantics for iterating through a container or array.\n\nstd::vector<int> numbers {1, 2, 3, 4};\nfor (int number : numbers) {\n    std::cout << number << std::endl;\n}\nLambda Functions: Anonymous functions that allow the creation of function objects more easily.\n\nauto add = [](int a, int b) -> int { return a + b; };\nint sum = add(42, 13); // sum is equal to 55\nnullptr: A new keyword to represent null pointers, more type-safe than using a literal ‘0’ or “NULL”.\n\nint *ptr = nullptr;\nThread Support Library: Provides a standard way to work with threads and synchronize data access across threads.\n\nstd::thread t([]() { std::cout << \"Hello from another thread\\n\"; });\nt.join();\n\nC++14\nThe C++14 standard was officially released in December 2014 as a small extension over C++11, focusing more on fine-tuning language features and fixing issues. Some of the new features introduced:\n\nGeneric Lambdas: Allows lambda function parameters to be declared with ‘auto’ type placeholders.\n\nauto add = [](auto a, auto b) { return a + b; };\nauto sum_i = add(42, 13); // Still works with integers\nauto sum_f = add(3.14, 2.72); // Now works with doubles too\nBinary Literals: Allow you to input integers as binary literals for better readability.\n\nint b = 0b110101; // Decimal value is 53\ndecltype(auto): Deduces the type of variable to match that of the expression it is initialized with.\n\nauto func = [](auto a, auto b) { return a * b; };\ndecltype(auto) result = func(5, 3.14); // decltype(auto) deduces to \"double\"\nVariable Templates: Allows you to define variables with template parameters.\n\ntemplate <typename T>\nconstexpr T pi = T(3.1415926535897932385);\nfloat r = pi<float>; // Instantiated as a float\ndouble d = pi<double>; // Instantiated as a double",
            "resources": []
          },
          {
            "name": "C++17",
            "recommendation-type": "opinion",
            "description": "C++17, also known as C++1z, is the version of the C++ programming language published in December 2017. It builds upon the previous standard, C++14, and adds various new features and enhancements to improve the language’s expressiveness, performance, and usability.\n\n**Key Features:**\n\n- **If-init-statement:** Introduces a new syntax for writing conditions with scope inside if and switch statements.\n  ```cpp\n  if(auto it = map.find(key); it != map.end())\n  {\n      // Use it\n  }\n  ```\n\n- **Structured Binding Declarations:** Simplify the process of unpacking a tuple, pair, or other aggregate types.\n  ```cpp\n  map<string, int> data;\n  auto [iter, success] = data.emplace(\"example\", 42);\n  ```\n\n- **Inline variables:** Enables inline keyword for variables and allows a single definition of global and class static variables in header files.\n  ```cpp\n  inline int globalVar = 0;\n  ```\n\n- **Folds expressions:** Introduce fold expressions for variadic templates.\n  ```cpp\n  template <typename... Ts>\n  auto sum(Ts... ts)\n  {\n      return (ts + ...);\n  }\n  ```\n\n- **constexpr if statement:** Allows conditional compilation during compile time.\n  ```cpp\n  template <typename T>\n  auto get_value(T t)\n  {\n      if constexpr (std::is_pointer_v<T>)\n      {\n          return *t;\n      }\n      else\n      {\n          return t;\n      }\n  }\n  ```\n\n- **Improved lambda expression:** Allows lambda to capture a single object without changing its type or constness.\n  ```cpp\n  auto func = [x = std::move(obj)] { /* use x */ };\n  ```\n\n- **Standard file system library:** std::filesystem as a standardized way to manipulate paths, directories, and files.\n\n- **New Standard Library additions:** <string_view> (non-owning string reference), <any> (type-safe discrimination union), <optional> (optional value wrapper), <variant> (type-safe sum type), and <memory_resource> (library for polymorphic allocators).\n\n- **Parallel Algorithms:** Adds support for parallel execution of Standard Library algorithms.\n\nThis is a brief summary of the key features of C++17; it includes more features and library updates. For a complete list, you can refer to the [full list of C++17 features and changes](https://en.cppreference.com/w/cpp/17).",
            "resources": [
              {
                "name": "full list of C++17 features and changes.",
                "link": "https://en.cppreference.com/w/cpp/17"
              }
            ]
          },
          {
            "name": "C++20",
            "recommendation-type": "opinion",
            "description": "C++20 is the latest standard of the C++ programming language, which brings significant improvements and new features to the language. This version is aimed at facilitating better software development practices and enabling developers to write more efficient, readable, and maintainable code.\n\nHere are some of the key features introduced in C++20:\n\n- **Concepts:** Concepts are a way to enforce specific requirements on template parameters, allowing you to write more expressive and understandable code. They improve the error messages when using templates and ensure that the template parameters fulfill specific criteria.\n\n```cpp\n template <typename T>\n concept Addable = requires (T a, T b) {\n     { a + b } -> std::same_as<T>;\n };\n\n template <Addable T>\n T add(T a, T b) {\n     return a + b;\n }\n```\n\n- **Ranges:** Ranges provide a new way to work with sequences of values, enhancing the power and expressiveness of the Standard Library algorithms. The range-based algorithms make it easier and more convenient to work with sequences.\n\n```cpp\n #include <algorithm>\n #include <iostream>\n #include <ranges>\n #include <vector>\n\n int main() {\n     std::vector<int> numbers = { 1, 2, 3, 4, 5 };\n\n     auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n\n     for (int n : even_numbers) {\n         std::cout << n << ' ';\n     }\n }\n```\n\n- **Coroutines:** Coroutines are a new way to write asynchronous and concurrent code with improved readability. They allow functions to be suspended and resumed, enabling you to write more efficient, non-blocking code.\n\n```cpp\n #include <coroutine>\n #include <iostream>\n #include <future>\n\n std::future<int> async_value(int value) {\n     co_await std::chrono::seconds(1);\n     co_return value * 2;\n }\n\n int main() {\n     auto result = async_value(42);\n     std::cout << \"Result: \" << result.get() << std::endl;\n }\n```\n\n- **The constexpr and consteval Keywords:** Both constexpr and consteval are related to compile-time evaluation. Functions marked with constexpr can be executed at compile-time or runtime, while functions marked with consteval can only be executed at compile-time.\n\n```cpp\n constexpr int add(int a, int b) {\n     return a + b;\n }\n\n consteval int square(int x) {\n     return x * x;\n }\n\n int main() {\n     constexpr int result1 = add(3, 4);   // evaluated at compile-time\n     int result2 = add(5, 6);             // evaluated at runtime\n     constexpr int result3 = square(7);   // evaluated at compile-time\n }\n```\n\nThese are just some of the highlights of the C++20 standard. It also includes many other features and improvements, like structured bindings, improved lambdas, and new standard library components. Overall, C++20 makes it easier for developers to write clean, efficient, and expressive code.",
            "resources": []
          },
          {
            "name": "C++ Newest Standard: C++20",
            "recommendation-type": "opinion",
            "description": "C++20 is the newest standard of the C++ programming language, which was officially published in December 2020. It introduces many new features, enhancements, and improvements over the previous standards. Here is a brief summary of some key features in C++20.\n\n- **Concepts:** Concepts provide a way to specify constraints on template parameters, ensuring that they meet a specific set of requirements. This allows for better compile-time error messages and code readability.\n\n```cpp\n template<typename T>\n concept Printable = requires(T x) {\n     {std::cout << x};\n };\n\n template<Printable T>\n void print(const T& x) {\n     std::cout << x << '\\n';\n }\n```\n\n- **Ranges:** Ranges build on the iterator concept and provide a more usable and composable framework for dealing with sequences of values. They simplify the way algorithms can be applied to collections of data.\n\n```cpp\n #include <iostream>\n #include <vector>\n #include <ranges>\n\n int main() {\n     std::vector<int> numbers{1, 2, 3, 4, 5};\n     auto even_view = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n\n     for (int n : even_view) {\n         std::cout << n << ' ';\n     }\n }\n```\n\n- **Coroutines:** Coroutines offer a way to split complex, long-running functions into smaller, more manageable chunks, allowing them to be suspended and resumed at specific points.\n\n```cpp\n #include <iostream>\n #include <coroutine>\n\n std::generator<int> generator() {\n     for (int i = 0; i < 5; ++i)\n         co_yield i;\n }\n\n int main() {\n     for (int value : generator())\n         std::cout << value << ' ';\n }\n```\n\n- **Lambdas with template parameters:** C++20 enables using auto as a lambda parameter, allowing for generic lambdas with templated parameters.\n\n```cpp\n auto sum = [](auto a, auto b) {\n     return a + b;\n };\n\n int res1 = sum(1, 2);           // int\n double res2 = sum(1.0, 2.0);    // double\n```\n\n- **Constexpr enhancements:** constexpr support is extended with additional features, such as constexpr dynamic allocations, constexpr try-catch blocks, and constexpr lambdas.\n\n```cpp\n struct Point {\n     constexpr Point(int x, int y): x_{x}, y_{y} {}\n     int x_, y_;\n };\n\n constexpr auto create_points() {\n     Point points[3]{};\n\n     for (int i = 0; i < 3; ++i) {\n         points[i] = Point{i, i * i};\n     }\n\n     return points;\n }\n\n constexpr auto points = create_points();\n```\n\nThere are many other features in C++20, such as new standard library improvements, std::format, improvements to compile-time programming, and more. These are just a few highlights that showcase the versatility and power of the newest standard of C++.",
            "resources": []
          },
          {
            "name": "C++0x",
            "recommendation-type": "opinion",
            "description": "cpp0x refers to the working name for C++11, which was previously known as C++0x before its final release. C++11 is a major revision of the C++ language standard, published in 2011, and brought several new features and improvements to the language.\n\nSome of the notable features in C++11 include:\n\n- **Auto keyword for automatic type inference.**\n\n```cpp\n auto i = 42; // i is an int\n auto s = \"hello\"; // s is a const char*\n```\n\n- **Range-based for loop for easier iteration over containers.**\n\n```cpp\n std::vector<int> vec = {1, 2, 3};\n for (int i : vec) {\n     std::cout << i << std::endl;\n }\n```\n\n- **Lambda functions for creating anonymous functions.**\n\n```cpp\n auto add = [](int a, int b) { return a + b; };\n int result = add(3, 4); // result is 7\n```\n\n- **nullptr for representing null pointer values, instead of using NULL.**\n\n```cpp\n int* p = nullptr;\n```\n\n- **Rvalue references and move semantics to optimize the handling of temporary objects.**\n\n```cpp\n std::string str1 = \"hello\";\n std::string str2 = std::move(str1); // move the content of str1 to str2\n```\n\n- **Variadic templates for creating templates that take a variable number of arguments.**\n\n```cpp\n template <typename... Args>\n void printArgs(Args... args) {\n     // function body\n }\n```\n\n- **Static assertions for compile-time assertions.**\n\n```cpp\n static_assert(sizeof(int) == 4, \"This code requires int to be 4 bytes.\");\n```\n\n- **Thread support for multithreading programming.**\n\n```cpp\n #include <thread>\n\n void my_function() {\n     // thread function body\n }\n\n int main() {\n     std::thread t(my_function);\n     t.join();\n     return 0;\n }\n```\n\nThese are just a few examples of the many new features introduced in C++11. For a comprehensive list, you can refer to the C++11 documentation.",
            "resources": []
          }
        ]
      },
      "Debuggers": {
        "description": "Debuggers are essential tools for any C++ programmer, as they help in detecting, diagnosing, and fixing bugs in the code. They serve as an invaluable resource in identifying and understanding potential errors in the program.\n\n**Types of Debuggers**\n\nThere are several debuggers available for use with C++:\n\n- **GDB (GNU Debugger):** This is the most widely used C++ debugger in the Linux environment. It can debug many languages, including C and C++.\n\nExample usage:\n\n```bash\n g++ -g main.cpp -o main    # compile the code with debug info\ngdb ./main                 # start gdb session\nb main                     # set a breakpoint at the start of the main function\nrun                        # run the program\nnext                       # step to the next line\n```\n\n- **LLDB:** This is the debugger developed by LLVM. It supports multiple languages and is popular among macOS and iOS developers.\n\nExample usage:\n\n```bash\n clang++ -g main.cpp -o main # compile the code with debug info\nlldb ./main                 # start lldb session\nbreakpoint set --name main  # set a breakpoint at the start of the main function\nrun                         # run the program\nnext                        # step to the next line\n```\n\n- **Microsoft Visual Studio Debugger:** This debugger is built into Visual Studio and is typically used in a graphical interface on Windows systems.\n\nExample usage:\n\nOpen your Visual Studio project and go to Debug > Start Debugging. Then use the step over (F10), step into (F11), or continue (F5) commands to navigate through the code.\n\n- **Intel Debugger (IDB):** This debugger is part of Intel’s parallel development suite and is popular for high-performance applications.\n\n- **TotalView Debugger:** Developed by Rogue Wave Software, TotalView Debugger is a commercial debugger designed for parallel, high-performance, and enterprise applications.\n\nEach debugger has its advantages and unique features, so it’s essential to choose the one that best suits your needs and works well with your development environment.",
        "resources": [],
        "order": 15,
        "options": [
          {
            "name": "Debugger Messages",
            "recommendation-type": "opinion",
            "description": "Debugger messages are notifications or alerts provided by a debugger to help you identify problems or errors in your C++ code. These messages can be warnings or error messages and can provide helpful information about the state of your program and specific issues encountered during the debugging process.\n\n**Types of Debugger Messages**\n\n**Error Messages:** Notify you about issues in the code that prevent the program from running or compiling correctly. These messages typically include information about the file and the line number where the error is detected, followed by a description of the issue.\n\nExample:\n\n```cpp\ntest.cpp: In function 'int main()':\ntest.cpp:6:5: error: 'cout' was not declared in this scope\n     cout << \"Hello World!\";\n     ^~~~\n```\n\n**Warning Messages:** Inform you about potential issues or risky programming practices that may not necessarily cause errors but could lead to problems later on. Like error messages, warning messages usually include information about the file and line number where the issue is found, along with a description of the problem.\n\nExample:\n\n```cpp\ntest.cpp: In function 'int main()':\ntest.cpp:6:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n     if (a < size)\n              ^\n```\n\n**Informational Messages:** Provide general information about the execution of the program, such as breakpoints, watchpoints, and variable values. These messages can also reveal the current state of the program, including the call stack and the list of active threads.\n\nExample (assuming you are using GDB as debugger):\n\n```bash\n(gdb) break main\nBreakpoint 1 at 0x40055f: file test.cpp, line 5.\n(gdb) run\nStarting program: /path/to/test\nBreakpoint 1, main () at test.cpp:5\n5       int a = 5;\n```\n\n**Code Examples**\n\nTo make use of debugger messages, you need to employ a debugger, such as GDB or Visual Studio Debugger, and include specific flags during the compilation process.\n\nExample using GDB:\n\n```cpp\n// test.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int num1 = 10;\n    int num2 = 0;\n    int result = num1 / num2;\n\n    cout << \"Result: \" << result << endl;\n\n    return 0;\n}\n```\n\n```bash\n$ g++ -g -o test test.cpp  // Compile with -g flag to include debugging information\n$ gdb ./test               // Run the GDB debugger\n(gdb) run                  // Execute the program inside GDB\n```\n\nAt this point, the debugger will show an error message triggered by the division by zero:\n\n```bash\nProgram received signal SIGFPE, Arithmetic exception.\n0x00005555555546fb in main () at test.cpp:7\n7       int result = num1 / num2;\n```\n\nNow you can make appropriate changes to fix the issue in your C++ code.",
            "resources": []
          },
          {
            "name": "Debugger Symbols",
            "recommendation-type": "opinion",
            "description": "Debugger symbols are additional information embedded within the compiled program’s binary code, that help debuggers in understanding the structure, source code, and variable representations at a particular point in the execution process.\n\nThere are generally two types of debugging symbols:\n\n**Internal Debugging Symbols:** These symbols reside within the compiled binary code itself. When using internal debugging symbols, it is essential to note that the size of the binary increases, which may not be desirable for production environments.\n\n**External Debugging Symbols:** The debugging symbols are kept in separate files apart from the binary code, usually with file extensions such as .pdb (Program Database) in Windows or .dSYM (DWARF Symbol Information) in macOS.\n\n**Generating Debugger Symbols**\n\nTo generate debugger symbols in C++, you need to specify specific options during the compilation process. We will use g++ compiler as an example.\n\n**Internal Debugging Symbols (g++)**\n\nTo create a debug build with internal debugging symbols, use the -g flag:\n\n```bash\ng++ -g -o my_program my_program.cpp\n```\n\nThis command compiles my_program.cpp into an executable named my_program with internal debugging symbols.\n\n**External Debugging Symbols (g++)**\n\nIn case you want to generate a separate file containing debugging symbols, you can use the -gsplit-dwarf flag:\n\n```bash\ng++ -g -gsplit-dwarf -o my_program my_program.cpp\n```\n\nThis command compiles my_program.cpp into an executable named my_program and generates a separate file named my_program.dwo containing the debugging symbols.\n\nWhen sharing your compiled binary to end-users, you can remove the debugging symbols using the strip command:\n\n```bash\nstrip --strip-debug my_program\n```\n\nThis command removes internal debug symbols, resulting in a smaller binary size while keeping the .dwo file for debugging purposes when needed.\n\nRemember that the availability and syntax of these options may vary between different compilers and platforms. Be sure to consult your compiler’s documentation to ensure proper usage of the debugging options.",
            "resources": []
          },
          {
            "name": "WinDbg",
            "recommendation-type": "opinion",
            "description": "WinDbg is a powerful debugger for Windows applications, which is included in the Microsoft Windows SDK. It provides an extensive set of features to help you analyze and debug complex programs, kernel mode, and user-mode code. With a user-friendly graphical interface, WinDbg can help in analyzing crash dumps, setting breakpoints, and stepping through code execution.\n\n**Getting Started**\n\nTo begin using WinDbg, you first need to install it. You can download the Windows SDK and install it to get the WinDbg.\n\n**Loading Symbols**\n\nWinDbg relies on symbol files (*.pdb) to provide more useful information about a program’s internal structures, functions, and variables. To load symbols properly, you may need to configure the symbol path:\n\n```bash\n!sym noisy\n.sympath SRV*C:\\symbols*http://msdl.microsoft.com/download/symbols\n.reload /f\n```\n\n**Opening Executables and Crash Dumps**\n\nTo debug an executable using WinDbg, go to File > Open Executable..., then locate and open the target program. To analyze a crash dump, use File > Open Crash Dump... instead.\n\n**Basic Commands**\n\nSome common commands you might use in WinDbg:\n\n- `g`: Execute the program until the next breakpoint or exception\n- `bp <address>`: Set a breakpoint at a given address\n- `bl`: List all breakpoints\n- `bd <breakpoint_id>`: Disable a breakpoint\n- `be <breakpoint_id>`: Enable a breakpoint\n- `bc <breakpoint_id>`: Clear a breakpoint\n- `t`: Single-step through instructions (trace)\n- `p`: Step over instructions (proceed)\n- `k`: Display call stack\n- `dd`: Display memory contents in 4-byte units (double words)\n- `da`: Display memory contents as ASCII strings\n- `!analyze -v`: Analyze the program state and provide detailed information\n\n**Example Usage**\n\nDebugging a simple program:\n\n1. Open the executable in WinDbg\n2. Set a breakpoint using `bp <address>`\n3. Run the program using `g`\n4. Once the breakpoint is hit, use `t` or `p` to step through the code\n5. Try `k` to view the call stack, or `dd`, `da` to inspect memory\n6. Remove the breakpoint and continue debugging with other commands as needed\n\nRemember that WinDbg has a wealth of commands and functionality, so it’s essential to get comfortable with the documentation and explore the wealth of available resources specific to your debugging tasks.",
            "resources": [],
            "options": [
              {
                "name": "GDB: GNU Debugger",
                "recommendation-type": "opinion",
                "description": "GDB, or the GNU Project Debugger, is a powerful command-line debugger used primarily for C, C++, and other languages. It can help you find runtime errors, examine the program’s execution state, and manipulate the flow to detect and fix bugs easily.\n\n**Getting started with GDB**\n\nTo start using GDB, you first need to compile your code with the -g flag, which includes debugging information in the executable:\n\n```bash\ng++ -g myfile.cpp -o myfile\n```\n\nNow, you can load your compiled program into GDB:\n\n```bash\ngdb myfile\n```\n\n**Basic GDB Commands**\n\nHere are some common GDB commands you’ll find useful when debugging:\n\n- `run`: Start your program.\n- `break [function/line number]`: Set a breakpoint at the specified function or line.\n- `continue`: Continue the program execution after stopping on a breakpoint.\n- `next`: Execute the next line of code, stepping over function calls.\n- `step`: Execute the next line of code, entering function calls.\n- `print [expression]`: Evaluate an expression in the current context and display its value.\n- `backtrace`: Show the current call stack.\n- `frame [frame-number]`: Switch to a different stack frame.\n- `quit`: Exit GDB.\n\n**Example Usage**\n\nSuppose you have a simple cpp file called example.cpp:\n\n```cpp\n#include <iostream>\n\nvoid my_function(int i) {\n  std::cout << \"In my_function with i = \" << i << std::endl;\n}\n\nint main() {\n  for (int i = 0; i < 5; ++i) {\n    my_function(i);\n  }\n  return 0;\n}\n```\n\nFirst, compile the code with debugging symbols:\n\n```bash\ng++ -g example.cpp -o example\n```\n\nStart GDB and load the example program:\n\n```bash\ngdb example\n```\n\nSet a breakpoint in the my_function function and run the program:\n\n```bash\n(gdb) break my_function\n(gdb) run\n```\n\nOnce stopped at the breakpoint, use next, print, and continue to examine the program’s state:\n\n```bash\n(gdb) next\n(gdb) print i\n(gdb) continue\n```\n\nFinally, exit GDB with the quit command.\n\nThis was just a brief summary of GDB; you can find more details in the official GDB manual.",
                "resources": []
              }
            ]
          }
        ]
      },
      "Compilers": {
        "description": "A compiler is a computer program that translates source code written in one programming language into a different language, usually machine code or assembly code, that can be executed directly by a computer’s processor. In the context of C++, compilers take your written C++ source code and convert it into an executable program.\n\n**Popular C++ Compilers**\n\nThere are several popular C++ compilers available, here’s a short list of some common ones:\n\n- **GNU Compiler Collection (GCC):** Developed by the GNU Project, GCC is an open-source compiler that supports multiple programming languages, including C++.\n- **Clang:** As part of the LLVM project, Clang is another open-source compiler that supports C++ and is known for its fast compilation times and extensive diagnostics.\n- **Microsoft Visual C++ (MSVC):** MSVC is a commercial compiler provided by Microsoft as part of Visual Studio, and it’s widely used on Windows platforms.\n- **Intel C++ Compiler (ICC):** ICC is a commercial compiler provided by Intel and is known for its ability to optimize code for the latest Intel processors.\n\n**Example of a Simple C++ Compilation**\n\nLet’s say you have a simple C++ program saved in a file called hello.cpp:\n\n```cpp\n#include <iostream>\n\nint main() {\n  std::cout << \"Hello, World!\" << std::endl;\n  return 0;\n}\n```\n\nYou can compile this program using the GCC compiler by executing the following command in a command-line/terminal:\n\n```bash\ng++ hello.cpp -o hello\n```\n\nThis will generate an executable file called hello (or hello.exe on Windows) which you can run to see the output “Hello, World!“.\n\n**Note**\n\nWhen learning about compilers, it’s essential to know that they work closely with the linker and the standard library. The linker takes care of combining compiled object files and libraries into a single executable, while the standard library provides implementations for common functionalities used in your code.",
        "resources": [],
        "order": 16,
        "options": [
          {
            "name": "Stages of Compilation in C++",
            "recommendation-type": "opinion",
            "description": "The process of compilation in C++ can be divided into four primary stages: Preprocessing, Compilation, Assembly, and Linking. Each stage performs a specific task, ultimately converting the source code into an executable program.\n\n**Preprocessing**\n\nThe first stage is the preprocessing of the source code. Preprocessors modify the source code before the actual compilation process. They handle directives that start with a # (hash) symbol, like #include, #define, and #if. In this stage, included header files are expanded, macros are replaced, and conditional compilation statements are processed.\n\n**Code Example:**\n\n```cpp\n#include <iostream>\n#define PI 3.14\n\nint main() {\n    std::cout << \"The value of PI is: \" << PI << std::endl;\n    return 0;\n}\n```\n\n**Compilation**\n\nThe second stage is the actual compilation of the preprocessed source code. The compiler translates the modified source code into an intermediate representation, usually specific to the target processor architecture. This step also involves performing syntax checking, semantic analysis, and producing error messages for any issues encountered in the source code.\n\n**Code Example:**\n\n```cpp\nint main() {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n    return 0;\n}\n```\n\n**Assembly**\n\nThe third stage is converting the compiler’s intermediate representation into assembly language. This stage generates assembly code using mnemonics and syntax that is specific to the target processor architecture. Assemblers then convert this assembly code into object code (machine code).\n\n**Code Example (x86 Assembly):**\n\n```assembly\nmov eax, 10\nmov ebx, 20\nadd eax, ebx\n```\n\n**Linking**\n\nThe final stage is the linking of the object code with the necessary libraries and other object files. In this stage, the linker merges multiple object files and libraries, resolves external references from other modules or libraries, allocates memory addresses for functions and variables, and generates an executable file that can be run on the target platform.\n\n**Code Example (linking objects and libraries):**\n\n```bash\n$ g++ main.o -o main -lm\n```\n\nIn summary, the compilation process in C++ involves four primary stages: preprocessing, compilation, assembly, and linking. Each stage plays a crucial role in transforming the source code into an executable program.",
            "resources": []
          },
          {
            "name": "Features of C++ Compilers",
            "recommendation-type": "opinion",
            "description": "Different C++ compilers have different features. Some of the most common features of C++ compilers are:\n\n**Optimization:** Compilers can optimize the code to improve the performance of the program. For example, they can remove redundant code, inline functions, and perform loop unrolling.\n\n**Debugging:** Compilers can generate debugging information that can be used to debug the program.\n\n**Warnings:** Compilers can generate warnings for suspicious code that may cause errors.\n\nSome of the most popular C++ compilers are:\n\n- **GNU Compiler Collection (GCC):** GCC is a free and open-source compiler that supports many programming languages, including C++.\n- **Clang:** Clang is a C++ compiler that is part of the LLVM project. It is designed to be compatible with GCC.\n- **Microsoft Visual C++:** Microsoft Visual C++ is a C++ compiler that is part of the Microsoft Visual Studio IDE.\n- **Intel C++ Compiler:** Intel C++ Compiler is a C++ compiler that is part of the Intel Parallel Studio XE suite.\n\nYou should go through the documentation of your compiler to learn more about its features.",
            "resources": []
          }
        ]
      },
      "Build Systems": {
        "name": "Build Systems in C++",
        "recommendation-type": "opinion",
        "description": "A build system is a collection of tools and utilities that automate the process of compiling, linking, and executing source code files in a project. The primary goal of build systems is to manage the complexity of the compilation process and produce a build (executable or binary files) in the end. In C++ (cpp), some common build systems are:\n\n**GNU Make:** It is a popular build system that uses Makefile to define the build process. It checks the dependencies and timestamps of source files to determine which files need to be compiled and linked.\n\n**CMake:** It is a cross-platform build system that focuses on defining project dependencies and managing build environments. CMake generates build files (like Makefiles) for different platforms and allows developers to write source code once and then compile it for different target platforms.\n\n**Autotools:** Also known as GNU Build System, consists of the GNU Autoconf, Automake, and Libtool tools that enable developers to create portable software across different Unix-based systems. For a C++ project, you will need to create configure.ac, Makefile.am files with specific rules, and then run the following commands in the terminal to build the project:\n```\nautoreconf --install\n./configure\nmake\nmake install\n```\n\n**SCons:** This build system uses Python for build scripts, making it more expressive than GNU Make. It can also build for multiple platforms and configurations simultaneously.\n\n**Ninja:** A small and focused build system that takes a list of build targets specified in a human-readable text file and builds them as fast as possible.\n\nThese are some of the popular build systems in C++, each with their own syntax and capabilities. While Make is widely used, CMake is a cross-platform build system that generates build files for other build systems like Make or Ninja. Autotools is suitable for creating portable software, SCons leverages Python for its build scripts, and Ninja focuses on fast build times.",
        "resources": [],
        "order": 17,
        "module bundlers": {
          "options": [
            {
              "name": "CMake",
              "recommendation-type": "opinion",
              "description": "CMake is a powerful cross-platform build system that generates build files, Makefiles, or workspaces for various platforms and compilers. Unlike other build systems, CMake does not actually build the project; it only generates the files needed by build tools. CMake is widely used, particularly in C++ projects, for its ease of use and flexibility.\n\n**CMakeLists.txt:**\nCMake uses a file called CMakeLists.txt to define settings, source files, libraries, and other configurations. A typical CMakeLists.txt for a simple project would look like:\n```cmake\n# CMakeLists.txt\n\ncmake_minimum_required(VERSION 3.0)\n\nproject(MyProject)\n\nset(SRC_DIR \"${CMAKE_CURRENT_LIST_DIR}/src\")\nset(SOURCES \"${SRC_DIR}/main.cpp\" \"${SRC_DIR}/file1.cpp\" \"${SRC_DIR}/file2.cpp\")\n\nadd_executable(${PROJECT_NAME} ${SOURCES})\n\ntarget_include_directories(${PROJECT_NAME} PRIVATE \"${CMAKE_CURRENT_LIST_DIR}/include\")\n\nset_target_properties(${PROJECT_NAME} PROPERTIES\n    CXX_STANDARD 14\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS OFF\n)\n```\n\n**Building with CMake:**\nHere is an example of a simple build process using CMake:\n1. Create a new directory for the build.\n```bash\nmkdir build\ncd build\n```\n2. Generate build files using CMake.\n```bash\ncmake ..\n```\nIn this example, .. indicates the parent directory where CMakeLists.txt is located. The build files will be generated in the build directory.\n3. Build the project using the generated build files.\n```bash\nmake\n```\nOr, on Windows with Visual Studio, you may use:\n```bash\nmsbuild MyProject.sln\n```\nCMake makes it easy to manage large projects, define custom build configurations, and work with many different compilers and operating systems, making it a widely chosen tool for managing build systems in C++ projects.",
              "resources": []
            },
            {
              "name": "Makefile",
              "recommendation-type": "opinion",
              "description": "A Makefile is a configuration file used by the make utility to automate the process of compiling and linking code in a C++ project. It consists of a set of rules and dependencies that help in building the target executable or library from source code files.\n\nMakefiles help developers save time, reduce errors, and ensure consistency in the build process. They achieve this by specifying the dependencies between different source files and providing commands that generate output files (such as object files and executables) from input files (such as source code and headers).\n\n**Structure of a Makefile:**\nA typical Makefile has the following structure:\n\n- **Variables:** Define variables to store commonly used values, such as compiler flags, directories, or target names.\n- **Rules:** Define how to generate output files from input files using a set of commands. Each rule has a target, a set of prerequisites, and a recipe.\n- **Phony targets:** Targets that do not represent actual files in the project but serve as a way to group related rules and invoke them using a single command.\n\n**Example:**\nConsider a basic C++ project with the following directory structure:\n```plaintext\nproject/\n|-- include/\n|   |-- header.h\n|-- src/\n|   |-- main.cpp\n|-- Makefile\n```\nA simple Makefile for this project could be as follows:\n```make\n# Variables\nCXX = g++\nCXXFLAGS = -Wall -Iinclude\nSRC = src/main.cpp\nOBJ = main.o\nEXE = my_program\n\n# Rules\n$(EXE): $(OBJ)\n\t$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJ)\n\n$(OBJ): $(SRC)\n\t$(CXX) $(CXXFLAGS) -c $(SRC)\n\n# Phony targets\n.PHONY: clean\nclean:\n\trm -f $(OBJ) $(EXE)\n```\nWith this Makefile, you can simply run `make` in the terminal to build the project, and `make clean` to remove the output files. The Makefile specifies the dependencies between the source code, object files, and the final executable, as well as the commands to compile and link them.\n\n**Summary:**\nMakefiles provide a powerful way to automate building C++ projects using the make utility. They describe the dependencies and commands required to generate output files from source code, saving time and ensuring consistency in the build process.",
              "resources": []
            },
            {
              "name": "Ninja",
              "recommendation-type": "opinion",
              "description": "Ninja is a small build system with a focus on speed. It is designed to handle large projects by generating build files that implement the minimal amount of work necessary to build the code. This results in faster build times, especially for large codebases. Ninja is often used in conjunction with other build systems like CMake, which can generate Ninja build files for you.\n\nNinja build files are typically named build.ninja and contain rules, build statements, and variable declarations. Here’s a simple example of a Ninja build file for a C++ project:\n```plaintext\n# Variable declarations\ncxx = g++\ncflags = -Wall -Wextra -std=c++17\n\n# Rule for compiling the C++ files\nrule cxx_compile\n  command = $cxx $cflags -c $in -o $out\n\n# Build statements for the source files\nbuild main.o: cxx_compile main.cpp\nbuild foo.o: cxx_compile foo.cpp\n\n# Rule for linking the object files\nrule link\n  command = $cxx $in -o $out\n\n# Build statement for the final executable\nbuild my_program: link main.o foo.o\n```\nTo build the project using this build.ninja file, simply run `ninja` in the terminal:\n```plaintext\n$ ninja\n```\nThis will build the my_program executable by first compiling the main.cpp and foo.cpp files into object files, and then linking them together.",
              "resources": []
            }
          ]
        }
      },
      "Package Managers": {
        "description": "Package managers are tools that automate the process of installing, upgrading, and managing software (libraries, frameworks, and other dependencies) for a programming language, such as C++.\n\nSome popular package managers used in the C++ ecosystem include:\n\n- **Conan**: Conan is an open-source, decentralized, cross-platform package manager for C and C++ developers. It simplifies managing dependencies and reusing code, which benefits multi-platform development projects.\n\n  For example, installing a library using Conan:\n\n  ```plaintext\n  conan install poco/1.9.4@\n  ```\n\n- **vcpkg**: vcpkg is a cross-platform package manager created by Microsoft. It is an open-source library management system for C++ developers to build and manage their projects.\n\n  For example, installing a package using vcpkg:\n\n  ```plaintext\n  ./vcpkg install boost:x64-windows\n  ```\n\n- **C++ Archive Network (cppan)**: cppan is a package manager and software repository for C++ developers, simplifying the process of managing and distributing C++ libraries and tools. It’s now part of build2, a build toolchain that provides a package manager.\n\n  An example of a cppan.yml file:\n\n  ```yaml\n  #\n  # cppan.yml\n  #\n\n  project:\n    api_version: 1\n\n    depend:\n      - pvt.cppan.demo.sqlite3\n      - pvt.cppan.demo.xz_utils.lzma\n  ```\n\nWith these package managers, you can streamline your development process and easily manage dependencies in your C++ projects. In addition, you can easily reuse the code in your projects to improve code quality and accelerate development.",
        "resources": [],
        "order": 18,
        "options": [
          {
            "name": "vcpkg",
            "recommendation-type": "opinion",
            "description": "vcpkg is a cross-platform, open-source package manager for C and C++ libraries. Developed by Microsoft, it simplifies the process of acquiring and building open-source libraries for your projects. vcpkg supports various platforms including Windows, Linux, and macOS, enabling you to easily manage and integrate external libraries into your projects.\n\n**Installation**\n\nTo install vcpkg, follow these steps:\n\n1. Clone the repository:\n\n```plaintext\n  git clone https://github.com/Microsoft/vcpkg.git\n```\n\n2. Change to the vcpkg directory and run the bootstrap script:\n\n  On Windows:\n\n```plaintext\n  .\\bootstrap-vcpkg.bat\n```\n\n  On Linux/macOS:\n\n```plaintext\n  ./bootstrap-vcpkg.sh\n```\n\n3. (Optional) Add the vcpkg executable to your PATH environment variable for easy access.\n\n**Basic usage**\n\nHere are some basic examples of using vcpkg:\n\n- Search for a package:\n\n```plaintext\n  vcpkg search <package_name>\n```\n\n- Install a package:\n\n```plaintext\n  vcpkg install <package_name>\n```\n\n- Remove a package:\n\n```plaintext\n  vcpkg remove <package_name>\n```\n\n- List installed packages:\n\n```plaintext\n  vcpkg list\n```\n\n- Integrate vcpkg with Visual Studio (Windows only):\n\n```plaintext\n  vcpkg integrate install\n```\n\nFor additional documentation and advanced usage, you can refer to the [official GitHub repository](https://github.com/Microsoft/vcpkg).",
            "resources": [],
            "options": [
              {
                "name": "Conan",
                "recommendation-type": "opinion",
                "description": "Conan is a popular package manager for C and C++ languages and is designed to be cross-platform, extensible, and easy to use. It allows developers to declare, manage, and fetch dependencies while automating the build process. Conan supports various build systems, such as CMake, Visual Studio, MSBuild, and more.\n\n**Installation**\n\nTo install Conan, you can use pip, the Python package manager:\n\n```plaintext\npip install conan\n```\n\n**Basic Usage**\n\nCreate a conanfile.txt file in your project root directory, specifying dependencies you need for your project:\n\n```plaintext\n[requires]\nboost/1.75.0\n\n[generators]\ncmake\n```\n\nRun the conan install command to fetch and build required dependencies:\n\n```plaintext\nmkdir build && cd build\nconan install ..\n```\n\nNow build your project using your build system, for example CMake:\n\n```plaintext\ncmake .. -DCMAKE_BUILD_TYPE=Release\n```\n\n```plaintext\ncmake --build .\n```\n\n**Creating Packages**\n\nTo create a package in Conan, you need to write a conanfile.py file with package information and build instructions.\n\nHere’s an example:\n\n```python\nfrom conans import ConanFile, CMake\n\nclass MyLibraryConan(ConanFile):\n    name = \"MyLibrary\"\n    version = \"0.1\"\n    license = \"MIT\"\n    url = \"https://github.com/username/mylibrary\"\n    description = \"A simple example library\"\n    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n    generators = \"cmake\"\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure(source_folder=\"src\")\n        cmake.build()\n\n    def package(self):\n        self.copy(\"*.hpp\", dst=\"include\", src=\"src/include\")\n        self.copy(\"*.lib\", dst=\"lib\", keep_path=False)\n        self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n        self.copy(\"*.so\", dst=\"lib\", keep_path=False)\n        self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n\n    def package_info(self):\n        self.cpp_info.libs = [\"MyLibrary\"]\n```\n\nWith that setup, you can create a package by running:\n\n```plaintext\nconan create . username/channel\n```\n\nThis will compile the package and store it in your Conan cache. You can now use this package as a dependency in other projects.",
                "resources": []
              }
            ]
          },
          {
            "name": "Spack",
            "recommendation-type": "opinion",
            "description": "Spack is a flexible package manager designed to support multiple versions, configurations, platforms, and compilers. It is particularly useful in High Performance Computing (HPC) environments and for those who require fine control over their software stack. Spack is a popular choice in scientific computing due to its support for various platforms such as Linux, macOS, and many supercomputers. It is designed to automatically search for and install dependencies, making it easy to build complex software.\n\n**Key Features**\n\n- Multi-Version Support: Spack allows for the installation of multiple versions of packages, enabling users to work with different configurations depending on their needs.\n- Compiler Support: Spack supports multiple compilers, including GCC, Clang, Intel, PGI, and others, allowing users to choose the best toolchain for their application.\n- Platform Support: Spack can run on Linux, macOS, and various supercomputers, and it can even target multiple architectures within a single package.\n- Dependencies: Spack takes care of dependencies, providing automatic installation and management of required packages.\n\n**Basic Usage**\n\nTo install Spack, clone its Git repository and set up your environment:\n\n```plaintext\ngit clone https://github.com/spack/spack.git\ncd spack\n. share/spack/setup-env.sh\n```\n\nInstall a package using Spack:\n\n```plaintext\nspack install <package-name>\n```\n\nFor example, to install hdf5:\n\n```plaintext\nspack install hdf5\n```\n\nLoad a package in your environment:\n\n```plaintext\nspack load <package-name>\n```\n\nFor example, to load hdf5:\n\n```plaintext\nspack load hdf5\n```\n\nList installed packages:\n\n```plaintext\nspack find\n```\n\nUninstall a package:\n\n```plaintext\nspack uninstall <package-name>\n```\n\nFor more advanced usage, like installing specific versions or using different compilers, consult the [Spack documentation](https://spack.readthedocs.io/).",
            "resources": [],
            "options": [
              {
                "name": "NuGet",
                "recommendation-type": "opinion",
                "description": "NuGet is a Microsoft-supported package manager for the .NET framework, mainly used in C# and other .NET languages, but also supports C++ projects with PackageReference. It allows you to easily add, update, and manage dependencies in your projects.\n\n**Installation**\n\nYou can use NuGet either as a command-line tool or integrated in your preferred IDE like Visual Studio or Visual Studio Code. If you’re using Visual Studio, it comes pre-installed. For other editors, you may need to download the command-line tool nuget.exe.\n\n**Usage**\n\nYou can use NuGet to manage your C++ dependencies using the PackageReference format in vcxproj files:\n\n1. Tools > NuGet Package Manager > Manage NuGet Packages for Solution…\n2. Package source should be set to “nuget.org”\n3. Select the Projects tab\n4. Use the search box to find packages\n\nFor example, to install a package called “PackageName” for all configurations:\n\n```xml\n<Project>\n  <ItemGroup>\n    <PackageReference Include=\"PackageName\" Version=\"1.0.0\" />\n  </ItemGroup>\n  ...\n</Project>\n```\n\n**NuGet Command-Line**\n\nYou can also use the command-line tool nuget.exe for more advanced scenarios or for specific needs.\n\nHere’s an example of installing a package using the command line:\n\n```plaintext\nnuget install PackageName\n```\n\nAnd updating a package:\n\n```plaintext\nnuget update PackageName\n```\n\nFor more information and detailed examples on using NuGet in your projects, please refer to the [official documentation](https://docs.microsoft.com/en-us/nuget/).",
                "resources": []
              }
            ]
          }
        ]
      },
      "Working with Libraries": {
        "description": "When working with C++, you may need to use external libraries to assist in various tasks. Libraries are precompiled pieces of code that can be reused in your program to perform a specific task or provide a certain functionality. In C++, libraries can be either static libraries (.lib) or dynamic libraries (.dll in Windows, .so in Unix/Linux).\n\n**1. Static Libraries**\n\nStatic libraries are incorporated into your program during compile time. They are linked with your code, creating a larger executable file, but it does not require any external files during runtime.\n\nTo create a static library, you’ll need to compile your source files into object files, then bundle them into an archive. You can use the following commands:\n\n```bash\ng++ -c sourcefile.cpp -o objectfile.o\nar rcs libmystaticlibrary.a objectfile.o\n```\n\nTo use a static library, you need to include the header files in your source code and then link the library during the compilation process:\n\n```bash\ng++ main.cpp -o my program -L/path/to/your/library/ -lmy static library\n```\n\nReplace /path/to/your/library/ with the path where your libmystaticlibrary.a file is located.\n\n**2. Dynamic Libraries**\n\nDynamic libraries are loaded during runtime, which means that your executable file only contains references to these libraries. The libraries need to be available on the system where your program is running.\n\nTo create a dynamic library, you’ll need to compile your source files into object files, then create a shared library:\n\n```bash\ng++ -c -fPIC sourcefile.cpp -o objectfile.o\ng++ -shared -o libmy dynamic library.so objectfile.o\n```\n\nTo use a dynamic library, include the library’s header files in your source code and then link the library during the compilation process:\n\n```bash\ng++ main.cpp -o my program -L/path/to/your/library/ -lmy dynamic library\n```\n\nReplace /path/to/your/library/ with the path where your libmy dynamic library.so file is located.\n\n**NOTE:** When using dynamic libraries, make sure the library is in the system’s search path for shared libraries. You may need to update the LD_LIBRARY_PATH environment variable on Unix/Linux systems or the PATH variable on Windows.\n\nIn conclusion, using libraries in C++ involves creating or obtaining a library (static or dynamic), including the library’s header files in your source code, and linking the library during the compilation process. Be aware of the differences between static and dynamic libraries, and choose the right approach to suit your needs.",
        "resources": [],
        "order": 19,
        "options": [
          {
            "name": "Inclusion in C++",
            "recommendation-type": "opinion",
            "description": "In C++ programming, inclusion refers to incorporating external libraries, header files, or other code files into your program. This process allows developers to access pre-built functions, classes, and variable declarations that can be used in their own code. There are two types of inclusion in C++:\n\n**Header Inclusion**\n\nHeader inclusion involves including header files using the preprocessor directive #include. Header files are typically used to provide function prototypes, class declarations, and constant definitions that can be shared across multiple source files. There are two ways to include header files in your program:\n\n- **Angle brackets <>:** Used for including standard library headers, like iostream, vector, or algorithm.\n\n  Example:\n  ```cpp\n  #include <iostream>\n  #include <vector>\n  ```\n\n- **Double quotes \":** Used for including user-defined headers or headers provided by third-party libraries.\n\n  Example:\n  ```cpp\n  #include \"myHeader.h\"\n  #include \"thirdPartyLibrary.h\"\n  ```\n\n**Source Inclusion**\n\nSource inclusion refers to including the content of a source file directly in another source file. This approach is generally not recommended as it can lead to multiple definitions and increased compile times but it can occasionally be useful for certain tasks (e.g., templates or simple small programs). To include a source file, you can use the #include directive with double quotes, just like with header files:\n\nExample:\n\n```cpp\n#include \"mySourceFile.cpp\"\n```\n\nRemember, using source inclusion for large projects or in situations where it’s not necessary can lead to unexpected issues and should be avoided.",
            "resources": []
          },
          {
            "name": "Licensing in C++",
            "recommendation-type": "opinion",
            "description": "Licensing is a crucial aspect of working with libraries in C++ because it determines the rights and limitations on how you can use, modify, and distribute a given library. There are various types of licenses applied to open-source libraries. Below is a brief overview of three common licenses:\n\n**MIT License**\n\nThe MIT License is a permissive license that allows users to do whatever they want with the software code. They only need to include the original copyright, license notice, and a disclaimer of warranty in their copies.\n\nExample: Including the MIT License into your project can be done by simply adding the license file and a notice at the top of your source code files like:\n\n```cpp\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    MIT\n */\n```\n\n**GNU General Public License (GPL)**\n\nThe GPL is a copyleft license that grants users the rights to use, study, share, and modify the software code. However, any changes made to the code or any software that uses GPL licensed code must also be distributed under the GPL license.\n\nExample: To include a GPL license in your project, include a COPYING file with the full text of the license and place a notice in your source code files like:\n\n```cpp\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    GPL-3.0-or-later\n */\n```\n\n**Apache License 2.0**\n\nThe Apache License is a permissive license similar to the MIT license and allows users to do virtually anything with the software code. The primary difference is that it requires that any changes to the code are documented, and it provides specific terms for patent protection.\n\nExample: To include the Apache License in your project, add a LICENSE file with the full text of the license. Add a notice to your source code files like:\n\n```cpp\n/* Copyright (C) [year] [author]\n * SPDX-License-Identifier:    Apache-2.0\n */\n```\n\nPlease note that these are brief summaries of the licenses, and there are many other licenses available for use in software projects. When using third-party libraries, it is crucial to understand and adhere to the terms of their respective licenses to avoid legal complications.",
            "resources": []
          },
          {
            "Libraries": {
              "options": [
                {
                  "name": "Boost C++ Libraries",
                  "recommendation-type": "opinion",
                  "description": "Boost is a collection of high-quality and widely-used C++ libraries designed to help developers write efficient and portable code. They are modular and can be included in your projects as needed. Boost libraries provide various functionalities, including support for parallelism, multithreading, memory management, string manipulation, and advanced data structures.#include <iostream>\n#include <boost/filesystem.hpp>\n\nint main() {\n    boost::filesystem::path path(\"directory_path\");\n\n    if (boost::filesystem::exists(path)) {\n        std::cout << \"Path: \" << path << \" exists!\" << std::endl;\n\n        if (boost::filesystem::is_directory(path)) {\n            std::cout << \"Path: \" << path << \" is a directory.\" << std::endl;\n        } else if (boost::filesystem::is_regular_file(path)) {\n            std::cout << \"Path: \" << path << \" is a regular file.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Path: \" << path << \" does not exist!\" << std::endl;\n    }\n\n    return 0;\n}",
                  "resources": [
                    {
                      "name": "Boost Documentation",
                      "link": "https://www.boost.org/doc/libs/"
                    }
                  ]
                },
                {
                  "name": "OpenCV",
                  "recommendation-type": "opinion",
                  "description": "OpenCV (Open Source Computer Vision Library) is an open-source computer vision and machine learning software library. It was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in commercial products. OpenCV contains over 2,500 optimized algorithms for real-time computer vision and is actively used by a large community of programmers, researchers, and industries worldwide.\n\nThe library has interfaces for C++, Python, Java, and MATLAB/Octave and is widely used in various computer vision fields, such as:\n\n- 2D and 3D image processing\n- Facial recognition and face detection\n- Object detection and recognition\n- Machine learning\n\nHere’s a simple example using OpenCV in C++ to read and display an image:\n\n```cpp\n#include <opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <iostream>\n\nint main(int argc, char** argv) {\n    if(argc != 2) {\n        std::cout << \"Usage: display_image ImageToLoadAndDisplay\" << std::endl;\n        return -1;\n    }\n\n    cv::Mat image;\n    image = cv::imread(argv[1], cv::IMREAD_COLOR);\n\n    if(!image.data) {\n        std::cout << \"Could not open or find the image\" << std::endl;\n        return -1;\n    }\n\n    cv::namedWindow(\"Display window\", cv::WINDOW_AUTOSIZE);\n    cv::imshow(\"Display window\", image);\n    cv::waitKey(0);\n\n    return 0;\n}\n```\n\nThis example reads an image from the given input path (argv[1]) and displays it in a window. The cv::imread() function is used to read the image, and the cv::imshow() function displays it in the created window.\n\nRemember to compile the code, linking the necessary libraries:\n\n```bash\ng++ -o display_image display_image.cpp `pkg-config --cflags --libs opencv4`\n```\n\nAnd run the executable with an image path as an argument:\n\n```bash\n./display_image path/to/image.jpg\n```\n\nFor more advanced examples and detailed documentation on how to use OpenCV, please visit the [official OpenCV documentation](https://docs.opencv.org/).",
                  "resources": [
                    {
                      "name": "OpenCV Documentation",
                      "link": "https://docs.opencv.org/"
                    }
                  ]
                },
                {
                  "name": "Poco",
                  "recommendation-type": "opinion",
                  "description": "Poco (also known as POCO C++ Libraries) is a collection of open-source class libraries, which simplifies the creation of network-centric, portable, and maintainable software in C++.\n\n**Overview**\n\nPoco library provides functionality for various areas, such as:\n\n- Networking: HTTP, FTP, SMTP, POP3, and other internet protocols\n- File handling: FileSystem, Path, File, and Directory classes\n- XML processing: XML parsing and DOM manipulation\n- Logging: Loggers, levels, channels, patterns, etc.\n- Data manipulation: Stream, ByteBuffer, Buffer, etc.\n- Multithreading and synchronization: Threads, Mutex, Event, and Condition\n\n**Code Example**\n\nHere’s an example demonstrating an HTTP client using the Poco library:\n\n```cpp\n#include <Poco/Net/HTTPClientSession.h>\n#include <Poco/Net/HTTPRequest.h>\n#include <Poco/Net/HTTPResponse.h>\n#include <Poco/Net/HTTPMessage.h>\n#include <Poco/StreamCopier.h>\n#include <iostream>\n#include <string>\n\nusing namespace Poco::Net;\nusing namespace Poco;\nusing namespace std;\n\nint main()\n{\n  try\n  {\n    // Prepare the request\n    URI uri(\"http://example.com\");\n    HTTPClientSession session(uri.getHost(), uri.getPort());\n\n    HTTPRequest request(HTTPRequest::HTTP_GET, uri.getPath(), HTTPMessage::HTTP_1_1);\n    request.setContentType(\"application/json\");\n\n    session.sendRequest(request);\n\n    // Process the response\n    HTTPResponse response;\n    istream& responseStream = session.receiveResponse(response);\n    if (response.getStatus() == HTTPResponse::HTTP_OK)\n    {\n      // Successful\n      string responseBody;\n      StreamCopier::copyToString(responseStream, responseBody);\n      cout << \"Response: \" << responseBody << endl;\n    }\n    else\n    {\n      // Error\n      cout << \"Error: \" << response.getStatus() << \" \" << response.getReason() << endl;\n    }\n  }\n  catch(const Exception& e)\n  {\n    cerr << \"Error: \" << e.displayText() << endl;\n    return -1;\n  }\n\n  return 0;\n}\n```\n\nIn the above example, Poco is used to send an HTTP GET request and process the response. It manages tasks like connecting to the server, handling exceptions, and managing HTTP headers.\n\n[Official Docs for Poco Library](https://pocoproject.org/)",
                  "resources": [
                    {
                      "name": "Official Docs for Poco Library",
                      "link": "https://pocoproject.org/"
                    }
                  ]
                },
                {
                  "name": "Protocol Buffers (protobuf)",
                  "recommendation-type": "opinion",
                  "description": "Protocol Buffers, or protobuf, is a language and platform-neutral data serialization format developed by Google. It is used to efficiently serialize structured data for use in communications protocols, data storage, and more. It is extensible, as it allows you to define your own custom data structures called “messages” with various scalar and complex field types.\n\nHere is a brief summary of protobuf and how to use it in C++:\n\n1. **Define your .proto file:** Create a .proto file that defines the structure of your messages.\n\n   Example:\n\n   ```proto\n   syntax = \"proto3\";\n\n   message Person {\n       string name = 1;\n       int32 age = 2;\n       string email = 3;\n   }\n   ```\n\n2. **Compile the .proto file:** You need to compile your .proto file to generate C++ classes for serialization and deserialization.\n\n   Example:\n\n   ```bash\n   protoc --cpp_out=. person.proto\n   ```\n\n   This will generate two files: person.pb.cc and person.pb.h that contains the C++ class definitions.\n\n3. **Include protobuf library and generated files into your C++ code:** You’ll need to include the protobuf library and the generated files in your main C++ code.\n\n   Example:\n\n   ```cpp\n   #include <iostream>\n   #include <fstream>\n   #include \"person.pb.h\"\n\n   int main () {\n       GOOGLE_PROTOBUF_VERIFY_VERSION; // Verify that protobuf library headers match library version\n\n       // Serialize a Person message\n       Person person;\n       person.set_name(\"Sam\");\n       person.set_age(35);\n       person.set_email(\"sam@example.com\");\n\n       // Save the data to a file\n       std::ofstream output(\"person.bin\", std::ios::binary);\n       person.SerializeToOstream(&output);\n       output.close();\n\n       // Deserialize the message from the file\n       Person input_person;\n       std::ifstream input(\"person.bin\", std::ios::binary);\n       input_person.ParseFromIstream(&input);\n       input.close();\n\n       // Print the deserialized message\n       std::cout << \"Name: \" << input_person.name() << std::endl;\n       std::cout << \"Age: \" << input_person.age() << std::endl;\n       std::cout << \"Email: \" << input_person.email() << std::endl;\n\n       google::protobuf::ShutdownProtobufLibrary();\n\n       return 0;\n   }\n   ```\n\n4. **Compile and link your C++ code:** Finally, compile your C++ code and link it to the protobuf library.\n\n   Example:\n\n   ```bash\n   g++ -std=c++11 -o main main.cpp person.pb.cc -lprotobuf\n   ```\n\nFor more information and examples, you can refer to the [official protobuf C++ tutorial](https://developers.google.com/protocol-buffers/docs/cpptutorial).",
                  "resources": [
                    {
                      "name": "Official protobuf C++ tutorial",
                      "link": "https://developers.google.com/protocol-buffers/docs/cpptutorial"
                    }
                  ]
                },
                {
                  "name": "gRPC",
                  "recommendation-type": "opinion",
                  "description": "gRPC (gRPC Remote Procedure Calls) is an open-source Remote Procedure Call (RPC) framework that runs on various programming languages, including C++. gRPC is designed to be high-performance, efficient, and scalable, making it ideal for microservice architectures and other applications with high performance requirements.\n\ngRPC uses the Protocol Buffers (Protobuf) serialization format for message exchange and method definition. Protocol Buffers enable more efficient and smaller serialization compared to other formats like JSON or XML.\n\n**Protocol Buffers**\n\nIn gRPC, you start by defining service definitions and message structures in .proto files. You can define data structures and service interfaces using a compact, language-neutral, platform-neutral binary format.\n\nHere’s an example of how that might look:\n\n```proto\nsyntax = \"proto3\";\n\npackage example;\n\n// The gRPC service definition\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The Request message definition\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The Reply message definition\nmessage HelloReply {\n  string message = 1;\n}\n```\n\nAfter defining the .proto file, you use the protoc compiler to generate the corresponding C++ code for your application.\n\n**gRPC C++ Server**\n\nTo create a gRPC server in C++, you first need to implement the service interface generated by the protoc compiler. Here’s an example implementation for the Greeter service:\n\n```cpp\n#include <grpcpp/grpcpp.h>\n#include \"example.grpc.pb.h\"\n\nusing grpc::Server;\nusing grpc::ServerBuilder;\nusing grpc::ServerContext;\nusing grpc::Status;\nusing example::HelloRequest;\nusing example::HelloReply;\nusing example::Greeter;\n\n// ... (The rest of the server code)\n```\n\n**gRPC C++ Client**\n\nSimilarly, to create a gRPC C++ client, you use the generated code from protoc compiler and connect to a server:\n\n```cpp\n#include <grpcpp/grpcpp.h>\n#include \"example.grpc.pb.h\"\n\nusing grpc::Channel;\nusing grpc::ClientContext;\nusing grpc::Status;\nusing example::HelloRequest;\nusing example::HelloReply;\nusing example::Greeter;\n\n// ... (The rest of the client code)\n```\n\nThis is a basic example demonstrating the client-server communication using gRPC in C++. More advanced features like bi-directional streaming, error handling, and authentication can also be used in gRPC. For more information, you can refer to the [gRPC C++ documentation](https://grpc.io/docs/languages/cpp/).",
                  "resources": [
                    {
                      "name": "gRPC C++ documentation",
                      "link": "https://grpc.io/docs/languages/cpp/"
                    }
                  ]
                },
                {
                  "name": "TensorFlow",
                  "recommendation-type": "opinion",
                  "description": "TensorFlow is an open-source machine learning library developed by researchers and engineers from the Google Brain team. It is designed for building, training, and deploying deep learning models. TensorFlow provides a set of tools for ML, deep learning, and numerical computation using data flow graphs. TensorFlow can process computations on GPUs and TPUs, which speed up training time and ensures efficient model deployment.\n\n**Installation**\n\nYou can install TensorFlow using the Python package manager pip:\n\n```plaintext\npip install tensorflow\n```\n\n**Basic usage**\n\nHere’s a simple example of how to create and train a neural network with TensorFlow:\n\n```python\nimport tensorflow as tf\nfrom tensorflow import keras\n\n# Load dataset\n mnist = keras.datasets.mnist\n(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n\n# Preprocess data\ntrain_images = train_images / 255.0\ntest_images = test_images / 255.0\n\n# Define model\nmodel = keras.Sequential([\n    keras.layers.Flatten(input_shape=(28, 28)),\n    keras.layers.Dense(128, activation='relu'),\n    keras.layers.Dense(10, activation='softmax')\n])\n\n# Compile model\nmodel.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\n# Train model\nmodel.fit(train_images, train_labels, epochs=5)\n\n# Evaluate model\ntest_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)\nprint('\\nTest accuracy:', test_acc)\n```\n\nThis code loads the MNIST dataset, preprocesses the data, creates a simple neural network, compiles it, trains it, and evaluates its performance on the test set.\n\nFor more advanced usage, TensorFlow offers several APIs like tf.data, tf.keras, and tf.estimator that enable flexible and efficient data input pipelines, composing and training complex neural network architectures, and managing large-scale distributed training.\n\nYou can visit TensorFlow’s [official website](https://www.tensorflow.org/) and their [GitHub repository](https://github.com/tensorflow/tensorflow) for more information, tutorials, and resources.",
                  "resources": [
                    {
                      "name": "TensorFlow Official Website",
                      "link": "https://www.tensorflow.org/"
                    },
                    {
                      "name": "TensorFlow GitHub Repository",
                      "link": "https://github.com/tensorflow/tensorflow"
                    }
                  ]
                },
                {
                  "name": "Pybind11",
                  "recommendation-type": "opinion",
                  "description": "Pybind11 is a lightweight header-only library that seamlessly integrates C++ code with Python, allowing users to easily expose C++11 code to the Python ecosystem. This is achieved by providing Python bindings that can interact with functions and classes written in C++. It offers an API similar to the Boost.Python library but requires less code, thus leading to better performance.\n\nPybind11 helps in creating library extensions, bringing high-performance C++ code into Python programs, and using Python’s flexibility for rapid development while still benefiting from the efficiency of C++.\n\n**Code Examples**\n\nHere are a few examples of Pybind11 for understanding the concept better:\n\n**Exposing a C++ function to Python:**\n\n```cpp\n#include <pybind11/pybind11.h>\n\nint add(int a, int b) {\n    return a + b;\n}\n\nPYBIND11_MODULE(example, m) {\n    m.def(add, &add, \"A function that adds two numbers\");\n}\n```\n\nRunning the above example will create a Python module named example, containing a single function add. You can use this new function in Python as follows:\n\n```python\nimport example\n\nresult = example.add(1, 2)\nprint(result)  # Output: 3\n```\n\n**Exposing a C++ class to Python:**\n\n```cpp\n#include <pybind11/pybind11.h>\n\nnamespace py = pybind11;\n\nclass MyTestClass {\npublic:\n    MyTestClass(const std::string &name) : name_(name) { }\n\n    const std::string &name() const { return name_; }\n    void setName(const std::string &name) { name_ = name; }\n\nprivate:\n    std::string name_;\n};\n\nPYBIND11_MODULE(example, m) {\n    py::class_<MyTestClass>(m, \"MyTestClass\")\n        .def(py::init<const std::string &>())\n        .def(\"name\", &MyTestClass::name)\n        .def(\"setName\", &MyTestClass::setName);\n}\n```\n\nAfter compiling the code and importing it into Python, you can create MyTestClass instances and call their name() and setName(string) methods:\n\n```python\nimport example\n\nobj = example.MyTestClass(\"some_name\")\nprint(obj.name())  # Output: some_name\n\nobj.setName(\"new_name\")\nprint(obj.name())  # Output: new_name\n```\n",
                  "resources": []
                },
                {
                  "name": "Spdlog",
                  "recommendation-type": "opinion",
                  "description": "spdlog is a fast, header-only, C++ logging library. It provides a simple and efficient way to add diagnostic logging to your C++ application.\n\n**Features:**\n- Header-only, no need to build or link a library\n- Highly configurable, including support for custom log sinks (e.g. writing to a file or a database)\n- Asynchronous and synchronous logging modes\n- Preprocessor-based format string checks to catch bugs at compile-time\n- Easy to extend with custom formatters, sinks, and levels\n\n**Usage example:**\nInclude the spdlog header, create a logger object, and use it to log messages:\n\n```cpp\n#include \"spdlog/spdlog.h\"\n\nint main() {\n    // Create a logger with the name \"example_logger\"\n    auto logger = spdlog::stdout_color_mt(\"example_logger\");\n\n    // Log messages with various severity levels\n    logger->info(\"Welcome to spdlog!\");\n    logger->warn(\"Warning message\");\n    logger->error(\"Error message\");\n\n    return 0;\n}\n```\n\n**Custom sink example:**\nHere’s an example of creating a logger with a custom sink that writes to a text file:\n\n```cpp\n#include \"spdlog/spdlog.h\"\n#include \"spdlog/sinks/basic_file_sink.h\"\n\nint main() {\n    // Create a file sink to write logs to \"logs.txt\"\n    auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(\"logs.txt\");\n\n    // Create a logger with the file sink and the name \"example_logger\"\n    auto logger = std::make_shared<spdlog::logger>(\"example_logger\", file_sink);\n\n    // Register the logger\n    spdlog::register_logger(logger);\n\n    // Log messages\n    logger->info(\"Welcome to spdlog!\");\n    logger->warn(\"Warning message\");\n    logger->error(\"Error message\");\n\n    return 0;\n}\n```\nFor more examples and detailed documentation, visit the [spdlog GitHub repository](https://github.com/gabime/spdlog).",
                  "resources": []
                },
                {
                  "name": "OpenCL",
                  "recommendation-type": "opinion",
                  "description": "OpenCL (Open Computing Language) is a framework for writing programs that enables you to execute code on heterogeneous platforms consisting of CPUs, GPUs, and other processors. It is primarily used for parallel programming, and it can be employed to improve the performance of various applications, including gaming, image and video rendering, and scientific computing.\n\n**Overview**\nOpenCL provides a standardized programming interface, allowing you to target different devices such as graphics cards from different vendors. You can program in C with OpenCL C or C++ with OpenCL C++ kernel language, which are based on the ISO C99 and C++14 respectively, with specific extensions, built-ins, and features to exploit device parallelism.\n\n**Key Concepts**\n- Platform: A collection of devices and software features provided by a vendor.\n- Device: A processing unit that can execute OpenCL code, e.g., a CPU or a GPU.\n- Command queue: A sequence of instructions to be executed on a device.\n- Kernel: A parallelized function that is executed on OpenCL devices.\n- Buffer: A memory object that stores a specific amount of data (e.g., an array of integers or floats) that is accessible by both the host and devices.\n\n**Sample Code**\nHere is a simple OpenCL code example that illustrates how to implement vector addition:\n\n```cpp\n#include <CL/cl.h>\n#include <iostream>\n#include <vector>\n\nconst char *kernelSource = \"__kernel void vector_add(__global int *A, __global int *B, __global int *C, const int N){\"\n                            \"  int i = get_global_id(0);\"\n                            \"  if(i < N){\"\n                            \"    C[i] = A[i] + B[i];\"\n                            \"  }\"\n                            \"}\";\n\nint main(){\n    // Initialize data vectors\n    std::vector<int> A = {1, 2, 3};\n    std::vector<int> B = {4, 5, 6};\n    std::vector<int> C(A.size());\n\n    // Set up OpenCL environment, devices, and context\n    // ... omitted for brevity ...\n\n    // Create memory buffers for A, B, and C\n    // ... omitted for brevity ...\n\n    // Create kernel from source and set kernel arguments\n    // ... omitted for brevity ...\n\n    // Execute kernel using command queue and read output buffer\n    // ... omitted for brevity ...\n\n    // Output results\n    for (size_t i = 0; i < A.size(); ++i) {\n        std::cout << A[i] << \" + \" << B[i] << \" = \" << C[i] << std::endl;\n    }\n    return 0;\n}\n```",
                  "resources": [
                    {
                      "name": "OpenCL Programming Guide",
                      "link": "https://www.khronos.org/registry/OpenCL/"
                    }
                  ]
                },
                {
                  "name": "fmt",
                  "recommendation-type": "opinion",
                  "description": "fmt is a modern C++ formatting library that provides an easy and efficient way to format text and print it to various outputs. The library offers a high level of compatibility with C++ standards, making it suitable for various applications and platforms. fmt emphasizes simplicity, extensibility, and type safety.\n\n**Features**\n- Supports positional and named arguments for better readability in complex formatting tasks\n- Supports format string syntax similar to Python’s str.format()\n- Provides compile-time format string checks for type safety\n- Extensive documentation and user-friendly API\n\n**Example Usage**\nHere are some examples of how to use the fmt library:\n\n**Basic Usage**\n```cpp\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"Hello, world!\\n\");\n    return 0;\n}\n```\n**Formatting with Positional Arguments**\n```cpp\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"The answer is {}.\\n\", 42);\n    fmt::print(\"{1}, {0}!\\n\", \"world\", \"Hello\");\n    return 0;\n}\n```\n**Formatting with Named Arguments**\n```cpp\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"Hello, {name}!\\n\", fmt::arg(\"name\", \"world\"));\n    return 0;\n}\n```\n**Using Format String Syntax**\n```cpp\n#include <fmt/core.h>\n\nint main() {\n    fmt::print(\"{:<30}\", \"left-aligned\");\n    fmt::print(\"{:>30}\", \"right-aligned\");\n    fmt::print(\"{:^30}\", \"center-aligned\");\n    fmt::print(\"{:*^30}\", \"center-aligned\");\n\n    fmt::print(\"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\", 42);\n    fmt::print(\"{:.2f}\", 3.1415926);\n    fmt::print(\"{:010.2f}\", 3.1415926);\n\n    return 0;\n}\n```\nFor more information, you can refer to the [official fmt documentation](https://fmt.dev/).",
                  "resources": [
                    {
                      "name": "fmt Documentation",
                      "link": "https://fmt.dev/"
                    }
                  ]
                },
                {
                  "name": "Ranges v3",
                  "recommendation-type": "opinion",
                  "description": "Ranges v3 is a C++ library designed to work with ranges of values, rather than individual values. It provides a set of utilities and algorithms to manipulate and transform ranges of values in an efficient and expressive way. The library is inspired by the Range concept proposed for inclusion in the C++ standard library for C++20.\n\n**Overview**\nRanges v3 includes three main components:\n\n1. **Range adaptors**: Composable algorithms that transform a range into a new range. They help to create lazy views over the data without actually modifying it.\n2. **Action adaptors**: Algorithms that modify a range in-place, such as sorting or filtering elements in a container directly.\n3. **Trait concepts and utility functions**: Provide tools for working with range types, like determining if a type is a range, getting the iterator type for a range, etc.\n\n**Code examples**\nHere are some code examples of using the Ranges v3 library:\n\n**Including the library**\nFirst, you need to include the appropriate header files from the library. To use the entire Ranges v3 library, you can simply include the `range/v3/all.hpp` header file:\n```cpp\n#include <range/v3/all.hpp>\n```\n**Using range adaptors**\nYou can use range adaptors to manipulate and transform ranges. For example, you can use the `view::filter` and `view::transform` adaptors to create a new range containing only even numbers and then square them:\n```cpp\n#include <iostream>\n#include <range/v3/all.hpp>\n\nusing namespace ranges;\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n\n    // Create a new range containing only even numbers, and then square them.\n    auto even_squares = numbers | view::filter([](int n) { return n % 2 == 0; })\n                                 | view::transform([](int n) { return n * n; });\n\n    // Print the even_squares range.\n    for (auto n : even_squares) {\n        std::cout << n << ' ';\n    }\n    // Output: 4 16 36\n\n    return 0;\n}\n```\n**Using action adaptors**\nAction adaptors are used to modify ranges in-place. For example, you can use the `action::sort` and `action::unique` adaptors to sort and remove duplicate elements from a container:\n```cpp\n#include <iostream>\n#include <range/v3/all.hpp>\n\nusing namespace ranges;\n\nint main() {\n    std::vector<int> numbers = {5, 3, 1, 4, 4, 2, 2};\n\n    // Sort the numbers and remove duplicates.\n    numbers |= action::sort | action::unique;\n\n    // Print the modified numbers vector.\n    for (auto n : numbers) {\n        std::cout << n << ' ';\n    }\n    // Output: 1 2 3 4 5\n\n    return 0;\n}\n```\nRanges v3 provides a wide range of adaptors and actions to work with ranges in a more expressive and efficient way. You can explore more in the [official documentation](https://ericniebler.github.io/range-v3/).",
                  "resources": [
                    {
                      "name": "Ranges v3 Documentation",
                      "link": "https://ericniebler.github.io/range-v3/"
                    }
                  ]
                }
              ]
            }
          },
          {
            "Frameworks": {
              "options": [
                {
                  "name": "Google Test (gtest)",
                  "recommendation-type": "opinion",
                  "description": "Google Test, also known as gtest or google test, is a C++ testing framework developed by Google. It provides a user-friendly API for writing test cases and is designed for use in a range of applications, from simple unit tests to complex system-level tests.\n\n**Getting Started with Google Test**\nTo use Google Test in your project, follow these steps:\n\n1. Download the source code from the [GoogleTest GitHub repository](https://github.com/google/googletest).\n2. Build and install Google Test on your system. Instructions for various platforms can be found in the README file.\n3. Include the necessary headers and link against the Google Test library in your project.\n\n**Writing a Test with Google Test**\nHere’s an example of how to write a simple test using Google Test:\n\n1. Include the necessary headers\n```cpp\n#include \"gtest/gtest.h\"\n```\n2. Write the functions you want to test\n\nSuppose we have a simple function to test:\n```cpp\nint add(int a, int b) {\n   return a + b;\n}\n```\n3. Write the test cases\n\nTo create a test case, use the TEST() macro, which takes two arguments: the test suite name and the test case name.\n```cpp\n// Test the 'add' function.\nTEST(AdditionTest, PositiveNumbers) {\n   EXPECT_EQ(3, add(1, 2));\n   EXPECT_EQ(5, add(2, 3));\n}\n\nTEST(AdditionTest, NegativeNumbers) {\n   EXPECT_EQ(-3, add(-1, -2));\n   EXPECT_EQ(-5, add(-2, -3));\n}\n```\n4. Write a main() function\n\nIn order to run the tests, include a main() function that initializes Google Test and runs the tests.\n```cpp\nint main(int argc, char **argv) {\n   ::testing::InitGoogleTest(&argc, argv);\n   return RUN_ALL_TESTS();\n}\n```\n5. Compile and run the tests\n\nCompile your test program with the Google Test library and run the test executable.\n\n**More Features**\nGoogle Test offers a wide range of features to make testing easier, such as:\n\n- **Test Fixtures**: Test fixtures allow you to reuse the same set of objects for multiple tests. You can define a test fixture by creating a class that inherits from ::testing::Test and writing setup and teardown methods.\n\n- **Assertions**: Google Test provides a variety of assertion macros to help you verify your code’s behavior. Some common ones include EXPECT_EQ, EXPECT_TRUE, EXPECT_FALSE, ASSERT_EQ, ASSERT_TRUE, and ASSERT_FALSE.\n\n- **Parameterized Tests**: Google Test supports parameterized tests, allowing you to run the same test with different inputs easily.\n\n- **Death Tests**: Google Test allows you to write tests that verify if your code terminates correctly or with the expected error message.\n\nFor more information about Google Test and its features, refer to the [official documentation](https://github.com/google/googletest).",
                  "resources": [
                    {
                      "name": "GoogleTest GitHub Repository",
                      "link": "https://github.com/google/googletest"
                    },
                    {
                      "name": "Google Test Official Documentation",
                      "link": "https://github.com/google/googletest"
                    }
                  ]
                },
                {
                  "name": "Qt Framework",
                  "recommendation-type": "opinion",
                  "description": "Qt is an open-source, cross-platform framework for creating high-performance applications with interactive user interfaces. It is mainly used for developing GUI applications but can also be used for creating non-GUI applications like console tools and servers.\n\nQt provides a wide range of C++ libraries and seamless integration with popular IDEs, making it easier for developers to create feature-rich applications. It offers a comprehensive development environment, including tools for designing, coding, debugging, and profiling applications.\n\n**Key Features**\n\n- **Cross-platform**: Qt can create applications that run on different platforms (e.g., Windows, macOS, Linux, Android, iOS) without any platform-specific code.\n\n- **Modular Libraries**: Qt consists of several modular libraries, including QtCore (core non-GUI functionality), QtGui (GUI-related classes), QtWidgets (GUI widgets), and QtNetwork (networking support).\n\n- **Signals and Slots**: Qt provides a unique mechanism to handle events called “signals and slots”, which allows safe and flexible inter-object communication.\n\n- **OpenGL Integration**: Qt supports rendering 2D and 3D graphics using OpenGL, making it suitable for game development and other graphical applications.\n\n**Code Example**\n\nHere’s a simple example of a “Hello, World!” application using Qt:\n\n```cpp\n#include <QApplication>\n#include <QLabel>\n\nint main(int argc, char *argv[])\n{\n    QApplication app(argc, argv);\n\n    QLabel label(\"Hello, World!\");\n    label.show();\n\n    return app.exec();\n}\n```\n\nIn this example, we include the necessary header files, create QApplication and QLabel objects, display the label with a “Hello, World!” message, and execute the application.\n\nTo compile and run this example, you need to install the Qt library and configure your development environment to use it.\n\nFor more information and tutorials about Qt, you can refer to the [official Qt documentation](https://doc.qt.io/).",
                  "resources": [
                    {
                      "name": "Official Qt Documentation",
                      "link": "https://doc.qt.io/"
                    }
                  ]
                },
                {
                  "name": "Catch2",
                  "recommendation-type": "opinion",
                  "description": "Catch2 is a modern, C++-native, test framework for unit tests, TDD, and BDD. It is a single-header library, meaning you only need to include one header file (catch.hpp) to start using it. Catch2 is fast, easy to use, and supports various test styles.\n\n**Features**\n\n- **Single-header**: Just #include \"catch.hpp\" and start writing tests.\n\n- **Test cases**: Declare test cases using the TEST_CASE macro.\n\n- **Sections**: Divide test cases into sections using SECTION macro.\n\n- **BDD**: Behavior-Driven Development style supported with SCENARIO, GIVEN, WHEN, THEN.\n\n- **Matchers**: Use rich built-in matchers for more expressive assertions.\n\n- **Test discovery**: Catch2 automatically discovers your test cases and sections.\n\n**Code examples**\n\n**Basic test case**\n```cpp\n#define CATCH_CONFIG_MAIN  // Tells Catch to provide a main() function\n#include \"catch.hpp\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nTEST_CASE(\"Addition\") {\n    REQUIRE(add(2, 3) == 5);\n}\n```\n\n**Sections**\n```cpp\nTEST_CASE(\"Sections example\") {\n    int a = 1;\n\n    SECTION(\"incrementing a\") {\n        a++;\n        REQUIRE(a == 2);\n    }\n\n    SECTION(\"decrementing a\") {\n        a--;\n        REQUIRE(a == 0);\n    }\n}\n```\n\n**BDD style**\n```cpp\nSCENARIO(\"vector can be sized and resized\", \"[vector]\") {\n    std::vector<int> v;\n\n    GIVEN(\"A vector with some items\") {\n        v.push_back(1);\n        v.push_back(2);\n        v.push_back(3);\n\n        REQUIRE(v.size() == 3);\n\n        WHEN(\"the size is increased\") {\n            v.resize(5);\n\n            THEN(\"the size and contents change\") {\n                REQUIRE(v.size() == 5);\n                REQUIRE(v[3] == 0);\n                REQUIRE(v[4] == 0);\n            }\n        }\n        WHEN(\"the size is reduced\") {\n            v.resize(2);\n\n            THEN(\"the size changes but not the contents\") {\n                REQUIRE(v.size() == 2);\n                REQUIRE(v[0] == 1);\n                REQUIRE(v[1] == 2);\n            }\n        }\n    }\n}\n```\n\n**Matchers**\n```cpp\nTEST_CASE(\"Matchers example\") {\n    std::string str = \"Hello, world!\";\n\n    CHECK_THAT(str, Catch::Matchers::StartsWith(\"Hello\"));\n    CHECK_THAT(str, Catch::Matchers::EndsWith(\"world!\"));\n    CHECK_THAT(str, Catch::Matchers::Contains(\"lo, wo\"));\n}\n```\n\nFor more information, visit the [Catch2 GitHub repository](https://github.com/catchorg/Catch2).",
                  "resources": [
                    {
                      "name": "Catch2 GitHub Repository",
                      "link": "https://github.com/catchorg/Catch2"
                    }
                  ]
                },
                {
                  "name": "Orbit Profiler",
                  "recommendation-type": "opinion",
                  "description": "Orbit Profiler is a performance profiler for C++ applications. It is designed to provide developers with real-time feedback on their application’s performance and help them identify performance bottlenecks. It supports both Windows and Linux platforms, profiling both local and remote processes.\n\n**Major features of Orbit Profiler:**\n\n- Sampling-based profiling\n- Instrumentation-based profiling\n- Callstacks collection\n- Frame-based measurements using scopes macros\n\n**Usage**\n\n**Include OrbitProfiler.h:** First, you need to include the OrbitProfiler.h header file in your project:\n```cpp\n#include \"OrbitProfiler.h\"\n```\n\n**Starting and Stopping the profiler:** Use ORBIT_START and ORBIT_STOP to start and stop the profiler.\n```cpp\nORBIT_START();\n// Your application code here\nORBIT_STOP();\n```\n\n**Instrumenting scopes:** Use the ORBET_SCOPE macro to annotate the scope of the function you want to measure:\n```cpp\nvoid ExampleFunction() {\n  ORBIT_SCOPE(\"Example Function\");\n  // Function content here\n}\n```\n\n**Visualizing the captured data:** Orbit Profiler provides a Session View that displays the captured data and allows you to navigate through the timeline, analyze data, and identify performance bottlenecks.\n\n**Example**\n\nFor demonstration purposes, consider the following example of a simple C++ application:\n```cpp\n#include \"OrbitProfiler.h\"\n\nvoid FunctionA() {\n  ORBIT_SCOPE(\"Function A\");\n  // Function A code here\n}\n\nvoid FunctionB() {\n  ORBIT_SCOPE(\"Function B\");\n  // Function B code here\n}\n\nint main() {\n  ORBIT_START();\n\n  FunctionA();\n  FunctionB();\n\n  ORBIT_STOP();\n  return 0;\n}\n```\nBy using Orbit Profiler, we are able to pinpoint performance issues in FunctionA and FunctionB and optimize our application accordingly.\n\nFor more information, refer to the [official Orbit Profiler GitHub repository](https://github.com/bombomby/opt).\n",
                  "resources": [
                    {
                      "name": "Orbit Profiler GitHub Repository",
                      "link": "https://github.com/bombomby/opt"
                    }
                  ]
                },
                {
                  "name": "PyTorch C++",
                  "recommendation-type": "opinion",
                  "description": "PyTorch C++ is the C++ API (Application Programming Interface) for PyTorch. It is also known as LibTorch, which is a library that provides almost all the functionality of PyTorch accessible through C++ language. The main goal of providing a C++ API is to enable high-performance integration with other deep learning platforms and enable seamless operation in enterprise and production-level systems.\n\n**Installation**\n\nTo use the PyTorch C++ API, you need to install the LibTorch distribution. Follow the instructions on the [official PyTorch C++ API page](https://pytorch.org/get-started/locally/) to install the library based on your platform and requirements.\n\n**Example: Tensors**\n```cpp\n#include <iostream>\n#include <torch/torch.h>\n\nint main() {\n  // Create a 3x3 matrix with zeros.\n  torch::Tensor a = torch::zeros({3, 3});\n  std::cout << a << std::endl;\n\n  // Create a 2x2 matrix with ones and convert to float.\n  torch::Tensor b = torch::ones({2, 2}).to(torch::kFloat);\n  std::cout << b << std::endl;\n\n  // Create a random tensor size 2x2 and specify its type.\n  torch::Tensor c = torch::randint(0, 10, {2, 2}, torch::kInt);\n  std::cout << c << std::endl;\n\n  // Perform element-wise addition.\n  auto sum = b + c.to(torch::kFloat);\n  std::cout << sum << std::endl;\n}\n```\n**Example: Creating a Custom Module**\n```cpp\n#include <iostream>\n#include <torch/torch.h>\n\n// Define a custom module.\nstruct Net : torch::nn::Module {\n  Net() {\n    fc1 = register_module(\"fc1\", torch::nn::Linear(784, 64));\n    fc2 = register_module(\"fc2\", torch::nn::Linear(64, 10));\n  }\n\n  torch::Tensor forward(torch::Tensor x) {\n    x = x.view({-1, 784});\n    x = torch::relu(fc1->forward(x));\n    x = torch::log_softmax(fc2->forward(x), 1);\n    return x;\n  }\n\n  torch::nn::Linear fc1{nullptr};\n  torch::nn::Linear fc2{nullptr};\n};\n\nint main() {\n  // Create an instance of the custom module.\n  Net net;\n\n  // Use the custom module.\n  torch::Tensor input = torch::randn({2, 1, 28, 28});\n  torch::Tensor output = net.forward(input);\n  std::cout << output << std::endl;\n\n  return 0;\n}\n```\nIn these examples, we demonstrated how to use various tensor operations and how to create a custom neural network module with PyTorch C++. For more detailed information and tutorials, visit the [official PyTorch C++ documentation](https://pytorch.org/tutorials/advanced/cpp_frontend.html).\n",
                  "resources": [
                    {
                      "name": "Official PyTorch C++ API Page",
                      "link": "https://pytorch.org/get-started/locally/"
                    },
                    {
                      "name": "Official PyTorch C++ Documentation",
                      "link": "https://pytorch.org/tutorials/advanced/cpp_frontend.html"
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      "Continue Learning with following relevant tracks": {
        "resources": [
          {
            "name": "Backend Roadmap",
            "link": "https://roadmap.sh/backend"
          }
        ]
      }
    }
  }
}